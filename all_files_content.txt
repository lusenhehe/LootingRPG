

===================== [D:\download\LootingRPG\src\app\context\auth.ts] =====================
export interface AuthContext {
  profiles: any[];
  activeProfileId: string | null;
  isAuthenticated: boolean;
  handleLogin: (id: string) => void;
  handleCreateProfile: (name: string) => void;
  handleDeleteProfile: (id: string) => void;
  handleExportSave: () => void;
  handleImportSave: () => void;
  handleLogoutAction: () => void;
  loadProfile: (id: string) => void;
}


===================== [D:\download\LootingRPG\src\app\context\autoSell.ts] =====================
export interface AutoSellContext {
  autoSellQualities: Record<string, boolean>;
  handleToggleAutoSellQuality: (quality: string) => void;
  setAutoSellQualities: React.Dispatch<React.SetStateAction<Record<string, boolean>>>;
}


===================== [D:\download\LootingRPG\src\app\context\battle.ts] =====================
export interface BattleContext {
  handleEnterMapNode: (
    node: import('../../config/map/ChapterData').MapNodeDef,
    chapter: import('../../config/map/ChapterData').MapChapterDef,
  ) => void;
  handleBattleAttack: () => void;
  handleBattleRetreat: () => void;
}


===================== [D:\download\LootingRPG\src\app\context\debug.ts] =====================
export interface DebugContext {
  handleDebugAddItems: (quality: string, slot: string, count: number, level?: number) => void;
}


===================== [D:\download\LootingRPG\src\app\context\index.ts] =====================
export * from './auth';
export * from './state';
export * from './log';
export * from './autoSell';
export * from './map';
export * from './battle';
export * from './inventory';
export * from './debug';
export * from './misc';


===================== [D:\download\LootingRPG\src\app\context\inventory.ts] =====================
export interface InventoryContext {
  quickSellByQualityRange: (minQuality: string, maxQuality: string) => void;
  handleEquip: (id: string) => void;
  handleSell: (id: string) => void;
  handleForge: (id: string) => void;
  handleReroll: (id: string, locks?: string[]) => void;
  handleUnequip: (slot: string) => void;
}


===================== [D:\download\LootingRPG\src\app\context\log.ts] =====================
export interface LogContext {
  logs: string[];
  addLog: (msg: string) => void;
  setLogs: React.Dispatch<React.SetStateAction<string[]>>;
}


===================== [D:\download\LootingRPG\src\app\context\map.ts] =====================
import type { MapProgressState, ActiveTab } from '../../types/game';

export interface MapContext {
  mapProgress: MapProgressState;
  setMapProgress: React.Dispatch<React.SetStateAction<MapProgressState>>;
  activeTab: ActiveTab;
  setActiveTab: React.Dispatch<React.SetStateAction<ActiveTab>>;
  focusMapNode: string | null;
  setFocusMapNode: React.Dispatch<React.SetStateAction<string | null>>;
}


===================== [D:\download\LootingRPG\src\app\context\misc.ts] =====================
export interface MiscContext {
  handleReset: () => void;
}


===================== [D:\download\LootingRPG\src\app\context\state.ts] =====================
import type { GameState } from '../../types/game';

export interface StateContext {
  gameState: GameState;
  dispatchGameState: React.Dispatch<
    | { type: 'RESET' }
    | { type: 'SET'; payload: GameState }
  >;
  loading: boolean;
  setLoading: React.Dispatch<React.SetStateAction<boolean>>;
  forgeSelectedId: string | null;
  setForgeSelectedId: React.Dispatch<React.SetStateAction<string | null>>;
}


===================== [D:\download\LootingRPG\src\app\state\globalState.ts] =====================
import { INITIAL_STATE } from '../../config/game/gameConfig';
import type { GameState } from '../../types/game';

/**
 * Creates a fresh initial game state for a new player
 */
export const createFreshInitialState = (): GameState => structuredClone(INITIAL_STATE);


===================== [D:\download\LootingRPG\src\app\state\index.ts] =====================
import { normalizeInventory } from './inventoryState';
import type { BattleSession, GameState } from '../../shared/types/game';

const normalizeBattleSession = (session: BattleSession | null): BattleSession | null => {
  if (!session) return null;

  const enemies = (session.enemies ?? []).map((enemy, index) => ({
    ...enemy,
    meta: {
      ...(enemy.meta ?? {}),
      waveId:
        typeof enemy.meta?.waveId === 'string'
          ? enemy.meta.waveId
          : `wave-${index + 1}`,
    },
  }));

  const inferredWaveOrder = Array.from(
    new Set(
      enemies.map((enemy, index) =>
        typeof enemy.meta?.waveId === 'string' ? enemy.meta.waveId : `wave-${index + 1}`,
      ),
    ),
  );
  const existingWaveOrder = Array.isArray(session.waveOrder) ? session.waveOrder : [];
  const waveOrder = existingWaveOrder.length > 0
    ? existingWaveOrder.filter((waveId) => inferredWaveOrder.includes(waveId))
    : inferredWaveOrder;

  const safeWaveOrder = waveOrder.length > 0 ? waveOrder : inferredWaveOrder;
  const maxIndex = Math.max(0, safeWaveOrder.length - 1);
  const currentWaveIndex = Number.isFinite(session.currentWaveIndex)
    ? Math.max(0, Math.min(maxIndex, session.currentWaveIndex))
    : 0;

  return {
    ...session,
    enemies,
    waveOrder: safeWaveOrder,
    currentWaveIndex,
    phase: session.phase ?? 'player_input',
    events: Array.isArray(session.events) ? session.events : [],
  };
};

/**
 * Normalizes the entire game state, including inventory and equipment
 */
export const normalizeGameState = (state: GameState): GameState => {
  const { normalizedBackpack, normalizedCurrent } = normalizeInventory(state.backpack, state.currentEquipment);

  return {
    ...state,
    backpack: normalizedBackpack,
    currentEquipment: normalizedCurrent,
    battle: {
      activeSession: normalizeBattleSession(state.battle?.activeSession ?? null),
      history: Array.isArray(state.battle?.history) ? state.battle.history : [],
    },
  };
};

// Re-export all state creation and management functions
export { createFreshInitialState } from './globalState';
export { normalizeInventory } from './inventoryState';

// Export the StateManager class
export { StateManager } from './stateManager';


===================== [D:\download\LootingRPG\src\app\state\inventoryState.ts] =====================
import type { Equipment } from '../../types/game';

/**
 * Normalizes equipment data and ensures structural consistency
 */
const normalizeEquipment = (item: Equipment): Equipment => {
  const quality = item.quality;
  const slot = item.slot;

  const attrs: Record<string, number> = {};
  Object.entries(item.attributes).forEach(([k, v]) => {
    attrs[k] = v;
  });

  const main = item.mainStat;

  return {
    ...item,
    level: Math.max(1, Number(item.level) || 1),
    quality,
    slot,
    icon: item.icon,
    attributes: attrs,
    mainStat: main,
    affixes: Array.isArray(item.affixes) ? item.affixes : [],
    localeNames: item.localeNames || undefined,
  };
};

/**
 * Normalizes the inventory and equipped items in the game state
 */
import { SLOTS } from '../../config/game/equipment';

export const normalizeInventory = (backpack: Equipment[], currentEquipment: Record<string, Equipment | null>) => {
  const normalizedBackpack = backpack.map((item) => ({ ...normalizeEquipment(item), equipped: false }));

  // ensure every configured slot exists in the normalized output
  const normalizedCurrent = Object.fromEntries(
    SLOTS.map((slot) => {
      const item = currentEquipment[slot] || null;
      return [slot, item ? { ...normalizeEquipment(item), equipped: true } : null];
    }),
  ) as Record<string, Equipment | null>;

  return {
    normalizedBackpack,
    normalizedCurrent,
  };
};


===================== [D:\download\LootingRPG\src\app\state\stateManager.ts] =====================
import { createFreshInitialState, normalizeGameState } from './index';
import type { GameState } from '../../types/game';

/**
 * State Manager - Unified interface for all game state operations
 * This provides a single entry point for state creation and management
 * to prevent the gameState.ts from becoming a God Object.
 */
export class StateManager {
  /**
   * Creates a complete fresh game state including player and inventory state
   */
  static createFreshGameState(): GameState {
    return createFreshInitialState();
  }

  /**
   * Normalizes game state data (e.g., after loading from save)
   */
  static normalizeState(state: GameState): GameState {
    return normalizeGameState(state);
  }
}

// Re-export for convenience
export { createFreshInitialState, normalizeGameState } from './index';


===================== [D:\download\LootingRPG\src\app\AppShell.tsx] =====================
import { LoginScreen } from '../components/auth/LoginScreen';
import { GameScreen }  from '../components/game/GameScreen';
import { useGame }     from './GameContext';

export function AppShell() {
  const {
    profiles,
    activeProfileId,
    isAuthenticated,
    gameState,
    loading,
    activeTab,
    autoSellQualities,
    forgeSelectedId,
    mapProgress,
    focusMapNode,
    setActiveTab,
    setMapProgress,
    setFocusMapNode,
    setForgeSelectedId,
    handleLogin,
    handleCreateProfile,
    handleDeleteProfile,
    handleExportSave,
    handleImportSave,
    handleLogoutAction,
    handleReset,
    handleEnterMapNode,
    handleBattleAttack,
    handleBattleRetreat,
    handleToggleAutoSellQuality,
    quickSellByQualityRange,
    handleEquip,
    handleSell,
    handleForge,
    handleReroll,
    handleUnequip,
    handleDebugAddItems,
  } = useGame();

  if (!isAuthenticated) {
    return (
      <LoginScreen
        profiles={profiles}
        onLogin={handleLogin}
        onCreate={handleCreateProfile}
        onDelete={handleDeleteProfile}
      />
    );
  }

  const currentProfile = profiles.find((profile: import('../shared/types/game').SaveProfile) => profile.id === activeProfileId);

  return (
    <GameScreen
      gameState={gameState}
      activeTab={activeTab}
      loading={loading}
      playerName={currentProfile?.name || 'Unknown Player'}
      autoSellQualities={autoSellQualities}
      forgeSelectedId={forgeSelectedId}
      battleSession={gameState.battle.activeSession}
      playerStats={gameState.playerStats}
      onExportSave={handleExportSave}
      onImportSave={handleImportSave}
      onLogout={handleLogoutAction}
      onReset={handleReset}
      mapProgress={mapProgress}
      onSelectMapChapter={(chapterId) => {
        setMapProgress((prev: import('../shared/types/game').MapProgressState) => ({ ...prev, selectedChapterId: chapterId }));
      }}
      focusMapNode={focusMapNode}
      onClearFocusMapNode={() => setFocusMapNode(null)}
      onSetTab={setActiveTab}
      onEnterMapNode={handleEnterMapNode}
      onBattleAttack={handleBattleAttack}
      onBattleRetreat={handleBattleRetreat}
      onQuickSellByQualityRange={quickSellByQualityRange}
      onEquip={handleEquip}
      onSell={handleSell}
      onForge={handleForge}
      onToggleAutoSellQuality={handleToggleAutoSellQuality}
      onReroll={handleReroll}
      onSelectForgeItem={setForgeSelectedId}
      onUnequip={handleUnequip}
      onDebugAddItems={handleDebugAddItems}
    />
  );
}


===================== [D:\download\LootingRPG\src\app\GameContext.tsx] =====================
import React, { createContext, useContext, useReducer, useState, useCallback } from 'react';
import { createFreshInitialState } from './state';
import type {GameState} from '../shared/types/game';
import { createInitialMapProgress } from '../domains/map/services/progress';
import { MAP_CHAPTERS } from '../config/map/ChapterData';
import { useProfileSave } from '../hooks/profile/useProfileSave';
import { useInventoryActions } from '../hooks/game/useInventoryActions';
import { ACTIVE_PROFILE_KEY } from '../config/runtime/storage';

// smaller hooks
import { useGameLogger } from '../hooks/game/useGameLogger';
import { useAutoSell } from '../hooks/game/useAutoSell';
import { useMapProgress } from '../hooks/game/useMapProgress';
import { useBattleSession } from '../hooks/game/useBattleSession';
import { useDebug } from '../hooks/game/useDebug';

// --- game state reducer --------------------------------------------------

type GameStateAction =
  | { type: 'RESET' }
  | { type: 'SET'; payload: GameState };

function gameReducer(state: GameState, action: GameStateAction): GameState {
  switch (action.type) {
    case 'RESET':
      return createFreshInitialState();
    case 'SET':
      return action.payload;
    default:
      return state;
  }
}
const GameContext = createContext<any>(undefined);

export const GameProvider: React.FC<React.PropsWithChildren<unknown>> = ({ children }) => {
  const [gameState, dispatchGameState] = useReducer(
    gameReducer,
    undefined,
    () => createFreshInitialState(),
  );
  const setGameState: React.Dispatch<React.SetStateAction<GameState>> = useCallback(
    (value) => {
      if (typeof value === 'function') {
        // cast because TS can't infer from overloaded Dispatch type
        const updater = value as (prev: GameState) => GameState;
        dispatchGameState({ type: 'SET', payload: updater(gameState) });
      } else {
        dispatchGameState({ type: 'SET', payload: value });
      }
    },
    [gameState],
  );

  const [loading, setLoading] = useState(false);
  const [forgeSelectedId, setForgeSelectedId] = useState<string | null>(null);

  const { logs, setLogs, addLog } = useGameLogger();
  const {
    autoSellQualities,
    toggleQuality: handleToggleAutoSellQuality,
    setAutoSellQualities,
  } = useAutoSell();
  const {
    mapProgress,
    setMapProgress,
    activeTab,
    setActiveTab,
    focusMapNode,
    setFocusMapNode,
  } = useMapProgress();

  const { handleBattleAttack, handleBattleRetreat, handleEnterMapNode } = useBattleSession({
    gameState,
    mapProgress,
    setGameState,
    setMapProgress,
    addLog,
    setActiveTab,
    setFocusMapNode,
  });

  const {
    profiles,
    activeProfileId,
    isAuthenticated,
    handleLogin,
    handleCreateProfile,
    handleDeleteProfile,
    handleExportSave,
    handleImportSave,
    handleLogout,
    loadProfile,
  } = useProfileSave({
    gameState,
    logs,
    autoSellQualities,
    mapProgress,
    setGameState,
    setLogs,
    setAutoSellQualities,
    setMapProgress,
    addLog,
  });

  const reportError = useCallback(
    (err: unknown, context: { action?: string } = {}) => {
      const message = err instanceof Error ? err.message : String(err);
      const parts = [`[Error] ${message}`, `profile=${activeProfileId}`];
      if (context.action) parts.push(`action=${context.action}`);
      addLog(parts.join(' '));
    },
    [activeProfileId, addLog],
  );

  const { quickSellByQualityRange, processAction } = useInventoryActions({
    gameState,
    loading,
    setGameState,
    setLoading,
    addLog,
    reportError,
  });

  const handleEquip = useCallback((id: string) => processAction({ type: 'equip', itemId: id }), [processAction]);
  const handleSell = useCallback((id: string) => processAction({ type: 'sell', itemId: id }), [processAction]);
  const handleForge = useCallback((id: string) => processAction({ type: 'enchant', itemId: id }), [processAction]);
  const handleReroll = useCallback(
    (id: string, lockTypes?: string[]) => processAction({ type: 'reroll', itemId: id, lockTypes }),
    [processAction],
  );
  const handleUnequip = useCallback((slot: string) => processAction({ type: 'unequip_slot', slot }), [processAction]);

  const handleLogoutAction = useCallback(() => {
    handleLogout();
    setLoading(false);
    localStorage.removeItem(ACTIVE_PROFILE_KEY);
  }, [handleLogout]);

  const handleReset = useCallback(() => {
    if (confirm('浣犵‘瀹氳閲嶇疆褰撳墠瀛樻。鍚楋紵姝ゆ搷浣滄棤娉曟挙閿€銆?)) {
      setGameState(createFreshInitialState());
      setLoading(false);
      setLogs(['[System] 瀛樻。宸查噸缃畬鎴愩€俿torage 宸叉竻闄ゃ€?]);
      setMapProgress(createInitialMapProgress(MAP_CHAPTERS));
    }
  }, [setGameState, setLoading, setLogs, setMapProgress]);

  const { handleDebugAddItems } = useDebug({ gameState, setGameState, addLog });
  const value = {
    profiles,
    activeProfileId,
    isAuthenticated,
    handleLogin,
    handleCreateProfile,
    handleDeleteProfile,
    handleExportSave,
    handleImportSave,
    handleLogoutAction,
    loadProfile,

    gameState,
    dispatchGameState,
    loading,
    setLoading,
    forgeSelectedId,
    setForgeSelectedId,

    logs,
    addLog,
    setLogs,

    autoSellQualities,
    handleToggleAutoSellQuality,
    setAutoSellQualities,

    mapProgress,
    setMapProgress,
    activeTab,
    setActiveTab,
    focusMapNode,
    setFocusMapNode,

    handleEnterMapNode,
    handleBattleAttack,
    handleBattleRetreat,

    quickSellByQualityRange,
    handleEquip,
    handleSell,
    handleForge,
    handleReroll,
    handleUnequip,

    handleDebugAddItems,

    handleReset,
  };

  return <GameContext.Provider value={value}>{children}</GameContext.Provider>;
};

export function useGame() {
  const ctx = useContext(GameContext);
  if (!ctx) {
    throw new Error('useGame must be used within a GameProvider');
  }
  return ctx;
}


===================== [D:\download\LootingRPG\src\components\auth\LoginScreen.tsx] =====================
import { LogIn, Plus, Trash2, User } from 'lucide-react';
import { useState } from 'react';
import { motion } from 'motion/react';
import { useTranslation } from 'react-i18next';
import type { SaveProfile } from '../../types/game';

interface LoginScreenProps {
  profiles: SaveProfile[];
  onLogin: (profileId: string) => void;
  onCreate: (name: string) => void;
  onDelete: (profileId: string) => void;
}

export function LoginScreen({ profiles, onLogin, onCreate, onDelete }: LoginScreenProps) {
  const { t } = useTranslation();
  const [name, setName] = useState('');
  return (
    <div className="min-h-screen flex items-center justify-center p-4 md:p-8 relative overflow-hidden">
      <div className="pointer-events-none absolute -top-32 -left-32 w-96 h-96 bg-red-900/30 blur-3xl rounded-full animate-pulse" />
      <div className="pointer-events-none absolute -bottom-32 -right-32 w-96 h-96 bg-rose-500/10 blur-3xl rounded-full animate-pulse" style={{ animationDelay: '1s' }} />
      <div className="pointer-events-none absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[600px] h-[600px] bg-gradient-radial from-red-900/10 via-transparent to-transparent rounded-full" />
      
      <div className="absolute inset-0 pointer-events-none overflow-hidden">
        <div className="absolute inset-0 bg-[linear-gradient(rgba(18,16,22,0)_50%,rgba(0,0,0,0.1)_50%),linear-gradient(90deg,rgba(255,0,0,0.02),rgba(0,255,0,0.01),rgba(0,0,255,0.02))] z-[1] bg-[length:100%_4px,6px_100%]" />
      </div>

      <motion.div 
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        className="w-full max-w-4xl grid grid-cols-1 lg:grid-cols-2 gap-6 relative z-10"
      >
        <section className="bg-gradient-to-br from-game-card/90 to-game-card/60 backdrop-blur-sm border border-game-border/50 rounded-2xl p-6 shadow-2xl shadow-red-900/10 relative overflow-hidden">
          <div className="absolute inset-0 bg-gradient-to-br from-red-900/10 to-transparent" />
          <div className="absolute -top-20 -right-20 w-40 h-40 bg-red-900/20 rounded-full blur-3xl" />
          
          <div className="relative z-10">
            <h2 className="text-xl font-display mb-1 text-transparent bg-clip-text bg-gradient-to-r from-red-400 to-red-600">{t('login.title')}</h2>
            <p className="text-sm text-gray-500 mb-6">{t('login.subtitle')}</p>

            <div className="space-y-3 max-h-[420px] overflow-y-auto pr-2">
              {profiles.length === 0 && (
                <motion.div 
                  initial={{ opacity: 0 }} animate={{ opacity: 1 }}
                  className="text-center py-8 border border-dashed border-game-border/50 rounded-xl"
                >
                  <User size={32} className="mx-auto text-gray-600 mb-2" />
                  <p className="text-sm text-gray-500">{t('login.noProfiles')}</p>
                </motion.div>
              )}
              {profiles.map((profile, index) => (
                <motion.div 
                  key={profile.id} initial={{ opacity: 0, x: -20 }}
                  animate={{ opacity: 1, x: 0 }} transition={{ delay: index * 0.1 }}
                  className="flex items-center justify-between bg-game-bg/50 border border-game-border/50 rounded-xl px-3 py-3 hover:border-red-800/50 hover:bg-game-card/50 transition-all duration-200 cursor-pointer group"
                >
                  <button onClick={() => onLogin(profile.id)} className="text-left flex-1">
                    <div className="flex items-center gap-2">
                      <div className="w-8 h-8 bg-gradient-to-br from-red-800/30 to-red-900/30 rounded-lg flex items-center justify-center">
                        <User size={14} className="text-red-400" />
                      </div>
                      <span className="font-semibold text-gray-200">{profile.name}</span>
                    </div>
                    <p className="text-xs text-gray-500 mt-1 ml-10">{t('login.lastSaved')} {new Date(profile.updatedAt).toLocaleString()}</p>
                  </button>
                  <div className="flex items-center gap-2 ml-2">
                    <motion.button 
                      whileHover={{ scale: 1.1 }}
                      whileTap={{ scale: 0.95 }}
                      onClick={() => onLogin(profile.id)} 
                      className="px-2.5 py-1.5 rounded-lg bg-red-900/30 text-red-400 hover:bg-red-800 hover:text-white text-xs font-bold transition-all cursor-pointer"
                    >
                      <LogIn size={12} />
                    </motion.button>
                    <motion.button 
                      whileHover={{ scale: 1.1 }}
                      whileTap={{ scale: 0.95 }}
                      onClick={() => onDelete(profile.id)} 
                      className="px-2.5 py-1.5 rounded-lg bg-red-500/10 text-red-400 hover:bg-red-500 hover:text-white text-xs font-bold transition-all cursor-pointer"
                    >
                      <Trash2 size={12} />
                    </motion.button>
                  </div>
                </motion.div>
              ))}
            </div>
          </div>
        </section>

        <motion.section 
          initial={{ opacity: 0, x: 20 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ delay: 0.2 }}
          className="bg-gradient-to-br from-game-card/90 to-game-card/60 backdrop-blur-sm border border-game-border/50 rounded-2xl p-6 shadow-2xl shadow-red-900/10 relative overflow-hidden"
        >
          <div className="absolute inset-0 bg-gradient-to-br from-red-900/10 to-rose-500/5" />
          <div className="absolute -bottom-20 -left-20 w-40 h-40 bg-rose-600/10 rounded-full blur-3xl" />
          
          <div className="relative z-10">
            <h2 className="text-xl font-display mb-1 text-transparent bg-clip-text bg-gradient-to-r from-rose-400 to-red-500">{t('login.createTitle')}</h2>
            <p className="text-sm text-gray-500 mb-6">{t('login.createSubtitle')}</p>

            <div className="space-y-3">
              <input
                value={name}
                onChange={(e) => setName(e.target.value)}
                placeholder={t('login.placeholder')}
                className="w-full bg-game-bg/50 border border-game-border/50 rounded-xl px-4 py-3 outline-none focus:border-red-700 focus:ring-1 focus:ring-red-700/50 text-sm transition-all placeholder:text-gray-600"
              />
              <motion.button
                whileHover={{ scale: 1.02, boxShadow: '0_0_30px rgba(124, 58, 237, 0.4)' }}
                whileTap={{ scale: 0.98 }}
                onClick={() => {
                  const trimmed = name.trim();
                  if (!trimmed) return;
                  onCreate(trimmed);
                  setName('');
                }}
                className="w-full py-3 rounded-xl bg-gradient-to-r from-red-800 to-red-900 text-white font-bold hover:brightness-110 hover:shadow-lg hover:shadow-red-900/30 transition-all flex items-center justify-center gap-2 cursor-pointer relative overflow-hidden group"
              >
                <div className="absolute inset-0 bg-gradient-to-r from-white/0 via-white/20 to-white/0 translate-x-[-100%] group-hover:translate-x-[100%] transition-transform duration-700" />
                <Plus size={16} className="relative z-10" /> 
                <span className="relative z-10">{t('login.createEnter')}</span>
              </motion.button>
            </div>
          </div>
        </motion.section>
      </motion.div>
    </div>
  );
}


===================== [D:\download\LootingRPG\src\components\game\map\mapConfig.tsx] =====================
import nodeShapes from '@data/config/map/nodeShapes.json';
import type { ChapterTheme } from '../../../config/map/mapNode';
import { MAP_CHAPTERS } from '../../../config/map/ChapterData';

type ThemeKey = keyof typeof nodeShapes;

const orderedThemes = Array.from(new Set(MAP_CHAPTERS.map((chapter) => chapter.theme))) as ThemeKey[];
const [forestTheme, dungeonTheme, volcanoTheme, undeadTheme] =
  orderedThemes.length >= 4
    ? orderedThemes
    : (Object.keys(nodeShapes) as ThemeKey[]);


export interface ChapterThemeStyle {
  islandGradient: string;
  terrainTop: string;
  glowColor: string;
  shadowColor: string;
  accentColor: string;
  particles: { color: string; size: string; count: number };
  background: string;
  nodeShape: string;
  nodeEffects: {
    normal: string;
    elite: string;
    boss: string;
  };
  pathColor: string;
}
export const chapterThemeStyles = {
  [forestTheme]: {
    islandGradient: 'from-emerald-950 via-red-900 to-black',
    terrainTop: 'from-emerald-900 via-red-800 to-stone-900',
    glowColor: 'rgba(180, 40, 40, 0.4)',
    shadowColor: 'rgba(120, 30, 30, 0.3)',
    accentColor: 'emerald',
    particles: { color: 'bg-red-600', size: 'w-1 h-1', count: 4 },
    background: `
      radial-gradient(ellipse at 20% 30%, rgba(30, 80, 30, 0.2) 0%, transparent 40%),
      radial-gradient(ellipse at 80% 70%, rgba(60, 20, 20, 0.25) 0%, transparent 45%),
      radial-gradient(ellipse at 50% 50%, rgba(20, 10, 10, 0.4) 0%, transparent 60%),
      linear-gradient(180deg, #050805 0%, #0a0808 50%, #050505 100%)
    `,
    nodeShape: 'clip-path-forest',
    nodeEffects: nodeShapes[forestTheme],
    pathColor: 'rgb(100, 50, 30)',
  },
  [dungeonTheme]: {
    islandGradient: 'from-stone-950 via-red-950 to-black',
    terrainTop: 'from-stone-800 via-red-900 to-black',
    glowColor: 'rgba(150, 40, 40, 0.4)',
    shadowColor: 'rgba(100, 30, 30, 0.3)',
    accentColor: 'slate',
    particles: { color: 'bg-red-500', size: 'w-1 h-1', count: 3 },
    background: `
      radial-gradient(ellipse at 30% 20%, rgba(40, 40, 45, 0.3) 0%, transparent 35%),
      radial-gradient(ellipse at 70% 80%, rgba(30, 20, 20, 0.35) 0%, transparent 45%),
      radial-gradient(ellipse at 50% 50%, rgba(15, 15, 20, 0.5) 0%, transparent 55%),
      linear-gradient(180deg, #080808 0%, #0c0a0a 50%, #060606 100%)
    `,
    nodeShape: 'clip-path-dungeon',
    nodeEffects: nodeShapes[dungeonTheme],
    pathColor: 'rgb(80, 70, 60)',
  },
  [volcanoTheme]: {
    islandGradient: 'from-stone-950 via-red-950 to-black',
    terrainTop: 'from-orange-900 via-red-900 to-stone-950',
    glowColor: 'rgba(200, 60, 20, 0.5)',
    shadowColor: 'rgba(180, 40, 20, 0.35)',
    accentColor: 'orange',
    particles: { color: 'bg-red-600', size: 'w-1.5 h-1.5', count: 5 },
    background: `
      radial-gradient(ellipse at 30% 10%, rgba(200, 60, 10, 0.25) 0%, transparent 40%),
      radial-gradient(ellipse at 70% 85%, rgba(120, 30, 10, 0.3) 0%, transparent 45%),
      radial-gradient(ellipse at 50% 40%, rgba(80, 20, 10, 0.35) 0%, transparent 50%),
      linear-gradient(180deg, #0a0505 0%, #120808 50%, #080404 100%)
    `,
    nodeShape: 'clip-path-volcano',
    nodeEffects: nodeShapes[volcanoTheme],
    pathColor: 'rgb(180, 60, 20)',
  },
  [undeadTheme]: {
    islandGradient: 'from-slate-950 via-red-950 to-black',
    terrainTop: 'from-red-900 via-red-900 to-stone-950',
    glowColor: 'rgba(160, 50, 100, 0.4)',
    shadowColor: 'rgba(120, 30, 60, 0.3)',
    accentColor: 'purple',
    particles: { color: 'bg-rose-700', size: 'w-1 h-2', count: 4 },
    background: `
      radial-gradient(ellipse at 25% 15%, rgba(80, 20, 80, 0.2) 0%, transparent 40%),
      radial-gradient(ellipse at 75% 85%, rgba(40, 10, 50, 0.25) 0%, transparent 45%),
      radial-gradient(ellipse at 50% 50%, rgba(30, 5, 40, 0.4) 0%, transparent 55%),
      linear-gradient(180deg, #050308 0%, #08050a 50%, #040205 100%)
    `,
    nodeShape: 'clip-path-undead',
    nodeEffects: nodeShapes[undeadTheme],
    pathColor: 'rgb(120, 40, 80)',
  },
} as Record<ChapterTheme, ChapterThemeStyle>;

export const getNodeState = (
  unlocked: boolean, cleared: boolean, playerLevel: number, nodeLevel: number,
): 'locked' | 'warning' | 'ready' | 'cleared' => {
  if (!unlocked) return 'locked';
  if (cleared) return 'cleared';
  if (playerLevel < nodeLevel) return 'warning';
  return 'ready';
};

export const stateOverlayStyles = {
  locked: { overlay: 'opacity-35', glowFilter: 'none', },
  warning: { overlay: '', glowFilter: 'drop-shadow(0 0 8px rgba(200, 100, 30, 0.5))'},
  ready: { overlay: '', glowFilter: 'drop-shadow(0 0 12px rgba(180, 40, 40, 0.7))'},
  cleared: { overlay: 'opacity-70', glowFilter: 'drop-shadow(0 0 6px rgba(180, 50, 50, 0.5))'},
};
export const clamp = (value: number, min: number, max: number) => Math.max(min, Math.min(max, value));
const ZIGZAG_START_X = 14;
const ZIGZAG_STEP_X = 22;
const ZIGZAG_Y_POINTS = [46, 54] as const;

export const getZigzagNodePosition = (nodeIndex: number) => ({
  x: ZIGZAG_START_X + nodeIndex * ZIGZAG_STEP_X,
  y: ZIGZAG_Y_POINTS[nodeIndex % ZIGZAG_Y_POINTS.length],
});

const getPanLimits = (nodeCount: number, viewport: DOMRect) => {
  const firstX = getZigzagNodePosition(0).x;
  const lastX = getZigzagNodePosition(nodeCount - 1).x;
  const sidePadding = 12;

  const minX = ((50 - (lastX + sidePadding)) / 100) * viewport.width;
  const maxX = ((50 - (firstX - sidePadding)) / 100) * viewport.width;

  return { minX, maxX };
};

export const clampMapOffset = ( nextOffset: { x: number; y: number }, viewport: DOMRect | null, nodeCount: number) => {
  if (!viewport) return { x: 0, y: 0 };
  const { minX, maxX } = getPanLimits(nodeCount, viewport);
  return { x: clamp(nextOffset.x, minX, maxX), y: 0,};
};


===================== [D:\download\LootingRPG\src\components\game\map\MapNode.tsx] =====================
import {getNodeAttempts,isNodeCleared,isNodeUnlocked} from '../../../domains/map/services/progress';
import { Lock, Sparkles, Star, Zap, Skull, Crown, Trophy, Ghost } from 'lucide-react';
import { chapterThemeStyles, getNodeState, stateOverlayStyles, getZigzagNodePosition } from './mapConfig';
import type { MapNodeDef, MapChapterDef } from '../../../config/map/ChapterData';
import type { MapEncounterType } from '../../../config/map/mapNode';
import type { MapProgressState } from '../../../types/game';
import { UI_STYLES } from '../../../config/ui/tokens';
import { chapterNodeStyles, themeColors, defaultEncounterStyles } from '../../../config/map/mapNode';
import { useTranslation } from 'react-i18next';
import { motion } from 'motion/react';

interface MapNodeProps {
  node: MapNodeDef;
  nodeIndex: number;
  selectedChapter: MapChapterDef;
  normalizedProgress: MapProgressState;
  playerLevel: number;
  loading: boolean;
  onEnterNode: (node: MapNodeDef, chapter: MapChapterDef) => void;
  onHoverStart?: () => void;
  onHoverEnd?: () => void;
}

const EncounterIcon = ({ type, size = 22 }: { type: MapEncounterType; size?: number }) => {
  const style = defaultEncounterStyles[type];
  switch (type) {
    case 'boss':  return  <Crown size={size} className={style.iconColor} />;
    case 'elite': return  <Trophy size={size} className={style.iconColor} />;
    default:      return  <Ghost size={size} className={style.iconColor} />;
  }
};
export default function MapNode({
   node, nodeIndex, selectedChapter,
   normalizedProgress, playerLevel, loading,
   onEnterNode, onHoverStart, onHoverEnd,
}: MapNodeProps) {
  const { t } = useTranslation();
  const unlocked = isNodeUnlocked(normalizedProgress, node.id);
  const cleared = isNodeCleared(normalizedProgress, node.id);
  const attempts = getNodeAttempts(normalizedProgress, node.id);
  const waves = node.waves && node.waves.length > 0 ? node.waves : [];
  const waveCount = waves.length;
  const state = getNodeState(unlocked, cleared, playerLevel, node.recommendedLevel);
  const disabled     = loading || state === 'locked';
  const themeStyle   = chapterThemeStyles[selectedChapter.theme];
  const overlayStyle = stateOverlayStyles[state];
  const floatDelay   = nodeIndex * 0.3;
  const chapterEncounterStyles = chapterNodeStyles[selectedChapter.theme];
  const encounterStyle = chapterEncounterStyles[node.encounterType];
  const starCount = node.encounterType === 'boss' ? 3 : node.encounterType === 'elite' ? 2 : 1;
  const nodePosition = getZigzagNodePosition(nodeIndex);
  const isBoss = node.encounterType === 'boss';
  const themeColorConfig = themeColors[selectedChapter.theme];

  return (
    <div
      key={node.id} className="absolute"
      style={{ left: `${nodePosition.x}%`, top: `${nodePosition.y}%`, transform: 'translate(-50%, -50%)' }}
    >
      <motion.button
        data-map-node="1"
        initial={{ opacity: 0, y: 20, scale: 0.8 }}
        animate={{ opacity: 1, y: 0, scale: 1 }}
        transition={{ delay: nodeIndex * 0.08, duration: 0.35, type: 'spring', stiffness: 280 }}
        whileHover={disabled ? {} : { y: -8, scale: 1.1 }}
        whileTap={disabled ? {} : { scale: 0.95 }}
        onHoverStart={() => onHoverStart?.()}
        onHoverEnd={() => onHoverEnd?.()}
        onClick={() => !disabled && onEnterNode(node, selectedChapter)}
        className={`relative cursor-pointer ${overlayStyle.overlay}`}
        style={{ filter: overlayStyle.glowFilter }}
      >
        <motion.div
          className="relative"
          animate={disabled ? {} : { y: [0, -5, 0] }}
          transition={{ duration: 2.5 + floatDelay, repeat: Infinity, ease: 'easeInOut', delay: floatDelay}}
        >
          <div className="absolute -bottom-2 left-1/2 -translate-x-1/2 w-full h-4">
            <motion.div
              className="absolute inset-0 rounded-[50%] blur-lg"
              style={{ backgroundColor: themeStyle.shadowColor }}
              animate={{ scale: [1, 1.2, 1], opacity: [0.4, 0.7, 0.4] }}
              transition={{ duration: 2, repeat: Infinity, delay: floatDelay }}
            />
          </div>

          <div className="relative flex flex-col items-center">
            {waveCount > 1 && (
              <div className={UI_STYLES.nodeWaveLabel}>
                {waveCount} {t('map.encounter.wave')}
              </div>)}
            <div className="absolute -top-6 left-1/2 -translate-x-1/2 flex gap-1">
              {Array.from({ length: starCount }).map((_, i) => (
                <motion.div
                  key={i} animate={disabled ? {} : { scale: [1, 1.2, 1], opacity: [0.8, 1, 0.8] }}
                  transition={{ duration: 1.5, repeat: Infinity, delay: i * 0.2 }}
                >
                  <Star size={10} className="text-yellow-400" fill="currentColor" strokeWidth={1.5} />
                </motion.div>
              ))}
            </div>

            {isBoss && !disabled && !cleared && (
              <motion.div
                className="absolute -inset-4 rounded-full"
                style={{ background: `radial-gradient(circle, ${encounterStyle.glowColor} 0%, transparent 70%)` }}
                animate={{ scale: [1, 1.3, 1], opacity: [0.3, 0.6, 0.3] }}
                transition={{ duration: 2, repeat: Infinity }}
              />
            )}
            <motion.div
              className={`
                relative ${encounterStyle.size} ${encounterStyle.shape}
                bg-gradient-to-br ${encounterStyle.bgGradient}
                ring-2 ${encounterStyle.ringColor} shadow-lg flex items-center justify-center overflow-hidden
              `}
              animate={isBoss && !disabled ? { boxShadow: [`0 0 20px ${themeColorConfig.primary}80`, `0 0 40px ${themeColorConfig.primaryLight}aa`, `0 0 20px ${themeColorConfig.primary}80`] } : {}}
              transition={{ duration: 1.5, repeat: Infinity }}
            >
              <div
                className="absolute inset-0"
                style={{ background: `linear-gradient(135deg, ${themeColorConfig.primaryLight}26 0%, transparent 40%, rgba(0,0,0,0.5) 100%)` }}
              />
              <div className="absolute inset-0" style={{ background: `radial-gradient(circle at 30% 30%, ${themeColorConfig.primaryLight}1a, transparent 50%)` }} />

              {node.encounterType === 'elite' && (
                <div className="absolute inset-0 flex items-center justify-center">
                  <div className="w-full h-full bg-gradient-to-br from-amber-600/15 to-transparent" />
                </div>
              )}
              <div className={`relative z-10 ${node.encounterType === 'elite' ? '-rotate-45' : ''}`}>
                <EncounterIcon type={node.encounterType} size={isBoss ? 26 : 22} />
              </div>
              {Array.from({ length: 4 }).map((_, i) => (
                <motion.div
                  key={i}
                  className={`absolute ${encounterStyle.particleColor} w-1 h-1 rounded-full`}
                  style={{
                    left: `${15 + i * 22}%`,
                    top: `${15 + (i % 3) * 25}%`,
                  }}
                  animate={{ opacity: [0.3, 1, 0.3], scale: [0.5, 1.2, 0.5] }}
                  transition={{ duration: 1.2 + i * 0.2, repeat: Infinity, delay: i * 0.15 }}
                />
              ))}
            </motion.div>

            <motion.div
              className="mt-2"
              animate={disabled ? {} : { y: [0, -1, 0] }}
              transition={{ duration: 1.5, repeat: Infinity, delay: floatDelay }}
            >
              <span className="text-[10px] font-semibold whitespace-nowrap" style={{ color: isBoss ? themeColorConfig.primaryLight : themeColorConfig.primary }}>
                {node.name}
              </span>
            </motion.div>

            <div className="mt-1 flex items-center gap-2">
              <span className="text-[9px] font-medium opacity-70">{t(`map.encounter.${node.encounterType}`)}</span>
              <span className="text-[9px] font-mono" style={{ color: themeColorConfig.primaryLight }}>{t('map.level', { level: node.recommendedLevel })}</span>
            </div>

            <div className="mt-0.5 flex items-center gap-2">
              <span className="text-[7px] text-amber-400/80 flex items-center gap-0.5">
                <span className="text-amber-500">+</span>
                {node.firstClearRewardGold}G
              </span>
              {state === 'cleared' && (
                <span className="text-[7px] text-cyan-400 flex items-center gap-0.5">
                  <Star size={8} fill="currentColor" />
                  {t('map.state.cleared')}
                </span>
              )}
              {state === 'warning' && (
                <span className="text-[7px] text-amber-400 flex items-center gap-0.5">
                  <Zap size={8} />
                  {t('map.state.warning')}
                </span>
              )}
              {state === 'ready' && (
                <span className="text-[7px] text-emerald-400 flex items-center gap-0.5">
                  <Sparkles size={8} />
                  {t('map.state.ready')}
                </span>
              )}
              {state === 'locked' && (
                <span className="text-[7px] text-slate-500 flex items-center gap-0.5">
                  <Lock size={8} />
                  {t('map.state.locked')}
                </span>
              )}
            </div>

            {attempts > 0 && (
              <div className="text-[6px] text-rose-400/70 flex items-center gap-0.5 mt-0.5">
                <Skull size={7} />
                {t('map.failures', { count: attempts })}
              </div>
            )}
          </div>
        </motion.div>
      </motion.button>
    </div>
  );
}


===================== [D:\download\LootingRPG\src\components\game\map\MapViewport.tsx] =====================
import MapNode from './MapNode';
import { motion } from 'motion/react';
import { useRef, useState, useEffect } from 'react';
import { useTranslation } from 'react-i18next';
import { Mountain} from 'lucide-react';
import type { MapChapterDef, MapNodeDef } from '../../../config/map/ChapterData';
import type { MapProgressState } from '../../../shared/types/game';
import { isNodeCleared, isNodeUnlocked,} from '../../../domains/map/services/progress';
import { clampMapOffset, getZigzagNodePosition, chapterThemeStyles,} from './mapConfig';
import { themeHeaderColors} from '../../../config/map/mapNode';

interface MapViewportProps {
  playerLevel: number;
  loading: boolean;
  normalizedProgress: MapProgressState;
  selectedChapter: MapChapterDef;
  selectedChapterProgress: { cleared: number; total: number; completed: boolean };
  onEnterNode: (node: MapNodeDef, chapter: MapChapterDef) => void;
  focusNodeId?: string | null;
  onClearFocus?: () => void;
}

export default function MapViewport({
  playerLevel,
  loading,
  normalizedProgress,
  selectedChapter,
  selectedChapterProgress,
  onEnterNode,
  focusNodeId,
  onClearFocus,
}: MapViewportProps) {
  const { t } = useTranslation();
  const [offset, setOffset] = useState({ x: 0, y: 0 });
  const [, setHoveredNode] = useState<string | null>(null);
  const mapViewportRef = useRef<HTMLDivElement | null>(null);
  const dragRef = useRef<{ dragging: boolean; x: number; y: number }>({ dragging: false, x: 0, y: 0 });
  const themeColors = themeHeaderColors[selectedChapter.theme];

  const onWheel = (event: React.WheelEvent) => {
    // logic lives in the effect listener; kept here for typing but not attached directly
    const deltaX = event.deltaY || event.deltaX;
    setOffset((prev) => {
      const viewport = mapViewportRef.current?.getBoundingClientRect() ?? null;
      const next = { x: prev.x - deltaX, y: 0 };
      return clampMapOffset(next, viewport, selectedChapter.nodes.length);
    });
  };

  // React attaches wheel as a passive listener by default which prevents us from
  // calling preventDefault.  Patch the element directly with a non-passive
  // handler so we can cancel scrolling when over the map.
  useEffect(() => {
    const el = mapViewportRef.current;
    if (!el) return;
    const handler = (e: WheelEvent) => {
      e.preventDefault();
      onWheel(e as unknown as React.WheelEvent);
    };
    el.addEventListener('wheel', handler, { passive: false });
    return () => {
      el.removeEventListener('wheel', handler);
    };
  }, [onWheel]);

  const onPointerDown = (event: React.PointerEvent<HTMLDivElement>) => {
    const target = event.target as HTMLElement;
    if (target.closest('[data-map-node="1"]')) return;
    event.currentTarget.setPointerCapture(event.pointerId);
    dragRef.current = { dragging: true, x: event.clientX, y: event.clientY };
  };

  const onPointerMove = (event: React.PointerEvent<HTMLDivElement>) => {
    if (!dragRef.current.dragging) return;
    const dx = event.clientX - dragRef.current.x;
    dragRef.current.x = event.clientX;
    dragRef.current.y = event.clientY;
    const viewport = mapViewportRef.current?.getBoundingClientRect() ?? null;
    setOffset((prev) => clampMapOffset({ x: prev.x + dx, y: 0 }, viewport, selectedChapter.nodes.length));
  };

  const onPointerUp = (event: React.PointerEvent<HTMLDivElement>) => {
    if (event.currentTarget.hasPointerCapture(event.pointerId)) {
      event.currentTarget.releasePointerCapture(event.pointerId);
    }
    dragRef.current.dragging = false;
  };

  const onPointerLeave = () => {
    dragRef.current.dragging = false;
  };

  // center viewport when requested
  useEffect(() => {
    if (!focusNodeId) return;
    const idx = selectedChapter.nodes.findIndex((n) => n.id === focusNodeId);
    if (idx >= 0 && mapViewportRef.current) {
      const viewport = mapViewportRef.current.getBoundingClientRect();
      const pos = getZigzagNodePosition(idx);
      // target coordinates in px
      const targetX = (pos.x / 100) * viewport.width;
      const centerX = viewport.width / 2;
      const desired = { x: centerX - targetX, y: 0 };
      setOffset(() => clampMapOffset(desired, viewport, selectedChapter.nodes.length));
    }
    onClearFocus?.();
  }, [focusNodeId, selectedChapter, onClearFocus]);

  return (
    <section 
      className="flex-1 border rounded-xl bg-gradient-to-br from-stone-950/60 to-stone-950/50 p-3 flex flex-col overflow-hidden relative"
      style={{ borderColor: themeColors.border.replace('/30', ''), background: `linear-gradient(180deg, rgba(30,30,30,0.3) 0%, rgba(50,20,20,0.1) 50%, rgba(20,20,20,0.3) 100%)` }}
    >
      <div 
        className="absolute inset-0 pointer-events-none"
        style={{ background: `radial-gradient(ellipse at top left, ${themeColors.glow}, transparent 50%), radial-gradient(ellipse at bottom right, rgba(100,20,20,0.08), transparent 50%)` }}
      />

      <header className="mb-3 pb-3 relative z-10 flex items-center justify-between" style={{ borderBottom: `1px solid ${themeColors.border.replace('/30', '')}` }}>
        <div className="flex items-center gap-3">
          <div 
            className="w-9 h-9 rounded-lg flex items-center justify-center border"
            style={{ 
              background: `linear-gradient(135deg, ${themeColors.primary}-900/40 0%, ${themeColors.primary}-950/60 100%)`,
              borderColor: `${themeColors.primary}-700/50`,
              boxShadow: `0 0 12px ${themeColors.primary}-900/30`
            }}
          >
            <Mountain size={18} className={`text-${themeColors.primary}-300`} />
          </div>
          <div>
            <h3 className="text-base font-display font-bold" style={{ color: themeColors.text === 'stone' ? '#e7e5e4' : `var(--color-${themeColors.primary}-200)` }}>
              {t(`map.${selectedChapter.id}`)}
            </h3>
          </div>
        </div>

        <div className="flex items-center gap-1.5 px-3 py-1.5 rounded-lg border" style={{ backgroundColor: `${themeColors.primary}-950/30`, borderColor: `${themeColors.primary}-800/30` }}>
          <span className="text-[11px]" style={{ color: themeColors.text === 'stone' ? '#a8a29e' : `var(--color-${themeColors.primary}-300)` }}>
            {selectedChapter.levelRange}
          </span>
          <span style={{ color: themeColors.text === 'stone' ? '#57534e' : `var(--color-${themeColors.primary}-700)` }}>路</span>
          <span className="text-[11px] font-medium" style={{ color: themeColors.text === 'stone' ? '#d6d3d1' : `var(--color-${themeColors.primary}-200)` }}>
            {t('map.level', { level: playerLevel })}
          </span>
        </div>

        <div className="flex items-center gap-3">
          <div className="flex flex-col items-end gap-1">
            <span className="text-[10px] font-medium" style={{ color: themeColors.text === 'stone' ? '#a8a29e' : `var(--color-${themeColors.primary}-300)` }}>
              {t('map.progress')} {selectedChapterProgress.cleared}/{selectedChapterProgress.total}
            </span>
            <div className="w-24 h-1.5 rounded-full overflow-hidden" style={{ backgroundColor: `${themeColors.primary}-950/50` }}>
              <motion.div 
                className="h-full rounded-full"
                style={{ backgroundColor: themeColors.primary === 'stone' ? '#a8a29e' : `var(--color-${themeColors.primary}-500)` }}
                initial={{ width: 0 }}
                animate={{ width: `${(selectedChapterProgress.cleared / selectedChapterProgress.total) * 100}%` }}
                transition={{ duration: 0.8, ease: 'easeOut' }}
              />
            </div>
          </div>
          <div 
            className="w-10 h-10 rounded-lg flex items-center justify-center border"
            style={{ 
              background: `linear-gradient(135deg, ${themeColors.primary}-900/30 0%, ${themeColors.primary}-950/50 100%)`,
              borderColor: `${themeColors.primary}-700/40`,
            }}
          >
            <span className="text-sm font-bold" style={{ color: themeColors.text === 'stone' ? '#d6d3d1' : `var(--color-${themeColors.primary}-200)` }}>
              {Math.round((selectedChapterProgress.cleared / selectedChapterProgress.total) * 100)}%
            </span>
          </div>
        </div>
      </header>

      <div
        ref={mapViewportRef}
        className="flex-1 min-h-0 rounded-xl border relative overflow-hidden cursor-grab active:cursor-grabbing"
        style={{
          background: chapterThemeStyles[selectedChapter.theme]?.background,
          borderColor: themeColors.border.replace('/30', ''),
        }}
        onPointerDown={onPointerDown}
        onPointerMove={onPointerMove}
        onPointerUp={onPointerUp}
        onPointerLeave={onPointerLeave}
      >
        <div
          className="absolute inset-0"
          style={{
            transform: `translate(${offset.x}px, ${offset.y}px)`,
            transformOrigin: '50% 50%',
          }}
        >
          <svg className="absolute inset-0 w-full h-full pointer-events-none overflow-visible">
            <defs>
              <linearGradient id="pathGradientCleared" x1="0%" y1="0%" x2="100%" y2="0%">
                <stop offset="0%" stopColor={chapterThemeStyles[selectedChapter.theme]?.pathColor} stopOpacity="0.9" />
                <stop offset="50%" stopColor="rgba(255, 80, 80, 0.85)" />
                <stop offset="100%" stopColor={chapterThemeStyles[selectedChapter.theme]?.pathColor} stopOpacity="0.9" />
              </linearGradient>
              <linearGradient id="pathGradientReady" x1="0%" y1="0%" x2="100%" y2="0%">
                <stop offset="0%" stopColor={chapterThemeStyles[selectedChapter.theme]?.pathColor} stopOpacity="0.7" />
                <stop offset="50%" stopColor="rgba(200, 60, 60, 0.6)" />
                <stop offset="100%" stopColor={chapterThemeStyles[selectedChapter.theme]?.pathColor} stopOpacity="0.7" />
              </linearGradient>
              <filter id="pathGlow">
                <feGaussianBlur stdDeviation="4" result="coloredBlur"/>
                <feMerge>
                  <feMergeNode in="coloredBlur"/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>
              <filter id="bloodGlow">
                <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
                <feFlood floodColor="#8b0000" floodOpacity="0.8"/>
                <feComposite in2="coloredBlur" operator="in"/>
                <feMerge>
                  <feMergeNode/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>
            </defs>
            {selectedChapter.nodes.slice(0, -1).map((node, index) => {
              const nextNode = selectedChapter.nodes[index + 1];
              const currentPos = getZigzagNodePosition(index);
              const nextPos = getZigzagNodePosition(index + 1);
              const currentCleared = isNodeCleared(normalizedProgress, node.id);
              const nextUnlocked = isNodeUnlocked(normalizedProgress, nextNode.id);
              const themePathColor = chapterThemeStyles[selectedChapter.theme]?.pathColor || 'rgb(100, 50, 50)';
              const pathColor = currentCleared ? 'url(#pathGradientCleared)' : nextUnlocked ? 'url(#pathGradientReady)' : themePathColor + '40';
              return (
                  <g key={`${node.id}-${nextNode.id}`}>
                    <motion.line
                      x1={`${currentPos.x}%`}
                      y1={`${currentPos.y}%`}
                      x2={`${nextPos.x}%`}
                      y2={`${nextPos.y}%`}
                      stroke={pathColor}
                      strokeWidth="3"
                      strokeDasharray={currentCleared ? "none" : "8 6"}
                      strokeLinecap="round"
                      filter={currentCleared || nextUnlocked ? "url(#pathGlow)" : undefined}
                      initial={{ pathLength: 0 }}
                      animate={{ pathLength: 1 }}
                      transition={{ duration: 0.8, delay: index * 0.15 }}
                    />
                    <motion.line
                      x1={`${currentPos.x}%`}
                      y1={`${currentPos.y}%`}
                      x2={`${nextPos.x}%`}
                      y2={`${nextPos.y}%`}
                      stroke={currentCleared ? "rgba(255,255,255,0.4)" : nextUnlocked ? "rgba(255,255,255,0.2)" : "rgba(255,255,255,0.05)"}
                      strokeWidth="1"
                      strokeDasharray={currentCleared ? "none" : "8 6"}
                      strokeLinecap="round"
                      initial={{ pathLength: 0 }}
                      animate={{ pathLength: 1 }}
                      transition={{ duration: 0.8, delay: index * 0.15 + 0.1 }}
                    />
                  </g>
              );
            })}
          </svg>

          {selectedChapter.nodes.map((node, nodeIndex) => (
            <MapNode
              key={node.id}
              node={node}
              nodeIndex={nodeIndex}
              selectedChapter={selectedChapter}
              normalizedProgress={normalizedProgress}
              playerLevel={playerLevel}
              loading={loading}
              onEnterNode={onEnterNode}
              onHoverStart={() => setHoveredNode(node.id)}
              onHoverEnd={() => setHoveredNode(null)}
            />
          ))}
        </div>
      </div>
    </section>
  );
}


===================== [D:\download\LootingRPG\src\components\game\tabs\ForgeTab.tsx] =====================
import { Sparkles } from 'lucide-react';
import { motion } from 'motion/react';
import { LOCK_COST, QUALITY_CONFIG, REROLL_BASE_COST } from '../../../config/game/equipment';
import { getSlotLabel, getStatLabel } from '../../../infra/i18n/labels';
import type { Equipment, GameState } from '../../../types/game';
import { useTranslation } from 'react-i18next';
import { useMemo, useState } from 'react';
import { calculateEnchantCost, previewEnchant } from '../../../domains/inventory/services/equipment';


interface ForgeTabProps {
  gameState: GameState;
  selectedId: string | null;
  loading: boolean;
  onSelect: (id: string) => void;
  onForge: (id: string) => void;
  onReroll: (id: string, lockTypes?: string[]) => void;
}

type ForgeCandidate = {
  item: Equipment;
  source: string;
};

export function ForgeTab({ gameState, selectedId, loading, onSelect, onForge, onReroll }: ForgeTabProps) {
  const { t } = useTranslation();

  const equipped = (Object.entries(gameState.currentEquipment) as [string, Equipment | null][])
    .filter(([, item]) => Boolean(item))
    .map(([slot, item]) => ({ item: { ...(item as Equipment), equipped: true }, source: t('label.equipped') + '/' + getSlotLabel(slot) }));

  const backpack = gameState.backpack.map((item) => ({ item: { ...item, equipped: false }, source: t('label.backpack') }));
  const deduped = new Map<string, ForgeCandidate>();
  [...equipped, ...backpack].forEach((entry) => {
    deduped.set(entry.item.id, entry);
  });
  const candidates: ForgeCandidate[] = [...deduped.values()];

  const selected = candidates.find((entry) => entry.item.id === selectedId)?.item ?? candidates[0]?.item;

  // UI state for Forge interactions
  const [lockedTypes, setLockedTypes] = useState<string[]>([]);
  const [previewTimes, setPreviewTimes] = useState<number>(1);
  const [previewResult, setPreviewResult] = useState<Equipment | null>(null);
  const [confirmOpen, setConfirmOpen] = useState(false);

  const toggleLock = (type: string) => {
    setLockedTypes((prev) => (prev.includes(type) ? prev.filter((p) => p !== type) : [...prev, type]));
  };

  const enchantCost = useMemo(() => (selected ? calculateEnchantCost(selected) * previewTimes : 0), [selected, previewTimes]);
  const rerollCost = useMemo(() => {
    if (!selected) return 0;
    return REROLL_BASE_COST * ((selected.enhancementLevel || 0) + 1) + lockedTypes.length * LOCK_COST;
  }, [selected, lockedTypes]);

  if (!selected) {
    return (
      <motion.div key="forge" initial={{ opacity: 0, x: 20 }} animate={{ opacity: 1, x: 0 }} exit={{ opacity: 0, x: -20 }} className="h-full flex flex-col items-center justify-center space-y-6">
        <div className="text-center space-y-2">
          <Sparkles className="mx-auto text-red-400" size={48} />
          <h2 className="text-xl font-display">{t('ui.forgeCenter')}</h2>
          <p className="text-sm text-gray-500">{t('ui.no_forge_items')}</p>
        </div>
      </motion.div>
    );
  }

  const qualityColor = QUALITY_CONFIG[selected.quality]?.color || 'text-gray-400';

  return (
    <motion.div
      key="forge"
      initial={{ opacity: 0, x: 20 }}
      animate={{ opacity: 1, x: 0 }}
      exit={{ opacity: 0, x: -20 }}
      className="h-full grid grid-cols-1 gap-4 overflow-hidden"
      style={{ gridTemplateColumns: selected ? '35% 65%' : undefined }}
    >
      <div className="h-full overflow-y-auto pr-2 space-y-2">
        {candidates.map(({ item, source }) => (
          <button
            key={item.id}
            onClick={() => onSelect(item.id)}
            className={`w-full p-3 rounded-lg border text-left transition-all duration-200 cursor-pointer ${selected.id === item.id ? 'border-red-700 bg-red-900/10 hover:border-red-600' : 'border-game-border/50 bg-game-bg/50 hover:border-red-800/50 hover:bg-game-card/50'}`}
          >
            <div className="flex items-center justify-between gap-2">
              <div className="min-w-0">
                <p className={`text-sm font-bold truncate flex items-center gap-1 ${QUALITY_CONFIG[item.quality]?.color || 'text-gray-200'}`}>
                  <span className="text-base leading-none">{item.icon || '馃О'}</span>
                  {item.name} {item.enhancementLevel > 0 ? `+${item.enhancementLevel}` : ''}
                </p>
                <p className="text-[10px] text-gray-500 mt-1">{getSlotLabel(item.slot)} 路 {source}</p>
              </div>
              {item.equipped && (
                <span className="text-[10px] px-2 py-0.5 rounded-full bg-red-900/20 text-red-400 border border-red-700/30 font-bold">
                  宸茶澶?                </span>
              )}
            </div>
          </button>
        ))}
      </div>

      <div className="bg-game-bg/80 border border-game-border/50 rounded-xl p-4 space-y-4 overflow-y-auto">
        <div>
          <h3 className={`text-base font-bold ${qualityColor} flex items-center gap-1`}>
            <span className="text-lg leading-none">{selected.icon || '馃О'}</span>
            {selected.name} {selected.enhancementLevel > 0 ? `+${selected.enhancementLevel}` : ''}
          </h3>
          <p className="text-xs text-gray-500">{selected.slot} 鈥?{selected.quality}</p>
        </div>

        <div className="space-y-1">
          {Object.entries(selected.attributes).map(([key, value]) => (
            <div key={key} className="flex justify-between text-sm">
              <span className="text-gray-400">{getStatLabel(key)}</span>
              <span className="font-mono text-gray-200">+{value}</span>
            </div>
          ))}
        </div>

        {selected.affixes && selected.affixes.length > 0 && (
          <div className="mt-2">
            <h4 className="text-xs text-gray-400 mb-1">{t('label.affixes') || 'Affixes'}</h4>
            <div className="flex flex-col gap-2">
              {selected.affixes.map((affix, idx) => {
                const labelMap: Record<string, string> = {
                  crit_chance: t('stat.crit'),
                  lifesteal: t('stat.lifesteal'),
                  damage_bonus: t('stat.damage'),
                  thorns: t('trait.thorns'),
                  hp_bonus: t('stat.hp'),
                };
                const isLocked = lockedTypes.includes(affix.type);
                return (
                  <div key={`${affix.type}-${idx}`} className="flex items-center justify-between gap-2">
                    <div className="flex items-center gap-3">
                      <span className="text-[12px] px-2 py-1 rounded border border-white/10 bg-game-card/20 text-gray-200">{labelMap[affix.type] || affix.type}</span>
                      <span className="font-mono text-gray-200">+{affix.value}</span>
                    </div>
                    <div className="flex items-center gap-2">
                      <button
                        aria-pressed={isLocked}
                        onClick={() => toggleLock(affix.type)}
                        className={`px-2 py-1 rounded ${isLocked ? 'bg-red-800 text-white' : 'bg-game-card/10 text-gray-200'} text-xs`}
                      >
                        {isLocked ? t('ui.forge.lock') || 'Lock' : t('ui.forge.unlock') || 'Lock'}
                      </button>
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        )}

        {selected.special && <p className="text-xs text-red-400 italic">鈽?{selected.special}</p>}

        <div className="grid grid-cols-1 gap-3 pt-2">
          <div className="flex items-center gap-2">
            <label className="text-sm text-gray-400">{t('ui.forge.preview_times') || 'Preview'}</label>
            <div className="flex gap-2 ml-2">
              {[1, 5, 10].map((n) => (
                <button key={n} onClick={() => setPreviewTimes(n)} className={`px-3 py-1 rounded text-sm ${previewTimes === n ? 'bg-red-700 text-white' : 'bg-game-card/10 text-gray-200'}`}>{n}</button>
              ))}
            </div>
            <div className="ml-auto text-sm text-gray-400">{t('ui.forge.cost') || 'Cost'}: <span className="font-mono">{enchantCost}</span></div>
          </div>

          <div className="flex gap-3 w-full">
            <button
              onClick={() => {
                if (!selected) return;
                const preview = previewEnchant(JSON.parse(JSON.stringify(selected)), previewTimes);
                setPreviewResult(preview);
              }}
              disabled={loading}
              className="w-1/3 min-w-0 py-2 rounded-lg border border-red-700/30 bg-red-900/10 text-red-400 hover:bg-red-700 hover:text-white text-sm font-bold text-center whitespace-nowrap"
            >
              {t('ui.forge.preview') || 'Preview'}
            </button>
            <button
              onClick={() => setConfirmOpen(true)}
              disabled={loading || gameState.playerStats.gold < enchantCost}
              className="w-1/3 min-w-0 py-2 rounded-lg border border-yellow-500/30 bg-yellow-500/10 text-yellow-400 hover:bg-yellow-500 hover:text-white text-sm font-bold text-center whitespace-nowrap"
            >
              {t('ui.forge.apply') || 'Apply'} ({enchantCost})
            </button>
            <button
              onClick={() => {
                if (!selected) return;
                onReroll(selected.id, lockedTypes);
              }}
              disabled={loading || gameState.playerStats.gold < rerollCost}
              className="w-1/3 min-w-0 py-2 rounded-lg border border-blue-500/30 bg-blue-500/10 text-blue-400 hover:bg-blue-500 hover:text-white text-sm font-bold text-center whitespace-nowrap"
            >
              {t('ui.forge.reroll') || 'Reroll'} ({rerollCost})
            </button>
          </div>
        </div>
      </div>
      
      {/* Confirm Modal */}
      {confirmOpen && selected && (
        <div className="fixed inset-0 z-[9999] flex items-center justify-center">
          <div className="absolute inset-0 bg-black/50" onClick={() => setConfirmOpen(false)} />
          <div className="relative bg-game-bg border border-game-border rounded-lg p-6" style={{ width: 'min(92%,560px)' }}>
            <h3 className="text-lg font-bold mb-2">{t('ui.forge.confirm_title') || 'Confirm Enchant'}</h3>
            <p className="text-sm text-gray-300 mb-4">{t('ui.forge.confirm_body') || 'This will consume resources and apply the enchant.'}</p>
            {previewResult && (
              <div className="mb-4">
                <h4 className="text-sm text-gray-400 mb-2">{t('ui.forge.preview') || 'Preview'}</h4>
                <div className="space-y-2">
                  {Object.entries(previewResult.attributes).map(([k, v]) => (
                    <div key={k} className="flex justify-between text-sm">
                      <span className="text-gray-400">{getStatLabel(k)}</span>
                      <span className="font-mono text-gray-200">+{v}</span>
                    </div>
                  ))}
                </div>
              </div>
            )}
            <div className="flex justify-end gap-2">
              <button onClick={() => setConfirmOpen(false)} className="px-4 py-2 rounded bg-game-card/10">{t('button.cancel') || 'Cancel'}</button>
              <button
                onClick={() => {
                  setConfirmOpen(false);
                  for (let i = 0; i < previewTimes; i++) {
                    onForge(selected.id);
                  }
                }}
                className="px-4 py-2 rounded bg-yellow-500 text-white"
              >
                {t('button.confirm') || 'Confirm'}
              </button>
            </div>
          </div>
        </div>
      )}
    </motion.div>
  );
}


===================== [D:\download\LootingRPG\src\components\game\tabs\InventoryTab.tsx] =====================
import { Package, Shield, Zap, Gem, Crown, Star, Hexagon } from 'lucide-react';
import { QUALITIES, QUALITY_CONFIG } from '../../../config/game/equipment';
import { getQualityLabel } from '../../../infra/i18n/labels';
import { useMemo, useState, useCallback } from 'react';
import type { Equipment } from '../../../types/game';
import { useTranslation } from 'react-i18next';
import { motion } from 'motion/react';
import type { ReactNode } from 'react';
import { ItemCard } from '../ItemCard';

const iconMap: Record<string, ReactNode> = {
  shield: <Shield size={14} className="text-gray-400" />,
  zap: <Zap size={14} className="text-emerald-400" />,
  gem: <Gem size={14} className="text-blue-400" />,
  hexagon: <Hexagon size={14} className="text-red-400" />,
  crown: <Crown size={14} className="text-yellow-400" />,
  star: <Star size={14} className="text-red-400" />,
};

interface InventoryTabProps {
  items: Equipment[];
  loading: boolean;
  onEquip: (id: string) => void;
  onSell: (id: string) => void;
  onForge: (id: string) => void;
  onQuickSellByQualityRange: (minQuality: string, maxQuality: string) => void;
  autoSellQualities: Record<string, boolean>;
  onToggleAutoSellQuality: (quality: string) => void;
}

type SortField = 'quality' | 'price' | 'name' | 'enchantment';
type SortOrder = 'asc' | 'desc';

export function InventoryTab({
  items,
  loading,
  onEquip,
  onSell,
  onForge,
  onQuickSellByQualityRange,
  autoSellQualities,
  onToggleAutoSellQuality,
}: InventoryTabProps) {
  const [sortField, setSortField] = useState<SortField>('quality');
  const [sortOrder, setSortOrder] = useState<SortOrder>('desc');
  const { t } = useTranslation();
  const [sellMinQuality, setSellMinQuality] = useState(QUALITIES[0]);
  const [sellMaxQuality, setSellMaxQuality] = useState(QUALITIES[2]);

  const qualityIndexMap = useMemo((): Record<string, number> => {
    const map: Record<string, number> = {};
    QUALITIES.forEach((quality, index) => {
      map[quality] = index;
    });
    return map;
  }, []);

  const sortedItems = useMemo(() => {
    const direction = sortOrder === 'asc' ? 1 : -1;
    return [...items].sort((a, b) => {
      if (sortField === 'quality') {
        return ((qualityIndexMap[a.quality] ?? 0) - (qualityIndexMap[b.quality] ?? 0)) * direction;
      }
      if (sortField === 'price') {
        const pa = QUALITY_CONFIG[a.quality]?.price || 0;
        const pb = QUALITY_CONFIG[b.quality]?.price || 0;
        return (pa - pb) * direction;
      }
      if (sortField === 'enchantment') {
        return (a.enhancementLevel - b.enhancementLevel) * direction;
      }
      return a.name.localeCompare(b.name, 'zh-Hans-CN') * direction;
    });
  }, [items, qualityIndexMap, sortField, sortOrder]);

  const handleEquip = useCallback((id: string) => onEquip(id), [onEquip]);
  const handleSell = useCallback((id: string) => onSell(id), [onSell]);
  const handleForge = useCallback((id: string) => onForge(id), [onForge]);

  return (
    <motion.div key="inventory" initial={{ opacity: 0, scale: 0.95 }} animate={{ opacity: 1, scale: 1 }} exit={{ opacity: 0, scale: 0.95 }} className="h-full flex flex-col gap-3">
      <section className="border border-game-border rounded-xl bg-game-bg/60 p-3">
        <p className="text-xs text-gray-400 mb-2">{t('ui.autoSellHint')}</p>
        <div className="grid grid-cols-3 md:grid-cols-6 gap-2">
          {QUALITIES.map((quality) => (
            <label key={quality} className="flex items-center gap-1.5 text-xs text-gray-300 cursor-pointer hover:bg-game-card/30 p-1.5 rounded-lg transition-colors">
              <input
                type="checkbox"
                checked={Boolean(autoSellQualities[quality])}
                onChange={() => onToggleAutoSellQuality(quality)}
                className="accent-red-700"
              />
              <span className="flex items-center gap-1">
                {iconMap[QUALITY_CONFIG[quality]?.iconName || 'shield']}
                {getQualityLabel(quality)}
              </span>
            </label>
          ))}
        </div>
      </section>

      <section className="border border-game-border rounded-xl bg-game-bg/60 p-3 space-y-3">
        <p className="text-xs text-gray-400">{t('ui.quickSellAndSort')}</p>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
          <div className="flex flex-wrap items-center gap-2">
            <span className="text-xs text-gray-400">{t('label.sellRange')}</span>
            <select
              value={sellMinQuality}
              onChange={(event) => setSellMinQuality(event.target.value)}
              className="text-xs bg-game-bg border border-game-border rounded px-2 py-1 text-gray-200"
            >
              {QUALITIES.map((quality) => (
                <option key={`min-${quality}`} value={quality}>{getQualityLabel(quality)}</option>
              ))}
            </select>
            <span className="text-xs text-gray-500">{t('label.to')}</span>
              <select
              value={sellMaxQuality}
              onChange={(event) => setSellMaxQuality(event.target.value)}
              className="text-xs bg-game-bg border border-game-border rounded px-2 py-1 text-gray-200"
            >
              {QUALITIES.map((quality) => (
                  <option key={`max-${quality}`} value={quality}>{getQualityLabel(quality)}</option>
              ))}
            </select>
            <button
              onClick={() => onQuickSellByQualityRange(sellMinQuality, sellMaxQuality)}
              disabled={loading || sortedItems.length === 0}
              className="text-xs px-3 py-1 rounded-lg border border-red-500/30 bg-red-500/10 hover:bg-red-500 text-red-300 hover:text-white disabled:opacity-40 disabled:cursor-not-allowed transition-colors"
            >
              {t('button.quickSell')}
            </button>
          </div>

          <div className="flex flex-wrap items-center gap-2">
            <span className="text-xs text-gray-400">{t('label.sort')}</span>
              <select
              value={sortField}
              onChange={(event) => setSortField(event.target.value as SortField)}
              className="text-xs bg-game-bg border border-game-border rounded px-2 py-1 text-gray-200"
            >
              <option value="quality">{t('label.quality')}</option>
              <option value="price">{t('label.price')}</option>
              <option value="enchantment">{t('label.enchantLevel')}</option>
              <option value="name">{t('label.name')}</option>
            </select>
            <select
              value={sortOrder}
              onChange={(event) => setSortOrder(event.target.value as SortOrder)}
              className="text-xs bg-game-bg border border-game-border rounded px-2 py-1 text-gray-200"
            >
              <option value="desc">{t('label.desc')}</option>
              <option value="asc">{t('label.asc')}</option>
            </select>
          </div>
        </div>
      </section>

      <div className="h-[420px] overflow-y-auto grid grid-cols-1 sm:grid-cols-2 gap-3 pr-2">
        {sortedItems.length === 0 ? (
          <div className="col-span-full flex flex-col items-center justify-center h-64 text-gray-600">
            <Package size={48} className="mb-2 opacity-20" />
            <p>{t('message.empty_inventory')}</p>
          </div>
        ) : (
          sortedItems.map((item) => (
            <div key={item.id}>
              <ItemCard
                item={item}
                readonly={item.equipped}
                onEquip={() => handleEquip(item.id)}
                onSell={() => handleSell(item.id)}
                onForge={() => handleForge(item.id)}
                loading={loading}
              />
            </div>
          ))
        )}
      </div>
    </motion.div>
  );
}


===================== [D:\download\LootingRPG\src\components\game\tabs\MapTab.tsx] =====================
import { normalizeMapProgress, getChapterProgress} from '../../../domains/map/services/progress';
import type { MapChapterDef, MapNodeDef } from '../../../config/map/ChapterData';
import { Star, ChevronDown, Mountain, Lock } from 'lucide-react';
import { MAP_CHAPTERS } from '../../../config/map/ChapterData';
import type { MapProgressState } from '../../../shared/types/game';
import { themeColors } from '../../../config/map/mapNode';
import { motion, AnimatePresence } from 'motion/react';
import { useTranslation } from 'react-i18next';
import MapViewport from '../map/MapViewport';
import { useMemo, useState } from 'react';
interface MapTabProps {
  playerLevel: number;
  loading: boolean;
  progress: MapProgressState;
  onSelectChapter: (chapterId: string) => void;
  onEnterNode: (node: MapNodeDef, chapter: MapChapterDef) => void;
  focusNodeId?: string | null;
  onClearFocus?: () => void;
}

export function MapTab({ playerLevel, loading, progress, onSelectChapter, onEnterNode, focusNodeId, onClearFocus }: MapTabProps) {
  const { t } = useTranslation();
  const [dropdownOpen, setDropdownOpen] = useState(false);
  const normalizedProgress = useMemo(() => normalizeMapProgress(progress, MAP_CHAPTERS), [progress]);

  const selectedChapter = useMemo(
    () =>
      MAP_CHAPTERS.find((c) => c.id === normalizedProgress.selectedChapterId) ?? MAP_CHAPTERS[0],
    [normalizedProgress.selectedChapterId]
  );

  const selectedChapterProgress = useMemo(
    () =>
      selectedChapter ? getChapterProgress(normalizedProgress, selectedChapter) : { cleared: 0, total: 0, completed: false },
    [normalizedProgress, selectedChapter]
  );

  const totalStars = useMemo(() => {
    let stars = 0;
    MAP_CHAPTERS.forEach(chapter => {
      const chapterProgress = getChapterProgress(normalizedProgress, chapter);
      if (chapterProgress.completed) stars += chapter.nodes.length;
    });
    return stars;
  }, [normalizedProgress]);

  const chapterThemeColors = themeColors[selectedChapter.theme];

  return (
    <motion.div
      key="map"
      initial={{ opacity: 0, y: 10, scale: 0.98 }}
      animate={{ opacity: 1, y: 0, scale: 1 }}
      exit={{ opacity: 0, y: -10, scale: 0.98 }}
      transition={{ duration: 0.3 }}
      className="h-full flex flex-col"
    >
      <div className="flex items-center justify-between gap-3">
        <div className="relative">
          <button
            onClick={() => setDropdownOpen(!dropdownOpen)}
            className="flex items-center gap-2 px-3 py-1.5 bg-stone-900/60 backdrop-blur-sm rounded-lg border transition-all cursor-pointer hover:bg-stone-800/60"
            style={{ borderColor: `${chapterThemeColors.primary}33` }}
          >
            <Mountain size={16} style={{ color: chapterThemeColors.primaryLight }} />
            <span className="text-sm font-medium" style={{ color: chapterThemeColors.primaryLight }}>{t(`map.${selectedChapter.id}`)}</span>
            <ChevronDown size={14} className={`text-stone-500 transition-transform ${dropdownOpen ? 'rotate-180' : ''}`} />
          </button>

          <AnimatePresence>
            {dropdownOpen && (
              <>
                <div className="fixed inset-0 z-40" onClick={() => setDropdownOpen(false)} />
                <motion.div
                  initial={{ opacity: 0, y: 4 }}
                  animate={{ opacity: 1, y: 0 }}
                  exit={{ opacity: 0, y: 4 }}
                  className="absolute top-full mt-1 left-0 z-50 bg-stone-900/95 backdrop-blur-xl rounded-lg border border-white/10 shadow-xl py-1 min-w-[220px]"
                >
                  {MAP_CHAPTERS.map((chapter) => {
                    const unlocked = normalizedProgress.unlockedChapters.includes(chapter.id);
                    const chapterProgress = getChapterProgress(normalizedProgress, chapter);
                    const chapterColors = themeColors[chapter.theme];
                    
                    return (
                      <button
                        key={chapter.id}
                        disabled={!unlocked}
                        onClick={() => { onSelectChapter(chapter.id); setDropdownOpen(false); }}
                        className={`w-full flex items-center gap-2 px-3 py-2 text-left transition-colors cursor-pointer ${selectedChapter.id === chapter.id ? 'bg-white/5' : 'hover:bg-white/5'}`}
                        style={{ opacity: unlocked ? 1 : 0.4 }}
                      >
                        <Mountain size={14} style={{ color: chapterColors.primaryLight }} />
                        <span className="flex-1 text-sm text-stone-200">{t(`map.${chapter.id}`)}</span>
                        {chapterProgress.completed && <Star size={12} className="text-amber-400" fill="currentColor" />}
                        {!unlocked && <Lock size={12} className="text-stone-500" />}
                      </button>
                    );
                  })}
                </motion.div>
              </>
            )}
          </AnimatePresence>
        </div>

        <div className="flex items-center gap-2 text-xs">
          <Star size={12} className="text-amber-400" fill="currentColor" />
          <span className="text-stone-400">{totalStars}</span>
          <span className="text-stone-600">|</span>
          <span className="text-stone-500">{selectedChapter.levelRange}</span>
          <span className="text-stone-600">|</span>
          <span style={{ color: chapterThemeColors.primaryLight }}>{selectedChapterProgress.cleared}/{selectedChapterProgress.total}</span>
          <span className="text-stone-600">|</span>
          <span className="px-1.5 py-0.5 rounded font-medium" style={{ 
            backgroundColor: `${chapterThemeColors.primary}22`, 
            color: chapterThemeColors.primaryLight 
          }}>
            {Math.round((selectedChapterProgress.cleared / selectedChapterProgress.total) * 100)}%
          </span>
        </div>
      </div>

      <MapViewport
        playerLevel={playerLevel}
        loading={loading}
        normalizedProgress={normalizedProgress}
        selectedChapter={selectedChapter}
        selectedChapterProgress={selectedChapterProgress}
        onEnterNode={onEnterNode}
        focusNodeId={focusNodeId}
        onClearFocus={onClearFocus}
      />
    </motion.div>
  );
}


===================== [D:\download\LootingRPG\src\components\game\tabs\MonsterCodexTab.tsx] =====================
import { useState } from 'react';
import { motion, AnimatePresence } from 'motion/react';
import { BookOpen, Crown, Skull, Heart, Swords, Shield, Flame, Zap, Info } from 'lucide-react';
import { useTranslation } from 'react-i18next';
import type { TFunction } from 'i18next';
import { BOSS_MONSTERS, NORMAL_MONSTERS } from '../../../domains/monster/services/monsterCatalog';
import { UI_DIMENSIONS } from '../../../config/ui/tokens';
import { traitScoreMap, counterGoalScoreMap, StrategyTag } from '../../../config/game/monsterSchema';
import type {MonsterTrait, ThreatType } from '../../../shared/types/game';
import type { Monster } from '../../../shared/types/game';
const traitColorMap: Record<MonsterTrait, string> = {
  thorns: 'border-rose-400/30 bg-rose-500/10 text-rose-200',
  lifesteal: 'border-emerald-400/30 bg-emerald-500/10 text-emerald-200',
  double_attack: 'border-orange-400/30 bg-orange-500/10 text-orange-200',
  shield_on_start: 'border-blue-400/30 bg-blue-500/10 text-blue-200',
  rage_on_low_hp: 'border-red-400/30 bg-red-500/10 text-red-200',
};

const strategyTagStyleMap: Record<StrategyTag, string> = {
  offense: 'border-rose-400/35    bg-rose-500/10    text-rose-200',
  defense: 'border-blue-400/35    bg-blue-500/10    text-blue-200',
  sustain: 'border-emerald-400/35 bg-emerald-500/10 text-emerald-200',
};
const threatStyleMap: Record<ThreatType, string> = {
  burst_punish: 'border-fuchsia-400/35 bg-fuchsia-500/10 text-fuchsia-200',
  sustain_pressure: 'border-rose-400/35 bg-rose-500/10 text-rose-200',
  tank_breaker: 'border-amber-400/35 bg-amber-500/10 text-amber-200',
  attrition: 'border-cyan-400/35 bg-cyan-500/10 text-cyan-200',
};

const inferThreatTypes = (monster: Monster): ThreatType[] => {
  if (monster.threatTypes?.length) return monster.threatTypes;

  const result: ThreatType[] = [];
  const traits = monster.traits ?? [];

  if (traits.includes('thorns') || traits.includes('shield_on_start')) {
    result.push('burst_punish');
  }
  if (traits.includes('double_attack') || traits.includes('rage_on_low_hp')) {
    result.push('sustain_pressure');
  }
  if (traits.includes('shield_on_start') || monster.counterGoal?.stat === 'attack') {
    result.push('tank_breaker');
  }
  if (traits.includes('lifesteal') || monster.counterGoal?.stat === 'hp' || monster.counterGoal?.stat === 'lifesteal') {
    result.push('attrition');
  }

  if (monster.monsterType === 'boss' && result.length === 0) {
    result.push('sustain_pressure');
  }

  if (result.length === 0) {
    result.push('tank_breaker');
  }

  return result.slice(0, 2);
};

const getStrategyTags = (monster: Monster): StrategyTag[] => {
  const score: Record<StrategyTag, number> = {
    offense: 0,
    defense: 0,
    sustain: 0,
  };
  if (monster.monsterType === 'boss') {
    score.defense += 1;
    score.sustain += 1;
  }
  (monster.traits ?? []).forEach((trait) => {
    const traitScores = traitScoreMap[trait];
    if (traitScores) {
      Object.entries(traitScores).forEach(([key, value]) => {
        score[key as StrategyTag] += value ?? 0;
      });
    }
  });

  if (monster.counterGoal?.stat) {
    const tag = counterGoalScoreMap[monster.counterGoal.stat];
    if (tag) {
      score[tag] += 2;
    }
  }

  return (Object.entries(score) as [StrategyTag, number][])
    .sort((a, b) => b[1] - a[1])
    .filter(([, value], index) => value > 0 || index === 0)
    .slice(0, 2)
    .map(([tag]) => tag);
};

type CodexTranslator = TFunction;

const getStrategyHints = (monster: Monster, t: CodexTranslator): string[] => {
  const hints: string[] = [];

  if (monster.monsterType === 'boss') {
    hints.push(String(t('codex.hints.bossIntro')));
  } else {
    hints.push(String(t('codex.hints.normalIntro')));
  }

  (monster.traits ?? []).forEach((trait) => {
    const translateUnknown = t as unknown as (k: string, opts?: Record<string, unknown>) => unknown;
    const traitHints: unknown = translateUnknown(`trait.hints.${trait}`, { returnObjects: true });

    if (Array.isArray(traitHints)) {
      traitHints.forEach((text) => {
        if (typeof text === 'string' && !hints.includes(text)) hints.push(text);
      });
    } else if (typeof traitHints === 'string' && !hints.includes(traitHints)) {
      hints.push(traitHints);
    }
  });

  if (monster.counterGoal) {
    hints.push(String(t('codex.hints.counterGoal')));
    if (monster.counterGoal.successText && !hints.includes(monster.counterGoal.successText)) {
      hints.push(monster.counterGoal.successText);
    }
    if (monster.counterGoal.failText && !hints.includes(monster.counterGoal.failText)) {
      hints.push(monster.counterGoal.failText);
    }
  }

  if (!monster.traits?.length && !monster.counterGoal) {
    hints.push(String(t('codex.hints.simple')));
  }

  return hints.slice(0, 4);
};

function TraitTags({ traits, t }: { traits?: MonsterTrait[]; t: (k: string) => string }) {
  if (!traits?.length) {
    return <span className="text-[10px] text-gray-500">{t('trait.none')}</span>;
  }

  return (
    <div className="flex flex-wrap gap-1.5">
      {traits.map((trait) => (
        <span
          key={trait}
          className={`text-[10px] px-2 py-0.5 rounded border ${traitColorMap[trait] || 'border-red-400/30 bg-red-900/10 text-red-200'}`}
        >
          {t(`trait.${trait}`)}
        </span>
      ))}
    </div>
  );
}

function MonsterListItem({
  monster,
  isSelected,
  isBoss,
  onClick,
}: {
  monster: Monster;
  isSelected: boolean;
  isBoss: boolean;
  onClick: () => void;
}) {
  return (
    <motion.button
      onClick={onClick}
      className={`w-full flex items-center gap-2 p-2 rounded-lg border transition-all duration-150 text-left ${
        isSelected
          ? isBoss
            ? 'border-rose-500/60 bg-rose-500/20'
            : 'border-red-700/60 bg-red-900/20'
          : isBoss
            ? 'border-rose-500/20 bg-rose-950/15 hover:border-rose-500/40 hover:bg-rose-500/10'
            : 'border-game-border/40 bg-game-bg/40 hover:border-red-800/40 hover:bg-red-900/10'
      }`}
    >
      <div
        style={{ width: `${UI_DIMENSIONS.codexIconSize}px`, height: `${UI_DIMENSIONS.codexIconSize}px` }}
        className={`rounded-md flex items-center justify-center text-lg flex-shrink-0 ${isBoss ? 'bg-rose-500/20' : 'bg-game-card/40'}`}
      >
        {monster.icons.map((ic: string, i: number) => (
          <span key={i}>{ic}</span>
        ))}
      </div>
      <div className="flex-1 min-w-0">
        <div className={`text-[11px] font-medium truncate ${isBoss ? 'text-rose-200' : 'text-gray-200'}`}>
          {monster.name}
        </div>
        <div className="text-[9px] text-gray-500 flex items-center gap-1.5">
          <span className="text-red-400/80">Lv.{monster.level}</span>
          <span className="text-red-400/70">{monster.maxHp}</span>
          <span className="text-orange-400/70">{monster.attack}</span>
          <span className="text-blue-400/70">{monster.defense}</span>
        </div>
      </div>
      {isBoss && <Crown size={11} className="text-yellow-400/60 flex-shrink-0" />}
    </motion.button>
  );
}

function MonsterDetailPanel({ monster, t }: { monster: Monster; t: CodexTranslator }) {
  const isBoss = monster.monsterType === 'boss';
  const strategyHints = getStrategyHints(monster, t);
  const strategyTags = getStrategyTags(monster);
  const threatTypes = inferThreatTypes(monster);

  return (
    <motion.div
      key={monster.id}
      initial={{ opacity: 0, x: 20 }}
      animate={{ opacity: 1, x: 0 }}
      exit={{ opacity: 0, x: -20 }}
      className="h-full flex flex-col"
    >
      <div className={`relative rounded-xl border p-3 flex-1 ${isBoss ? 'border-rose-500/30 bg-gradient-to-br from-rose-950/25 to-rose-900/10' : 'border-game-border/60 bg-game-bg/50'}`}>
        <div className="absolute -top-10 -right-10 w-24 h-24 bg-red-900/20 rounded-full blur-2xl" />
        
        <div className="relative z-10 h-full flex flex-col">
          <div className="flex items-center gap-2 mb-3">
            <motion.div
              whileHover={{ scale: 1.05 }}
              className={`w-12 h-12 rounded-lg flex items-center justify-center text-3xl ${isBoss ? 'bg-gradient-to-br from-rose-600/30 to-red-600/20 shadow-lg shadow-rose-500/15' : 'bg-game-card/60 shadow'}`}
            >
              {monster.icons.map((ic: string, i: number) => (<span key={i}>{ic}</span>))}
            </motion.div>
            <div className="flex-1 min-w-0">
              <h3 className={`text-sm font-display font-bold truncate ${isBoss ? 'text-rose-200 drop-shadow-[0_0_10px_rgba(244,63,94,0.4)]' : 'text-gray-100'}`}>
                {monster.name}
              </h3>
              <div className="text-[10px] text-red-400/80 font-mono mt-0.5">Lv.{monster.level}</div>
              {isBoss && (
                <div className="flex items-center gap-1 mt-0.5">
                    <Crown size={10} className="text-yellow-400" />
                    <span className="text-[9px] text-yellow-400/70">{t('codex.bossLevelLabel')}</span>
                  </div>
              )}
            </div>
          </div>

          <div className="grid grid-cols-3 gap-2 mb-3">
            <motion.div
              whileHover={{ scale: 1.03 }}
              className="bg-black/25 rounded-lg p-2 border border-white/5"
            >
              <div className="flex items-center gap-1 mb-1">
                <Heart size={10} className="text-red-400" />
                <span className="text-[8px] text-gray-400 uppercase">{t('codex.stat.hp')}</span>
              </div>
              <div className="text-lg font-bold text-red-300">{monster.maxHp}</div>
              <div className="w-full h-1 bg-red-500/20 rounded-full mt-1 overflow-hidden">
                <div className="h-full bg-gradient-to-r from-red-500 to-red-400 rounded-full" style={{ width: `${Math.min(100, (monster.maxHp / 500) * 100)}%` }} />
              </div>
            </motion.div>
            <motion.div
              whileHover={{ scale: 1.03 }}
              className="bg-black/25 rounded-lg p-2 border border-white/5"
            >
                <div className="flex items-center gap-1 mb-1">
                <Swords size={10} className="text-orange-400" />
                <span className="text-[8px] text-gray-400 uppercase">{t('codex.stat.attack')}</span>
              </div>
              <div className="text-lg font-bold text-orange-300">{monster.attack}</div>
              <div className="w-full h-1 bg-orange-500/20 rounded-full mt-1 overflow-hidden">
                <div className="h-full bg-gradient-to-r from-orange-500 to-orange-400 rounded-full" style={{ width: `${Math.min(100, (monster.attack / 50) * 100)}%` }} />
              </div>
            </motion.div>
            <motion.div
              whileHover={{ scale: 1.03 }}
              className="bg-black/25 rounded-lg p-2 border border-white/5"
            >
                <div className="flex items-center gap-1 mb-1">
                <Shield size={10} className="text-blue-400" />
                <span className="text-[8px] text-gray-400 uppercase">{t('codex.stat.defense')}</span>
              </div>
              <div className="text-lg font-bold text-blue-300">{monster.defense}</div>
                <div className="w-full h-1 bg-blue-500/20 rounded-full mt-1 overflow-hidden">
                <div className="h-full bg-gradient-to-r from-blue-500 to-blue-400 rounded-full" style={{ width: `${Math.min(100, (monster.defense / 30) * 100)}%` }} />
              </div>
            </motion.div>
          </div>

          <div className="mb-2">
            <div className="flex items-center gap-1 mb-1.5">
              <Zap size={10} className="text-red-400" />
              <span className="text-[9px] text-gray-400 uppercase">{t('codex.traits')}</span>
            </div>
            <TraitTags traits={monster.traits} t={t} />
          </div>

          <div className="mb-2">
            <div className="flex items-center gap-1 mb-1.5">
              <Info size={10} className="text-fuchsia-300" />
              <span className="text-[9px] text-gray-400 uppercase">{t('codex.threatTypes')}</span>
            </div>
            <div className="flex flex-wrap gap-1.5">
              {threatTypes.map((threat) => (
                <span
                  key={threat}
                  className={`text-[9px] px-1.5 py-0.5 rounded border ${threatStyleMap[threat]}`}
                >
                  {t(`codex.threat.${threat}`)}
                </span>
              ))}
            </div>
          </div>

          <div className="mb-2 rounded-lg border border-indigo-400/20 bg-indigo-500/5 p-2">
            <div className="flex items-center gap-1 mb-1">
              <BookOpen size={10} className="text-indigo-300" />
              <span className="text-[9px] text-indigo-200 uppercase">{t('codex.background')}</span>
            </div>
            <p className="text-[9px] text-indigo-100/80 leading-relaxed">
              {monster.background ?? t('codex.backgroundFallback')}
            </p>
          </div>

          {isBoss && monster.counterGoal && (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              className="mt-auto rounded-lg border border-amber-400/25 bg-amber-500/8 p-2"
            >
              <div className="flex items-center gap-1.5 mb-1">
                <Flame size={11} className="text-amber-400" />
                <span className="text-[10px] font-medium text-amber-200">{t('codex.counterGoal')}</span>
              </div>
              <div className="text-[9px] text-amber-100/70">
                {monster.counterGoal.title}
              </div>
              <div className="text-[8px] text-amber-400/50 mt-0.5">
                {t(`stat.${monster.counterGoal.stat}`, { defaultValue: monster.counterGoal.stat })} 鈮?{monster.counterGoal.threshold}
              </div>
            </motion.div>
          )}

          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            className="mt-2 rounded-lg border border-cyan-400/20 bg-cyan-500/5 p-2"
          >
            <div className="flex items-center gap-1.5 mb-1">
              <Info size={11} className="text-cyan-300" />
              <span className="text-[10px] font-medium text-cyan-200">{t('codex.tacticsTitle')}</span>
            </div>
            <div className="flex flex-wrap gap-1 mb-1.5">
                {strategyTags.map((tag) => (
                <span
                  key={tag}
                  className={`text-[9px] px-1.5 py-0.5 rounded border ${strategyTagStyleMap[tag]}`}
                >
                  {t(`codex.strategy.${tag}`, { defaultValue: tag })}
                </span>
              ))}
            </div>
            <ul className="space-y-1">
              {strategyHints.map((hint) => (
                <li key={hint} className="text-[9px] text-cyan-100/80 leading-relaxed">
                  路 {hint}
                </li>
              ))}
            </ul>
          </motion.div>
        </div>
      </div>
    </motion.div>
  );
}

export function MonsterCodexTab() {
  const { t } = useTranslation();
  const [selectedMonsterId, setSelectedMonsterId] = useState<string | null>(NORMAL_MONSTERS[0]?.id || null);
  const [activeTab, setActiveTab] = useState<'normal' | 'boss'>('normal');

  const allMonsters = [...NORMAL_MONSTERS, ...BOSS_MONSTERS];
  const selectedMonster = allMonsters.find(m => m.id === selectedMonsterId);

  const currentList = activeTab === 'normal' ? NORMAL_MONSTERS : BOSS_MONSTERS;

  return (
    <motion.div
      key="codex"
      initial={{ opacity: 0, y: 10, scale: 0.98 }}
      animate={{ opacity: 1, y: 0, scale: 1 }}
      exit={{ opacity: 0, y: -10, scale: 0.98 }}
      transition={{ duration: 0.3 }}
      className="h-full max-h-full flex flex-col gap-3 overflow-hidden"
    >
      <motion.section
        initial={{ opacity: 0, x: -20 }}
        animate={{ opacity: 1, x: 0 }}
        className="border border-game-border/50 rounded-xl bg-gradient-to-br from-game-card/80 to-game-card/40 p-3 relative overflow-hidden flex-shrink-0"
      >
        <div className="absolute inset-0 bg-gradient-to-r from-cyan-500/5 to-red-900/10" />
        <div className="absolute -top-10 -right-10 w-32 h-32 bg-cyan-500/10 rounded-full blur-3xl" />
        
        <div className="relative z-10">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <motion.div 
                whileHover={{ rotate: 15, scale: 1.1 }}
                className="p-1.5 rounded-lg bg-cyan-500/20"
              >
                <BookOpen size={14} className="text-cyan-300" />
              </motion.div>
              <span className="font-display text-sm text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-red-500">{t('codex.title')}</span>
            </div>
            
            <div className="flex gap-1 bg-game-bg/50 p-0.5 rounded-lg border border-game-border/30">
              <motion.button
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
                onClick={() => {
                  setActiveTab('normal');
                  const first = NORMAL_MONSTERS[0];
                  if (first) setSelectedMonsterId(first.id);
                }}
                className={`px-2.5 py-1 rounded-md text-[10px] font-medium transition-all ${activeTab === 'normal' ? 'bg-red-900/30 text-red-300 border border-red-700/30' : 'text-gray-400 hover:text-gray-200'}`}
              >
                <Skull size={10} className="inline mr-1" />
                {t('codex.tab.normal')} ({NORMAL_MONSTERS.length})
              </motion.button>
              <motion.button
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
                onClick={() => {
                  setActiveTab('boss');
                  const first = BOSS_MONSTERS[0];
                  if (first) setSelectedMonsterId(first.id);
                }}
                className={`px-2.5 py-1 rounded-md text-[10px] font-medium transition-all ${activeTab === 'boss' ? 'bg-rose-500/30 text-rose-300 border border-rose-500/30' : 'text-gray-400 hover:text-gray-200'}`}
              >
                <Crown size={10} className="inline mr-1" />
                {t('codex.tab.boss')} ({BOSS_MONSTERS.length})
              </motion.button>
            </div>
          </div>
        </div>
      </motion.section>

      <div className="flex-1 grid grid-cols-1 lg:grid-cols-2 gap-2 min-h-0 overflow-hidden items-stretch">
        <motion.section
          initial={{ opacity: 0, x: -20 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ delay: 0.1 }}
          className="border border-game-border/50 rounded-xl bg-game-bg/40 p-2 overflow-hidden flex flex-col h-full min-h-0"
        >
          <div className="flex items-center gap-2 mb-2 text-[10px] text-gray-400 uppercase tracking-wider flex-shrink-0">
            <Info size={12} />
            <span>{t('codex.listTitle')}</span>
          </div>
          
          <div className="flex-1 overflow-y-auto pr-1 space-y-1.5 scrollbar-thin min-h-0">
            {currentList.map((monster, index) => (
              <motion.div
                key={monster.id}
                initial={{ opacity: 0, x: -20 }}
                animate={{ opacity: 1, x: 0 }}
                transition={{ delay: index * 0.02 }}
              >
                <MonsterListItem
                  monster={monster}
                  isSelected={selectedMonsterId === monster.id}
                  isBoss={activeTab === 'boss'}
                  onClick={() => setSelectedMonsterId(monster.id)}
                />
              </motion.div>
            ))}
          </div>
        </motion.section>

        <motion.section
          initial={{ opacity: 0, x: 20 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ delay: 0.15 }}
          className="border border-game-border/50 rounded-xl bg-game-bg/30 p-2 overflow-hidden flex flex-col h-full min-h-0"
        >
          <div className="flex items-center gap-2 mb-2 text-[10px] text-gray-400 uppercase tracking-wider flex-shrink-0">
            <Heart size={12} className="text-red-400" />
            <span>{t('codex.detailTitle')}</span>
          </div>
          
          <div className="flex-1 overflow-y-auto overflow-x-hidden scrollbar-thin min-h-0">
            <AnimatePresence mode="wait">
              {selectedMonster ? (
                <MonsterDetailPanel monster={selectedMonster} t={t} />
              ) : (
                <div className="h-full flex items-center justify-center text-gray-500">
                  <div className="text-center">
                      <Info size={24} className="mx-auto mb-1 opacity-30" />
                      <p className="text-[10px]">{t('codex.selectMonster')}</p>
                    </div>
                </div>
              )}
            </AnimatePresence>
          </div>
        </motion.section>
      </div>
    </motion.div>
  );
}


===================== [D:\download\LootingRPG\src\components\game\AppHeader.tsx] =====================
import { Coins, Download, LogOut, RefreshCw, Sword, Upload, Settings2, ChevronDown, Palette } from 'lucide-react';
import { motion, AnimatePresence } from 'motion/react';
import { useState, useEffect } from 'react';
import { createPortal } from 'react-dom';
import type { PlayerStats } from '../../types/game';
import { useTheme } from '../../config/themes/ThemeContext';

interface AppHeaderProps {
  gold: number;
  playerName: string;
  playerStats: PlayerStats;
  onReset: () => void;
  onLogout: () => void;
  onExportSave: () => void;
  onImportSave: () => void;
}

export function AppHeader({
  gold,
  playerName,
  playerStats,
  onReset,
  onLogout,
  onExportSave,
  onImportSave,
}: AppHeaderProps) {
  const { theme, themes, setTheme } = useTheme();
  const [showMenu, setShowMenu] = useState(false);
  const expNeeded = playerStats.level * 100;
  const expPercent = Math.min(100, (playerStats.xp / expNeeded) * 100);

  return (
    <header className="flex items-center justify-between gap-4 h-16 px-5 border-b border-white/5 bg-gradient-to-b from-stone-900 via-stone-900/95 to-stone-950 backdrop-blur-md shadow-lg shadow-black/20">
      <div className="flex items-center gap-5">
        <div className="flex items-center gap-3">
          <div className="relative">
            <div className="w-10 h-10 bg-gradient-to-br from-amber-600 via-amber-700 to-amber-900 rounded-xl flex items-center justify-center shadow-lg shadow-amber-900/40 border border-amber-500/30">
              <Sword className="text-amber-100" size={22} strokeWidth={2.5} />
            </div>
            <div className="absolute -bottom-0.5 -right-0.5 w-3 h-3 bg-gradient-to-r from-emerald-400 to-emerald-600 rounded-full border-2 border-stone-900" />
          </div>
          <div className="flex flex-col">
            <span className="text-lg font-display font-bold tracking-wider text-transparent bg-clip-text bg-gradient-to-r from-amber-300 via-yellow-200 to-amber-400 drop-shadow-sm">
              LOOT GRINDER
            </span>
            <span className="text-[9px] font-medium tracking-[0.2em] text-stone-500 uppercase">Rare Earth Explorer</span>
          </div>
        </div>

        <div className="w-px h-8 bg-gradient-to-b from-transparent via-stone-700/50 to-transparent" />

        <div className="flex items-center gap-4">
          <div className="flex items-center gap-2.5 px-3.5 py-2 bg-stone-800/40 rounded-xl border border-white/5">
            <div className="w-7 h-7 rounded-lg bg-gradient-to-br from-red-800/30 to-red-900/30 flex items-center justify-center border border-red-700/20">
              <span className="text-xs font-bold text-indigo-300">{playerName.charAt(0).toUpperCase()}</span>
            </div>
            <span className="text-sm font-medium text-stone-200">{playerName}</span>
            <span className="px-1.5 py-0.5 text-xs font-bold bg-gradient-to-r from-amber-600 to-amber-700 text-amber-100 rounded-md shadow-inner">Lv.{playerStats.level}</span>
          </div>

          <div className="flex items-center gap-2 w-28">
            <div className="flex-1 h-2 rounded-full bg-stone-800 border border-stone-700/50 overflow-hidden">
              <motion.div
                className="h-full bg-gradient-to-r from-amber-700 via-amber-600 to-amber-500 relative"
                initial={{ width: 0 }}
                animate={{ width: `${expPercent}%` }}
                transition={{ duration: 0.5, ease: 'easeOut' }}
              >
                <div className="absolute inset-0 bg-gradient-to-b from-white/20 to-transparent rounded-full" />
              </motion.div>
            </div>
            <span className="text-[10px] text-stone-500 font-mono w-12 text-right">{playerStats.xp}/{expNeeded}</span>
          </div>

          <div className="flex items-center gap-3 text-xs">
            <div className="flex items-center gap-1.5 px-2 py-1 bg-rose-500/10 rounded-md border border-rose-500/20">
              <Sword size={12} className="text-rose-400" />
              <span className="text-rose-300 font-semibold">{playerStats.attack}</span>
              <span className="text-stone-600 font-normal">ATK</span>
            </div>
            <div className="flex items-center gap-1.5 px-2 py-1 bg-emerald-500/10 rounded-md border border-emerald-500/20">
              <div className="w-3 h-3 rounded-full bg-emerald-500/30 border border-emerald-400/50" />
              <span className="text-emerald-300 font-semibold">{playerStats.hp}</span>
              <span className="text-stone-600 font-normal">HP</span>
            </div>
            <div className="flex items-center gap-1.5 px-2 py-1 bg-sky-500/10 rounded-md border border-sky-500/20">
              <div className="w-3 h-1.5 rounded-sm bg-sky-400/50" />
              <span className="text-sky-300 font-semibold">{playerStats.defense}</span>
              <span className="text-stone-600 font-normal">DEF</span>
            </div>
          </div>
        </div>
      </div>

      <div className="flex items-center gap-3">
        <div className="flex items-center gap-2 px-4 py-2 bg-gradient-to-r from-amber-900/30 to-amber-800/20 rounded-xl border border-amber-700/30 shadow-lg shadow-amber-900/10">
          <Coins className="text-amber-400" size={16} strokeWidth={2} />
          <span className="font-mono font-bold text-amber-400 text-sm tracking-wide">{gold.toLocaleString()}</span>
        </div>

        <div className="relative">
          <motion.button
            whileHover={{ scale: 1.05, backgroundColor: 'rgba(51, 65, 85, 0.5)' }}
            whileTap={{ scale: 0.95 }}
            onClick={() => setShowMenu(!showMenu)}
            className="flex items-center gap-1 p-2.5 text-stone-400 hover:text-stone-200 rounded-lg transition-all cursor-pointer app-header-settings-anchor"
          >
            <Settings2 size={18} strokeWidth={2} />
            <ChevronDown size={12} className={`transition-transform ${showMenu ? 'rotate-180' : ''}`} />
          </motion.button>
          <MenuPortal
            show={showMenu}
            onClose={() => setShowMenu(false)}
            onExportSave={() => { onExportSave(); setShowMenu(false); }}
            onImportSave={() => { onImportSave(); setShowMenu(false); }}
            onLogout={() => { onLogout(); setShowMenu(false); }}
            onReset={() => { onReset(); setShowMenu(false); }}
            theme={theme}
            themes={themes}
            onThemeChange={(id) => { setTheme(id); setShowMenu(false); }}
          />
        </div>
      </div>
    </header>
  );
}

import type { Theme } from '../../config/themes/types';

interface MenuPortalProps {
  show: boolean;
  onClose: () => void;
  onExportSave: () => void;
  onImportSave: () => void;
  onLogout: () => void;
  onReset: () => void;
  theme: Theme;
  themes: Theme[];
  onThemeChange: (id: string) => void;
}

function MenuPortal({
  show,
  onClose,
  onExportSave,
  onImportSave,
  onLogout,
  onReset,
  theme,
  themes,
  onThemeChange,
}: MenuPortalProps) {
  const [pos, setPos] = useState<{ top: number; right: number } | null>(null);

  useEffect(() => {
    if (!show) return;
    const update = () => {
      try {
        const anchor = document.querySelector('.app-header-settings-anchor') as HTMLElement | null;
        if (!anchor) return;
        const r = anchor.getBoundingClientRect();
        setPos({ top: r.bottom, right: window.innerWidth - r.right });
      } catch (e) {
        setPos({ top: 56, right: 16 });
      }
    };
    update();
    window.addEventListener('resize', update);
    window.addEventListener('scroll', update, true);
    return () => {
      window.removeEventListener('resize', update);
      window.removeEventListener('scroll', update, true);
    };
  }, [show]);

  if (!show) return null;

  return createPortal(
    <AnimatePresence>
      <>
        <div className="fixed inset-0 z-40" onClick={onClose} />
        <motion.div
          initial={{ opacity: 0, y: 8, scale: 0.96 }}
          animate={{ opacity: 1, y: 0, scale: 1 }}
          exit={{ opacity: 0, y: 8, scale: 0.96 }}
          transition={{ duration: 0.15 }}
          style={pos ? { position: 'fixed', top: pos.top, right: pos.right } : { position: 'fixed', top: 64, right: 20 }}
          className="z-[9999] bg-stone-900/95 backdrop-blur-xl rounded-xl border border-white/10 shadow-2xl shadow-black/40 py-1.5 min-w-[160px]"
        >
          <button
            onClick={onExportSave}
            className="w-full flex items-center gap-3 px-4 py-2.5 text-sm text-stone-300 hover:text-emerald-400 hover:bg-emerald-500/10 transition-all cursor-pointer"
          >
            <Download size={15} />
            瀵煎嚭瀛樻。
          </button>
          <button
            onClick={onImportSave}
            className="w-full flex items-center gap-3 px-4 py-2.5 text-sm text-stone-300 hover:text-emerald-400 hover:bg-emerald-500/10 transition-all cursor-pointer"
          >
            <Upload size={15} />
            瀵煎叆瀛樻。
          </button>
          <div className="my-1.5 border-t border-white/5" />
          <div className="px-4 py-2">
            <div className="flex items-center gap-2 text-xs text-stone-500 mb-2">
              <Palette size={12} />
              <span>涓婚</span>
            </div>
            <div className="flex gap-1.5">
              {themes.map((t) => (
                <button
                  key={t.id}
                  onClick={() => onThemeChange(t.id)}
                  className={`flex-1 px-2 py-1.5 text-xs rounded-md border transition-all cursor-pointer ${
                    theme.id === t.id
                      ? 'bg-stone-700/80 border-stone-500 text-stone-100'
                      : 'bg-stone-800/50 border-stone-700/50 text-stone-400 hover:border-stone-600 hover:text-stone-300'
                  }`}
                  style={{
                    borderColor: theme.id === t.id ? t.colors.gameAccent : undefined,
                  }}
                >
                  {t.name}
                </button>
              ))}
            </div>
          </div>
          <div className="my-1.5 border-t border-white/5" />
          <button
            onClick={onLogout}
            className="w-full flex items-center gap-3 px-4 py-2.5 text-sm text-stone-300 hover:text-blue-400 hover:bg-blue-500/10 transition-all cursor-pointer"
          >
            <LogOut size={15} />
            鍒囨崲鐜╁
          </button>
          <button
            onClick={onReset}
            className="w-full flex items-center gap-3 px-4 py-2.5 text-sm text-stone-300 hover:text-rose-400 hover:bg-rose-500/10 transition-all cursor-pointer"
          >
            <RefreshCw size={15} />
            閲嶇疆瀛樻。
          </button>
        </motion.div>
      </>
    </AnimatePresence>,
    document.body,
  );
}


===================== [D:\download\LootingRPG\src\components\game\BattleUnitCardBase.tsx] =====================
import type { ReactNode } from 'react';

interface BattleUnitCardBaseProps {
  subtitle?: ReactNode;
  className?: string;
  children?: ReactNode;
}

export function BattleUnitCardBase({subtitle, className = '', children }: BattleUnitCardBaseProps) {
  return (
    <div className={`aspect-square rounded-2xl border border-game-border/60 bg-black/20 pt-3 px-3 pb-0 flex flex-col ${className}`}>
      <div className="mb-2 min-h-[36px]">
        {subtitle ? <div className="text-xs text-gray-400 mt-1">{subtitle}</div> : null}
      </div>
      <div className="flex-1">{children}</div>
    </div>
  );
}

export default BattleUnitCardBase;


===================== [D:\download\LootingRPG\src\components\game\BattleView.tsx] =====================
import { useTranslation } from 'react-i18next';
import type { BattleSession } from '../../shared/types/game';
import PlayerCard from './PlayerCard';
import EnemyCard from './EnemyCard';
import BattleUnitCardBase from './BattleUnitCardBase';

interface BattleViewProps {
  session: BattleSession;
  onAttack: () => void;
  onRetreat: () => void;
}


export function BattleView({ session, onAttack, onRetreat }: BattleViewProps) {
  const { t } = useTranslation();
  const fallbackWaveOrder = Array.from(new Set((session.enemies ?? []).map((enemy) => {
    const waveId = enemy.meta?.waveId;
    return typeof waveId === 'string' ? waveId : 'wave-1';
  })));
  const waveOrder = Array.isArray(session.waveOrder) && session.waveOrder.length > 0
    ? session.waveOrder
    : fallbackWaveOrder;
  const safeWaveIndex = Number.isFinite(session.currentWaveIndex)
    ? Math.max(0, Math.min(Math.max(0, waveOrder.length - 1), session.currentWaveIndex))
    : 0;
  const currentWaveId = waveOrder[safeWaveIndex];
  const currentWaveEnemies = (session.enemies ?? []).filter((enemy) => {
    if (!currentWaveId) return true;
    const waveId = enemy.meta?.waveId;
    return (typeof waveId === 'string' ? waveId : 'wave-1') === currentWaveId;
  });


  const leftSlotCount = 6;
  const rightEnemies = currentWaveEnemies.slice(0, 9);

  return (
    <div className="bg-gradient-to-br from-game-card/90 to-game-card/70 border border-game-border/40 rounded-2xl p-5 flex flex-col h-[68vh] max-h-[820px] min-h-[420px] gap-4">
      <div className="flex items-center justify-between border-b border-game-border/30 pb-3">
        <div>
          <div className="text-[11px] uppercase text-gray-400 tracking-[0.5em] flex items-center gap-2">
            <span>馃搷</span>
            <span>{session.chapterName}</span>
          </div>
          <div className="text-xl font-semibold text-white">{t('battle.title')}</div>
          <div className="text-[11px] uppercase text-gray-400 tracking-[0.5em]">{session.nodeName}</div>
        </div>
        <div className="text-right text-xs text-gray-400">
          <div>{t('battle.turn')}: {session.turn}</div>
          <div>{t('battle.enemyProgress')}: {Math.min(safeWaveIndex + 1, waveOrder.length)} / {waveOrder.length}</div>
          <div className="text-[11px] uppercase tracking-[0.4em] mt-1">Rewards</div>
          <div className="text-sm text-white">鈥?/div>
        </div>
      </div>

      {/* battlefield section with square grid background */}
      <div className="rounded-2xl border border-game-border/60 bg-black/20">
        <div className="relative overflow-auto" style={{ width:'768px', height:'288px' }}>
          {/* grid lines overlay covering grid area */}
          <div
            className="absolute inset-0 pointer-events-none"
            style={{
              backgroundSize: '96px 96px',
              backgroundImage:
                'linear-gradient(to right, rgba(255,255,255,0.12) 1px, transparent 1px),\
                 linear-gradient(to bottom, rgba(255,255,255,0.12) 1px, transparent 1px)',
            }}
          />

          {/* fixed 3脳8 battlefield grid with constant cell size */}
          <div
            className="grid"
            style={{
              width: `${96 * 8}px`,
              height: `${96 * 3}px`,
              gridTemplateRows: `repeat(3, ${96}px)`,
              gridTemplateColumns: `repeat(8, ${96}px)`,
              gap: '0px',
            }}
          >
          {(() => {
            const rows = 3;
            const cols = 8;
            const total = rows * cols;
            const leftIdx = [0,1,8,9,16,17];
            const rightIdx = [5,6,7,13,14,15,21,22,23];
            const cells: React.ReactNode[] = Array(total).fill(null);

            // fill left slots (placeholders with player in fourth position)
            const leftSlots: React.ReactNode[] = [];
            for (let i = 0; i < leftSlotCount; i++) {
              if (i === 3) {
                leftSlots.push(<PlayerCard key="player" session={session} />);
              } else {
                leftSlots.push(
                  <BattleUnitCardBase
                    key={`ally-slot-${i}`}
                    subtitle="棰勭暀"
                    className="w-full"
                  >
                    <div className="h-full flex items-center justify-center text-xs text-gray-500">
                      Empty
                    </div>
                  </BattleUnitCardBase>
                );
              }
            }
            leftIdx.forEach((idx, i) => {
              cells[idx] = leftSlots[i] || null;
            });

            // fill right slots (enemies + placeholders)
            rightIdx.forEach((idx, i) => {
              const enemy = rightEnemies[i];
              if (enemy) {
                cells[idx] = <EnemyCard key={enemy.id} enemy={enemy} />;
              } else {
                cells[idx] = (
                  <BattleUnitCardBase
                    key={`enemy-slot-${i}`}
                    subtitle="绌?
                    className="w-full"
                  >
                    <div className="h-full flex items-center justify-center text-xs text-gray-500">
                      Empty
                    </div>
                  </BattleUnitCardBase>
                );
              }
            });

            return cells.map((cell, idx) => (
              <div key={idx} className="w-full h-full">
                {cell}
              </div>
            ));
          })()}
        </div>
      </div>

      <div className="flex gap-4 flex-1 min-h-[230px]">
        <div className="w-[260px] rounded-2xl border border-game-border/60 bg-black/20 p-4 flex flex-col gap-3">
          <div className="text-[10px] uppercase text-gray-400 tracking-[0.4em]">Actions</div>
          <button
            type="button"
            onClick={onAttack}
            disabled={session.status !== 'fighting'}
            className="w-full px-3 py-2 rounded-lg bg-amber-600 hover:bg-amber-500 text-white text-sm disabled:opacity-50"
          >
            {t('battle.attack')}
          </button>
          <button
            type="button"
            onClick={onRetreat}
            disabled={session.status !== 'fighting'}
            className="w-full px-3 py-2 rounded-lg bg-gray-700 hover:bg-gray-600 text-white text-sm disabled:opacity-50"
          >
            {t('battle.retreat')}
          </button>
          <div className="text-[11px] text-gray-500">
            {Math.min(safeWaveIndex + 1, waveOrder.length)} / {waveOrder.length}
          </div>
        </div>
        <div className="flex-1 rounded-2xl border border-game-border/60 bg-black/20 p-4 flex flex-col">
          <div className="flex items-center justify-between text-[10px] uppercase text-gray-400 tracking-[0.4em]">
            <span>battle log</span>
            <span>{t('battle.turn')}: {session.turn}</span>
          </div>
          <div className="mt-3 flex-1 overflow-auto space-y-1 text-xs text-gray-200">
            {session.logs.slice(-30).map((line, index) => (
              <div key={`${line}-${index}`} className="border-b border-game-border/10 pb-1">
                {line}
              </div>
            ))}
          </div>
        </div>
      </div>
    </div>
    </div>
  );
}


===================== [D:\download\LootingRPG\src\components\game\DebugPanel.tsx] =====================
import React, { useEffect, useState } from 'react';
import { QUALITIES, SLOTS } from '../../config/game/equipment';
import type { Equipment } from '../../types/game';
import { createCustomEquipment } from '../../domains/inventory/services/equipment';
interface DebugPanelProps { onAddItems: (items: Equipment[]) => void;}
export function DebugPanel({ onAddItems }: DebugPanelProps) {
  const [open, setOpen] = useState(false);
  const [quality, setQuality] = useState(QUALITIES[0] || 'common');
  const [slot, setSlot] = useState(SLOTS[0] || 'weapon');
  const [count, setCount] = useState(1);
  const [level, setLevel] = useState(1);

  useEffect(() => {
    const handler = (e: KeyboardEvent) => {
      if (e.ctrlKey && e.key.toLowerCase() === 'd') {
        e.preventDefault();
        setOpen((v) => !v);
      }
    };
    window.addEventListener('keydown', handler);
    return () => window.removeEventListener('keydown', handler);
  }, []);
  const handleAdd = () => {
    const n = Math.floor(count);
    const items: Equipment[] = [];
    for (let i = 0; i < n; i++) {
      items.push(createCustomEquipment(quality, slot, Math.floor(level)));
    }
    onAddItems(items);
    setOpen(false);
  };

  return (
    <div className="fixed bottom-6 right-6 z-50">
      <button
        className="px-3 py-2 bg-red-800 text-white rounded-lg shadow-md"
        onClick={() => setOpen((v) => !v)}
      >
        Debug
      </button>

      {open && (
        <div className="mt-2 w-64 p-3 bg-game-bg border border-game-border rounded-lg shadow-xl">
          <div className="mb-2 text-sm font-bold">Debug - 娣诲姞瑁呭 (Ctrl+D)</div>

          <label className="block text-xs text-gray-400">鍝佽川</label>
          <select className="w-full mb-2 p-1 bg-transparent border rounded" value={quality} onChange={(e) => setQuality(e.target.value)}>
            {QUALITIES.map((q) => (
              <option key={q} value={q}>{q}</option>
            ))}
          </select>

          <label className="block text-xs text-gray-400">閮ㄤ綅</label>
          <select className="w-full mb-2 p-1 bg-transparent border rounded" value={slot} onChange={(e) => setSlot(e.target.value)}>
            {SLOTS.map((s) => (
              <option key={s} value={s}>{s}</option>
            ))}
          </select>

          <label className="block text-xs text-gray-400">鏁伴噺</label>
          <input className="w-full mb-2 p-1 bg-transparent border rounded" type="number" min={1} max={100} value={count} onChange={(e) => setCount(Number(e.target.value))} />

          <label className="block text-xs text-gray-400">绛夌骇</label>
          <input className="w-full mb-3 p-1 bg-transparent border rounded" type="number" min={1} max={999} value={level} onChange={(e) => setLevel(Number(e.target.value))} />

          <div className="flex gap-2">
            <button className="flex-1 py-1 bg-green-600 text-white rounded" onClick={handleAdd}>娣诲姞</button>
            <button className="flex-1 py-1 bg-gray-600 text-white rounded" onClick={() => setOpen(false)}>鍙栨秷</button>
          </div>
        </div>
      )}
    </div>
  );
}

export default DebugPanel;


===================== [D:\download\LootingRPG\src\components\game\EnemyCard.tsx] =====================
import BattleUnitCardBase from './BattleUnitCardBase';
import type { BattleUnitInstance } from '../../types/battle/BattleUnit';

const percent = (value: number, max: number) => {
  if (max <= 0) return 0;
  return Math.max(0, Math.min(100, (value / max) * 100));
};

interface EnemyCardProps {
  enemy: BattleUnitInstance;
}
export function EnemyCard({ enemy }: EnemyCardProps) {
  const icon = typeof enemy.meta?.icon === 'string' ? enemy.meta.icon : '馃懢';

  return (
    <BattleUnitCardBase className="w-full p-0">
      <div className="relative w-full h-full">
        <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-3xl">
          {icon}
        </div>
        <div className="absolute bottom-0 left-0 right-0 h-2 rounded bg-gray-800 overflow-hidden">
          <div
            className="h-full bg-rose-500"
            style={{ width: `${percent(enemy.currentHp, enemy.baseStats.hp)}%` }}
          />
        </div>
      </div>
    </BattleUnitCardBase>
  );
}

export default EnemyCard;


===================== [D:\download\LootingRPG\src\components\game\GamePanel.tsx] =====================
import { AnimatePresence, motion } from 'motion/react';
import { useTranslation } from 'react-i18next';
import { lazy, Suspense } from 'react';
import { Trophy } from 'lucide-react';
import type { ActiveTab, GameState, MapProgressState } from '../../types/game';
import { TabButton } from '../ui/TabButton';
import type { MapChapterDef, MapNodeDef } from '../../config/map/ChapterData';

const InventoryTab = lazy(() => import('./tabs/InventoryTab').then(m => ({ default: m.InventoryTab })));
const ForgeTab = lazy(() => import('./tabs/ForgeTab').then(m => ({ default: m.ForgeTab })));
const MonsterCodexTab = lazy(() => import('./tabs/MonsterCodexTab').then(m => ({ default: m.MonsterCodexTab })));
const MapTab = lazy(() => import('./tabs/MapTab').then(m => ({ default: m.MapTab })));

interface GamePanelProps {
  gameState: GameState;
  activeTab: ActiveTab;
  loading: boolean;
  focusMapNode: string | null;
  onClearFocusMapNode: () => void;
  onSetTab: (tab: ActiveTab) => void;
  onEnterMapNode: (node: MapNodeDef, chapter: MapChapterDef) => void;
  mapProgress: MapProgressState;
  onSelectMapChapter: (chapterId: string) => void;
  onEquip: (id: string) => void;
  onSell: (id: string) => void;
  onForge: (id: string) => void;
  onQuickSellByQualityRange: (minQuality: string, maxQuality: string) => void;
  autoSellQualities: Record<string, boolean>;
  onToggleAutoSellQuality: (quality: string) => void;
  onReroll: (id: string, lockTypes?: string[]) => void;
  forgeSelectedId: string | null;
  onSelectForgeItem: (id: string) => void;
}

export function GamePanel({
  gameState,
  activeTab,
  loading,
  focusMapNode,
  onClearFocusMapNode,
  onSetTab,
  onEnterMapNode,
  mapProgress,
  onSelectMapChapter,
  onEquip,
  onSell,
  onForge,
  onQuickSellByQualityRange,
  autoSellQualities,
  onToggleAutoSellQuality,
  onReroll,
  forgeSelectedId,
  onSelectForgeItem,
}: GamePanelProps) {
  const { t } = useTranslation();
  const inventoryItems = gameState.backpack
    .filter((item) => !item.equipped)
    .map((item) => ({ ...item, equipped: false }));
  return (
    <div className="lg:col-span-8 flex flex-col gap-6 h-full">
      <div className="bg-gradient-to-br from-game-card/90 to-game-card/70 border border-game-border/50 rounded-2xl flex flex-col overflow-hidden shadow-2xl shadow-red-900/10 h-[68vh] max-h-[820px] min-h-[420px] relative">
        <div className="absolute inset-0 bg-gradient-to-br from-red-900/10 via-transparent to-rose-500/3 pointer-events-none" />
        
        <div className="flex border-b border-game-border relative z-10">
          <TabButton active={activeTab === 'map'} onClick={() => onSetTab('map')} label={t('map.explore')} />
          <TabButton active={activeTab === 'inventory'} onClick={() => onSetTab('inventory')} label={t('tabs.inventory')} />
          <TabButton active={activeTab === 'forge'} onClick={() => onSetTab('forge')} label={t('tabs.forge')} />
          <TabButton active={activeTab === 'codex'} onClick={() => onSetTab('codex')} label={t('tabs.codex')} />
        </div>

        <div className="p-4 overflow-hidden relative z-10 h-full">
          <AnimatePresence mode="wait">
            {activeTab === 'inventory' && (
              <motion.div 
                key="inventory"
                initial={{ opacity: 0, y: 10, scale: 0.98 }}
                animate={{ opacity: 1, y: 0, scale: 1 }}
                exit={{ opacity: 0, y: -10, scale: 0.98 }}
                transition={{ duration: 0.3 }}
                className="h-full"
              >
                <Suspense fallback={<div className="h-full flex items-center justify-center text-gray-500">Loading...</div>}>
                  <InventoryTab
                    items={inventoryItems}
                    loading={loading}
                    onEquip={onEquip}
                    onSell={onSell}
                  onForge={onForge}
                  onQuickSellByQualityRange={onQuickSellByQualityRange}
                  autoSellQualities={autoSellQualities}
                  onToggleAutoSellQuality={onToggleAutoSellQuality}
                />
                </Suspense>
              </motion.div>
            )}

            {activeTab === 'map' && (
              <Suspense fallback={<div className="h-full flex items-center justify-center text-gray-500">Loading...</div>}>
                <motion.div
                  key="map"
                  initial={{ opacity: 0, y: 10, scale: 0.98 }}
                  animate={{ opacity: 1, y: 0, scale: 1 }}
                  exit={{ opacity: 0, y: -10, scale: 0.98 }}
                  transition={{ duration: 0.3 }}
                  className="h-full"
                >
                  <MapTab
                    playerLevel={gameState.playerStats.level}
                    loading={loading}
                    progress={mapProgress}
                    onSelectChapter={onSelectMapChapter}
                    onEnterNode={onEnterMapNode}
                    focusNodeId={focusMapNode}
                    onClearFocus={onClearFocusMapNode}
                  />
                </motion.div>
              </Suspense>
            )}

            {activeTab === 'forge' && (
              <Suspense fallback={<div className="h-full flex items-center justify-center text-gray-500">Loading...</div>}>
                <motion.div 
                  key="forge"
                  initial={{ opacity: 0, y: 10, scale: 0.98 }}
                  animate={{ opacity: 1, y: 0, scale: 1 }}
                  exit={{ opacity: 0, y: -10, scale: 0.98 }}
                  transition={{ duration: 0.3 }}
                  className="h-full"
                >
                  <ForgeTab
                    gameState={gameState}
                    selectedId={forgeSelectedId}
                    loading={loading}
                    onSelect={onSelectForgeItem}
                    onForge={onForge}
                    onReroll={onReroll}
                  />
                </motion.div>
              </Suspense>
            )}

            {activeTab === 'codex' && (
              <Suspense fallback={<div className="h-full flex items-center justify-center text-gray-500">Loading...</div>}>
                <motion.div 
                  key="codex"
                  initial={{ opacity: 0, y: 10, scale: 0.98 }}
                  animate={{ opacity: 1, y: 0, scale: 1 }}
                  exit={{ opacity: 0, y: -10, scale: 0.98 }}
                  transition={{ duration: 0.3 }}
                  className="h-full"
                >
                  <MonsterCodexTab />
                </motion.div>
              </Suspense>
            )}
          </AnimatePresence>
        </div>

        <div className="bg-game-bg/80 border-t border-game-border/50 h-16 px-3 flex items-center justify-between text-[10px] font-mono text-gray-500 relative z-10 shrink-0">
          <div className="flex gap-4">
            <motion.span 
              whileHover={{ scale: 1.05 }}
              className="flex items-center gap-1 cursor-default"
            >
              <Trophy size={10} className="text-yellow-500" /> 
              <span>{t('label.legendary_pity')}</span> 
              <div className="w-20 h-2 bg-gray-700 rounded overflow-hidden">
                <div
                  className="h-full bg-yellow-500"
                  style={{ width: `${(gameState.pityCounts.legendary / 50) * 100}%` }}
                />
              </div>
            </motion.span>
            <motion.span 
              whileHover={{ scale: 1.05 }}
              className="flex items-center gap-1 cursor-default"
            >
              <Trophy size={10} className="text-red-500" /> 
              <span>{t('label.mythic_pity')}</span> 
              <div className="w-20 h-2 bg-gray-700 rounded overflow-hidden">
                <div
                  className="h-full bg-red-500"
                  style={{ width: `${(gameState.pityCounts.mythic / 200) * 100}%` }}
                />
              </div>
            </motion.span>
          </div>
          <motion.div 
            whileHover={{ scale: 1.05 }}
            className="flex items-center gap-2"
          >
            <motion.div 
              animate={{ opacity: [0.5, 1, 0.5] }}
              transition={{ duration: 2, repeat: Infinity }}
              className="w-2 h-2 rounded-full bg-green-500" 
            />
            <span className="text-green-500/70">READY</span>
          </motion.div>
        </div>
      </div>
    </div>
  );
}


===================== [D:\download\LootingRPG\src\components\game\GameScreen.tsx] =====================
import type { ActiveTab, BattleSession, GameState } from '../../types/game';
import type { MapProgressState } from '../../types/game';
import type { MapChapterDef, MapNodeDef } from '../../config/map/ChapterData';
import { AppHeader } from './AppHeader';
import { GamePanel } from './GamePanel';
import { PlayerPanel } from './PlayerPanel';
import { BattleView } from './BattleView';
import DebugPanel from './DebugPanel';

interface GameScreenProps {
  gameState: GameState;
  activeTab: ActiveTab;
  loading: boolean;
  playerName: string;
  /** current player stats summary used by header */
  playerStats: import('../../types/game').PlayerStats;
  autoSellQualities: Record<string, boolean>;
  forgeSelectedId: string | null;
  battleSession: BattleSession | null;
  mapProgress: MapProgressState;
  onExportSave: () => void;
  onImportSave: () => void;
  onLogout: () => void;
  onReset: () => void;
  onSetTab: (tab: ActiveTab) => void;
  focusMapNode: string | null;
  onClearFocusMapNode: () => void;
  onEnterMapNode: (node: MapNodeDef, chapter: MapChapterDef) => void;
  onSelectMapChapter: (chapterId: string) => void;
  onBattleAttack: () => void;
  onBattleRetreat: () => void;
  onQuickSellByQualityRange: (minQuality: string, maxQuality: string) => void;
  onEquip: (id: string) => void;
  onSell: (id: string) => void;
  onForge: (id: string) => void;
  onToggleAutoSellQuality: (quality: string) => void;
  onReroll: (id: string, lockTypes?: string[]) => void;
  onSelectForgeItem: (id: string) => void;
  onUnequip: (slot: string) => void;
  onDebugAddItems?: (quality: string, slot: string, count: number, level?: number) => void;
}

export function GameScreen({
  gameState,
  activeTab,
  loading,
  playerName,
  autoSellQualities,
  forgeSelectedId,
  battleSession,
  mapProgress,
  onExportSave,
  onImportSave,
  onLogout,
  onReset,
  onSetTab,
  focusMapNode,
  onClearFocusMapNode,
  onEnterMapNode,
  onSelectMapChapter,
  onBattleAttack,
  onBattleRetreat,
  onQuickSellByQualityRange,
  onEquip,
  onSell,
  onForge,
  onToggleAutoSellQuality,
  onReroll,
  onSelectForgeItem,
  onUnequip,
  onDebugAddItems,
}: GameScreenProps) {
  return (
    <div className="min-h-screen relative overflow-hidden">
      <div className="pointer-events-none absolute -top-32 -left-32 w-96 h-96 bg-red-900/30 blur-3xl rounded-full" />
      <div className="pointer-events-none absolute -bottom-32 -right-32 w-96 h-96 bg-rose-500/15 blur-3xl rounded-full" />

      <div className="relative flex flex-col max-w-6xl mx-auto p-4 md:p-6 gap-6">

        <AppHeader
          gold={gameState.playerStats.gold}
          playerName={playerName}
          playerStats={gameState.playerStats}
          onExportSave={onExportSave}
          onImportSave={onImportSave}
          onLogout={onLogout}
          onReset={onReset}
        />

        <main className="grid grid-cols-1 lg:flex gap-6 items-start">
          <div className="lg:flex-none lg:w-[28%] lg:max-w-[380px] lg:min-w-[240px]">
            <PlayerPanel gameState={gameState} onUnequip={onUnequip} />
          </div>

          <div className="flex-1">
            {battleSession ? (
              <BattleView
                session={battleSession}
                onAttack={onBattleAttack}
                onRetreat={onBattleRetreat}
              />
            ) : (
              <GamePanel
                gameState={gameState}
                activeTab={activeTab}
                loading={loading}
                focusMapNode={focusMapNode}
                onClearFocusMapNode={onClearFocusMapNode}
                onSetTab={onSetTab}
                onEnterMapNode={onEnterMapNode}
                mapProgress={mapProgress}
                onSelectMapChapter={onSelectMapChapter}
                onQuickSellByQualityRange={onQuickSellByQualityRange}
                onEquip={onEquip}
                onSell={onSell}
                onForge={onForge}
                autoSellQualities={autoSellQualities}
                onToggleAutoSellQuality={onToggleAutoSellQuality}
                onReroll={onReroll}
                forgeSelectedId={forgeSelectedId}
                onSelectForgeItem={onSelectForgeItem}
              />
            )}
          </div>
        </main>
        <DebugPanel onAddItems={(items) => {
          // forward to parent via optional callback (preserve item level)
          if (onDebugAddItems) {
            items.forEach((it) => onDebugAddItems(it.quality, it.slot, 1, it.level));
          }
        }} />
      </div>
    </div>
  );
}


===================== [D:\download\LootingRPG\src\components\game\ItemCard.tsx] =====================
import { Coins, Trash2, Shield, Zap, Gem, Crown, Star, Hexagon } from 'lucide-react';
import type { ReactNode } from 'react';
import { QUALITY_CONFIG } from '../../config/game/equipment';
import { getQualityLabel, getStatLabel } from '../../infra/i18n/labels';
import type { Equipment } from '../../types/game';
import { useTranslation } from 'react-i18next';

const iconMap: Record<string, ReactNode> = {
  shield: <Shield size={18} className="text-gray-400" />,
  zap: <Zap size={18} className="text-emerald-400" />,
  gem: <Gem size={18} className="text-blue-400" />,
  hexagon: <Hexagon size={18} className="text-red-400" />,
  crown: <Crown size={18} className="text-yellow-400" />,
  star: <Star size={18} className="text-red-400" />,
};

interface ItemCardProps {
  item: Equipment;
  onEquip?: () => void;
  onSell?: () => void;
  onForge?: () => void;
  loading: boolean;
  readonly?: boolean;
  highlighted?: boolean;
  onClick?: () => void;
}

export function ItemCard({ item, onEquip, onSell, onForge, loading, readonly, highlighted, onClick }: ItemCardProps) {
  const qualityColor = QUALITY_CONFIG[item.quality]?.color || 'text-gray-400';
  const qualityIcon = iconMap[QUALITY_CONFIG[item.quality]?.iconName || 'shield'];
  const forgeCost = (item.enhancementLevel + 1) * 500;
  const { t, i18n } = useTranslation();
  const localeName = i18n.language.startsWith('zh') ? (item.localeNames?.zh || item.name) : (item.localeNames?.en || item.name);
  const affixLabelMap: Record<string, string> = {
    crit_chance: t('stat.crit'),
    lifesteal: t('stat.lifesteal'),
    damage_bonus: t('stat.damage'),
    thorns: t('trait.thorns'),
    hp_bonus: t('stat.hp'),
  };

  const borderClass = item.quality === 'mythic' 
    ? 'mythic-border shadow-lg shadow-red-900/30' 
    : item.quality === 'legendary' 
      ? 'legendary-border shadow-lg shadow-amber-900/20' 
      : highlighted 
        ? 'border-red-700 shadow-lg shadow-red-900/30' 
        : 'border-game-border/50 hover:border-red-800/50';

  const bgClass = item.quality === 'mythic' 
    ? 'mythic-card-bg' 
    : item.quality === 'legendary' 
      ? 'legendary-card-bg' 
      : 'bg-game-bg/80';

  return (
    <div
      onClick={onClick}
      className={`${bgClass} border rounded-xl p-4 space-y-3 transition-all duration-200 relative group hover:shadow-lg ${borderClass} ${onClick ? 'cursor-pointer hover:scale-[1.02]' : ''}`}
    >
      {item.quality === 'mythic' && (
        <div className="mythic-ornaments" aria-hidden>
          <div className="mythic-embers" />
          <span className="mythic-sparkle s1" />
          <span className="mythic-sparkle s2" />
          <span className="mythic-sparkle s3" />
          <span className="mythic-sparkle s4" />
          <span className="mythic-sparkle s5" />
          <div className="mythic-shard sh1" />
          <div className="mythic-shard sh2" />
          <div className="mythic-shard sh3" />
          <div className="mythic-ember-trail" />
        </div>
      )}
      {item.equipped && (
        <span className="absolute top-2 right-2 text-[10px] px-2 py-0.5 rounded-full bg-red-900/20 text-red-400 border border-red-700/30 font-bold">
          {t('label.equipped')}
        </span>
      )}
      <div className="flex justify-between items-start">
        <div className="flex items-center gap-2">
          <div className="p-2 rounded-lg bg-game-card/60 text-2xl leading-none">{item.icon || '馃О'}</div>
          <div>
            <h4 className={`font-bold text-sm ${qualityColor}`}>
              {localeName} {item.enhancementLevel > 0 ? `+${item.enhancementLevel}` : ''}
            </h4>
            <div className="flex items-center gap-2 mt-1">
              <span className="text-[10px] text-gray-500 uppercase font-mono">Lv.{item.level} 鈥?{item.slot}</span>
              <span className="text-[10px] px-1.5 py-0.5 rounded border border-white/15 bg-game-card/40 text-gray-300 font-mono inline-flex items-center gap-1">
                {qualityIcon}
                {getQualityLabel(item.quality)}
              </span>
            </div>
          </div>
        </div>
        <div className="flex items-center gap-1 text-[10px] text-yellow-400 font-mono">
          <Coins size={10} /> {QUALITY_CONFIG[item.quality].price}
        </div>
      </div>

      <div className="grid grid-cols-2 gap-x-4 gap-y-1 py-2 border-y border-game-border/50">
        {Object.entries(item.attributes).map(([k, v]) => (
          <div key={k} className="flex justify-between text-[10px]">
            <span className="text-gray-500">{getStatLabel(k)}</span>
            <span className="text-gray-300 font-mono">+{v}</span>
          </div>
        ))}
      </div>

      {item.affixes.length > 0 && (
        <div className="flex flex-wrap gap-1">
          {item.affixes.map((affix) => (
            <span
              key={`${affix.type}-${affix.value}`}
              className="text-[10px] px-2 py-0.5 rounded border border-cyan-500/30 bg-cyan-500/10 text-cyan-300"
            >
              {affixLabelMap[affix.type] || affix.type} +{affix.value}
            </span>
          ))}
        </div>
      )}

      {item.special && <p className="text-[10px] text-red-400 italic leading-tight">鈽?{item.special}</p>}

      {!readonly && (
        <div className="flex gap-2 pt-1">
          <button onClick={onEquip} disabled={loading} className="flex-1 py-1.5 bg-red-900/20 hover:bg-red-800 text-red-400 hover:text-white text-[10px] font-bold rounded-lg transition-all border border-red-700/20 cursor-pointer hover:scale-105">{t('button.equip')}</button>
          <button onClick={onForge} disabled={loading} className="flex-1 py-1.5 bg-yellow-500/10 hover:bg-yellow-500 text-yellow-400 hover:text-white text-[10px] font-bold rounded-lg transition-all border border-yellow-500/20 cursor-pointer hover:scale-105" title={`Cost ${forgeCost} gold`}>{t('button.enchant')}</button>
          <button onClick={onSell} disabled={loading} className="px-3 py-1.5 bg-red-500/10 hover:bg-red-500 text-red-400 hover:text-white text-[10px] font-bold rounded-lg transition-all border border-red-500/20 cursor-pointer hover:scale-105"><Trash2 size={12} /></button>
        </div>
      )}
    </div>
  );
}


===================== [D:\download\LootingRPG\src\components\game\PlayerCard.tsx] =====================
import BattleUnitCardBase from './BattleUnitCardBase';
import type { BattleSession } from '../../shared/types/game';

const percent = (value: number, max: number) => {
  if (max <= 0) return 0;
  return Math.max(0, Math.min(100, (value / max) * 100));
};

interface PlayerCardProps {
  session: BattleSession;
}

export function PlayerCard({ session }: PlayerCardProps) {
  const hpRatio = percent(session.player.currentHp, session.player.baseStats.hp);

  return (
    <BattleUnitCardBase
      className="w-full p-0"
    >
      <div className="relative w-full h-full">
        {/* icon explicitly centered with transform */}
        <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-4xl leading-none">
          馃
        </div>
        {/* health bar flush to bottom */}
        <div className="absolute bottom-0 left-0 right-0 h-2 rounded bg-gray-800 overflow-hidden">
          <div className="h-full bg-emerald-500" style={{ width: `${hpRatio}%` }} />
        </div>
      </div>
    </BattleUnitCardBase>
  );
}

export default PlayerCard;


===================== [D:\download\LootingRPG\src\components\game\PlayerPanel.tsx] =====================
import { ArrowUpCircle, Shield, Sword, User, Star, Gem, Package, Flame, Droplets, ShieldAlert, Sparkles, Gauge, Coins } from 'lucide-react';
import { getSlotLabel, getQualityLabel, getStatLabel } from '../../infra/i18n/labels';
import { getDerivedStats } from '../../domains/player/services/derivedStats';
import { QUALITY_CONFIG, SLOT_CONFIG, SLOTS } from '../../config/game/equipment';
import type { Equipment, GameState } from '../../types/game';
import { useTranslation } from 'react-i18next';
import { useState, useMemo } from 'react';
import type { ReactNode } from 'react';
import { motion } from 'motion/react';

const slotTypeIconMap: Record<string, ReactNode> = {
  sword:   <Sword   size={14} className="text-amber-400" />,
  user:    <User    size={14} className="text-gray-300"  />,
  package: <Package size={14} className="text-gray-300"  />,
  star:    <Star    size={14} className="text-red-400"   />,
  gem:     <Gem     size={14} className="text-blue-400"  />,
  shield:  <Shield  size={14} className="text-gray-400"  />,
};

interface PlayerPanelProps {
  gameState: GameState;
  onUnequip: (slot: string) => void;
}

export function PlayerPanel({ gameState, onUnequip }: PlayerPanelProps) {
  const { t, i18n } = useTranslation();
  const [selectedSlot, setSelectedSlot] = useState<string | null>(null);
  
  const derivedStats = useMemo(() => {
    const base = getDerivedStats(gameState);
    // add icons to each entry here so the util stays UI-agnostic
    return base.map((stat) => {
      let icon: ReactNode = null;
      switch (stat.key) {
        case 'dmg':
          icon = <Flame size={12} className="text-orange-300" />;
          break;
        case 'ls':
          icon = <Droplets size={12} className="text-red-300" />;
          break;
        case 'thorns':
          icon = <ShieldAlert size={12} className="text-emerald-300" />;
          break;
        case 'element':
          icon = <Sparkles size={12} className="text-cyan-300" />;
          break;
        case 'spd':
          icon = <Gauge size={12} className="text-red-400" />;
          break;
      }
      return { ...stat, icon };
    });
  }, [gameState]);

  const selectedItem = selectedSlot 
    ? gameState.currentEquipment[selectedSlot as keyof typeof gameState.currentEquipment] as Equipment | null
    : null;

  const selectedLocaleName = selectedItem
    ? (i18n.language.startsWith('zh')
      ? (selectedItem.localeNames?.zh || selectedItem.name)
      : (selectedItem.localeNames?.en || selectedItem.name))
    : '';

  const qualityColor = useMemo(() => {
    return selectedItem
      ? QUALITY_CONFIG[selectedItem.quality]?.color || 'text-gray-400'
      : 'text-gray-400';
  }, [selectedItem]);

  const handleSlotClick = (slot: string) => {
    const item = gameState.currentEquipment[slot as keyof typeof gameState.currentEquipment];
    if (item) {
      setSelectedSlot(selectedSlot === slot ? null : slot);
    }
  };

  const handleUnequipClick = () => {
    if (selectedSlot) {
      onUnequip(selectedSlot);
      setSelectedSlot(null);
    }
  };

  return (
    <div className="lg:col-span-4 space-y-3">
      <motion.section
        initial={{ opacity: 0, x: -20 }}
        animate={{ opacity: 1, x: 0 }}
        transition={{ delay: 0.08 }}
        className="bg-gradient-to-br from-game-card to-game-card/80 border border-game-border/50 rounded-xl p-3 shadow-xl shadow-red-900/20 relative overflow-hidden"
      >
        <div className="absolute inset-0 bg-gradient-to-br from-cyan-500/5 via-transparent to-fuchsia-500/5" />
        <h3 className="text-[10px] font-bold text-gray-500 uppercase tracking-widest mb-2 flex items-center gap-1.5 relative z-10">
          <Sparkles size={12} className="text-cyan-300" /> {t('player.affixBonuses')}
        </h3>

        <div className="grid grid-cols-5 gap-1.5 relative z-10">
          {derivedStats.map((stat) => {
            const active = stat.rawValue > 0;
            return (
              <motion.div
                key={stat.key}
                whileHover={{ scale: 1.02 }}
                className={`rounded-lg border px-2 py-1.5 transition-all ${active ? stat.accent : 'border-white/10 bg-white/[0.03] text-gray-500'}`}
              >
                <div className="flex flex-col items-center gap-1">
                  <span className="flex items-center gap-1">
                    {stat.icon}
                  </span>
                  <span className={`font-mono text-[10px] font-bold ${active ? 'text-white' : 'text-gray-500'}`}>
                    {stat.value}
                  </span>
                </div>
              </motion.div>
            );
          })}
        </div>
      </motion.section>

      <motion.section 
        initial={{ opacity: 0, x: -20 }}
        animate={{ opacity: 1, x: 0 }}
        transition={{ delay: 0.1 }}
        className="bg-gradient-to-br from-game-card to-game-card/80 border border-game-border/50 rounded-xl p-3 shadow-xl shadow-red-900/20 relative overflow-hidden"
      >
        <div className="absolute inset-0 bg-gradient-to-br from-red-900/10 to-transparent" />
        
        <h3 className="text-[10px] font-bold text-gray-500 uppercase tracking-widest mb-2 flex items-center gap-1.5 relative z-10">
          <Shield size={12} className="text-red-400" /> {t('player.currentEquipment')}
        </h3>
        
        <div className="grid grid-cols-3 gap-2 relative z-10">
          {SLOTS.map((slot) => {
            const item = (gameState.currentEquipment as Record<string, Equipment | null>)[slot] || null;
            const qualityClass = item ? {
              common: 'border-quality-common',
              uncommon: 'equip-slot-uncommon',
              rare: 'equip-slot-rare',
              epic: 'equip-slot-epic',
              legendary: 'equip-slot-legendary',
              mythic: 'equip-slot-mythic',
            }[item.quality] || 'border-game-border' : '';

            return (
            <div 
              key={slot}
              onClick={() => handleSlotClick(slot)}
              className={`relative aspect-square rounded-lg border border-dashed flex flex-col items-center justify-center transition-all duration-200 cursor-pointer ${
                selectedSlot === slot 
                  ? 'ring-2 ring-red-700 ring-offset-2 ring-offset-game-bg' 
                  : item 
                    ? `bg-game-bg/60 border-solid ${qualityClass}` 
                    : 'border-game-border/40 hover:border-red-800/40 hover:bg-game-card'
              }`}
            >
              {item ? (
                <div className="flex flex-col items-center">
                  <span className="text-3xl leading-none">{item.icon || '馃О'}</span>
                  {item.enhancementLevel > 0 && (
                    <span className="absolute top-1 right-1 text-[8px] font-mono text-red-400 bg-red-950/50 px-1 rounded">
                      +{item.enhancementLevel}
                    </span>
                  )}
                  {item.quality === 'legendary' && (
                    <div className="absolute inset-0 rounded-lg legendary-shine pointer-events-none" />
                  )}
                  {item.quality === 'mythic' && (
                    <div className="absolute inset-0 rounded-lg mythic-glow pointer-events-none" />
                  )}
                </div>
              ) : (
                <span className="text-[9px] text-gray-600 uppercase font-mono flex flex-col items-center gap-1">
                  {slotTypeIconMap[SLOT_CONFIG[slot]?.icon || 'package']}
                  {getSlotLabel(slot)}
                </span>
              )}
            </div>
          );        
        })}
        </div>
      </motion.section>

      {selectedItem && (
        <motion.section 
          initial={{ opacity: 0, y: 10 }}
          animate={{ opacity: 1, y: 0 }}
          className={`bg-game-bg/95 backdrop-blur-sm border rounded-xl p-4 shadow-2xl ${selectedItem.quality === 'mythic' ? 'mythic-border' : selectedItem.quality === 'legendary' ? 'legendary-border' : 'border-game-border'}`}
        >
          <div className="flex items-center gap-3 mb-3">
            <div className="p-2 rounded-lg bg-game-card/60 text-3xl leading-none">{selectedItem.icon || '馃О'}</div>
            <div>
              <h4 className={`font-bold text-sm ${qualityColor}`}>
                {selectedLocaleName} {selectedItem.enhancementLevel > 0 ? `+${selectedItem.enhancementLevel}` : ''}
              </h4>
              <div className="flex items-center gap-2 mt-1">
                <span className="text-[10px] text-gray-500 uppercase font-mono">Lv.{selectedItem.level} 鈥?{selectedItem.slot}</span>
              </div>
              <span className="text-[10px] px-1.5 py-0.5 rounded border border-white/15 bg-game-card/40 text-gray-300 font-mono mt-1 inline-block">
                {getQualityLabel(selectedItem.quality)}
              </span>
            </div>
            <div className="flex items-center gap-1 text-[10px] text-yellow-400 font-mono ml-auto">
              <Coins size={10} /> {QUALITY_CONFIG[selectedItem.quality].price}
            </div>
          </div>

          <div className="grid grid-cols-2 gap-x-4 gap-y-1 py-2 border-y border-game-border/50">
            {Object.entries(selectedItem.attributes).map(([k, v]) => (
              <div key={k} className="flex justify-between text-[10px]">
                <span className="text-gray-500">{getStatLabel(k)}</span>
                <span className="text-gray-300 font-mono">+{v}</span>
              </div>
            ))}
          </div>

          {selectedItem.affixes.length > 0 && (
            <div className="flex flex-wrap gap-1 mt-2">
              {(() => {
                const labelMap: Record<string, string> = {
                  crit_chance: t('stat.crit'),
                  lifesteal: t('stat.lifesteal'),
                  damage_bonus: t('stat.damage'),
                  thorns: t('trait.thorns'),
                  hp_bonus: t('stat.hp'),
                };
                return selectedItem.affixes.map((affix) => (
                  <span
                    key={`${affix.type}-${affix.value}`}
                    className="text-[9px] px-2 py-0.5 rounded border border-cyan-500/30 bg-cyan-500/10 text-cyan-300"
                  >
                    {labelMap[affix.type] || getStatLabel(affix.type)} +{affix.value}
                  </span>
                ));
              })()}
            </div>
          )}

          {selectedItem.special && (
            <p className="text-[10px] text-red-400 italic leading-tight mt-2">鈽?{selectedItem.special}</p>
          )}

          <div className="mt-3 pt-2 border-t border-game-border/50">
            <button 
              onClick={handleUnequipClick}
              className="w-full py-2 bg-red-900/30 hover:bg-red-800 text-red-300 hover:text-white text-xs font-bold rounded-lg transition-colors border border-red-700/30 cursor-pointer flex items-center justify-center gap-2"
            >
              <ArrowUpCircle size={14} />
              鍗镐笅瑁呭
            </button>
          </div>
        </motion.section>
      )}
    </div>
  );
}


===================== [D:\download\LootingRPG\src\components\ui\TabButton.tsx] =====================
import React from 'react';

interface TabButtonProps {
  active: boolean;
  onClick: () => void;
  label: string;
}

export const TabButton = React.memo(function TabButton({ active, onClick, label }: TabButtonProps) {
  return (
    <button
      onClick={onClick}
      className={`px-6 py-3 text-xs font-bold uppercase tracking-widest transition-all duration-200 border-b-2 cursor-pointer ${active ? 'text-red-400 border-red-500 bg-red-900/10' : 'text-gray-500 border-transparent hover:text-gray-300 hover:bg-gray-500/5'}`}
    >
      {label}
    </button>
  );
});


===================== [D:\download\LootingRPG\src\config\game\equipment.ts] =====================
// 鏈ā鍧楀悎骞朵簡鍘熸潵鐨勪袱涓厤缃枃浠讹細
// - `data/config/game/equipment.json`锛氬寘鍚澶囩浉鍏崇殑闈欐€侀厤缃暟鎹紝濡傚睘鎬ф睜銆佸搧璐ㄩ厤缃€佹Ы浣嶄俊鎭瓑銆?// - `data/config/game/equipments.csv`锛氬寘鍚澶囨ā鏉挎暟鎹紝鐢ㄤ簬浠?CSV 瀵煎叆鑷畾涔夎澶囥€侰SV 瑙ｆ瀽宸ュ叿涔熷湪姝ゆā鍧椾腑瀹炵幇骞跺鍑恒€?// 鎵€鏈夊鍑哄唴瀹瑰寘鎷熀纭€閰嶇疆甯搁噺銆侀厤鑹层€佷环鏍间俊鎭?// 浠ュ強涓轰簡璋冭瘯/鍔犺浇鑷畾涔夎澶囪€屼娇鐢ㄧ殑 CSV 瑙ｆ瀽宸ュ叿銆?
import equipment from '@data/config/game/equipment.json';
import csvRaw from '@data/config/game/equipments.csv?raw';

type QualityConfigItem = { stats: number; price: number; color: string; iconName: string };
type SlotItem = { id: string; name: string; icon: string };
type EnchantConfig = {
  enchantBaseCost?: number;
  rerollBaseCost?: number;
  lockCost?: number;
  enchantScaleByQuality?: number[];
  enchantCostMultiplierByQuality?: number[];
};
type EquipDataSchema = {
  statPool: string[];
  qualities: string[];
  slots: SlotItem[];
  qualityConfig: Record<string, QualityConfigItem>;
  affixCountByQuality: number[];
  baseMultiplierByQuality: number[];
  affixScaling: Record<string, number[]>;
  enchantConfig?: EnchantConfig;
};

// 浠?JSON 鏂囦欢涓姞杞借澶囬潤鎬侀厤缃暟鎹?const EquipData = equipment as unknown as EquipDataSchema;

// 鍙敤灞炴€ф睜锛堣瘝鏉＄被鍨嬶級
export const STAT_POOL: string[] = EquipData.statPool;
// 瑁呭鍝佽川鍒楄〃
export const QUALITIES: string[] = EquipData.qualities;
// 瑁呭妲戒綅 id 鏁扮粍
export const SLOTS: string[]     = EquipData.slots.map(s => s.id);
// 妲戒綅璇︾粏閰嶇疆锛屼究浜庨€氳繃 id 鏌ユ壘鍚嶇О鍜屽浘鏍?export const SLOT_CONFIG: Record<string, SlotItem> = EquipData.slots.reduce<Record<string, SlotItem>>((acc, s) => {
  acc[s.id] = s;
  return acc;
}, {});
// 鍝佽川閰嶇疆锛屽寘鍚熀纭€灞炴€у姞鎴愩€佷环鏍笺€侀鑹层€佸浘鏍囩瓑
export const QUALITY_CONFIG: Record<string, QualityConfigItem> = EquipData.qualityConfig as Record<string, QualityConfigItem>;
export const getQualityColor = (quality: string): string => {return QUALITY_CONFIG[quality]?.color};
// 姣忎釜鍝佽川鍙嫢鏈夌殑璇嶆潯鏁般€佸熀纭€鍊嶇巼
export const AFFIX_COUNT_BY_QUALITY: number[]     = EquipData.affixCountByQuality;
export const BASE_MULTIPLIER_BY_QUALITY: number[] = EquipData.baseMultiplierByQuality;
// 闄勯瓟鐩稿叧閰嶇疆
export const ENCHANT_CONFIG: EnchantConfig = EquipData.enchantConfig ?? {};
/// 浠锋牸鐩稿叧
export const ENCHANT_BASE_COST: number = ENCHANT_CONFIG?.enchantBaseCost ?? 500;
export const REROLL_BASE_COST: number  = ENCHANT_CONFIG?.rerollBaseCost ?? 300;
export const LOCK_COST: number         = ENCHANT_CONFIG?.lockCost ?? 200;
/// 姣旂巼
export const AFFIX_SCALING: Record<string, number[]> = EquipData.affixScaling;
export const ENCHANT_SCALE_BY_QUALITY: number[] = ENCHANT_CONFIG?.enchantScaleByQuality ?? [0.05, 0.06, 0.07, 0.08, 0.10, 0.12];
export const ENCHANT_COST_MULTIPLIER_BY_QUALITY: number[] = ENCHANT_CONFIG?.enchantCostMultiplierByQuality ?? [1,1,1.05,1.1,1.25,1.5];


// 浠ヤ笅涓哄師鏉ョ殑 `src/config/content/equipments.ts` 鍐呭锛?// 宸蹭笌鏈枃浠跺悎骞讹紝姝ゆ枃浠剁幇鍦ㄨ礋璐ｈ澶囬潤鎬侀厤缃互鍙?// 浠?CSV 瀵煎叆瑁呭妯℃澘鐨勫姛鑳姐€?// 鍘熸枃浠惰寮冪敤锛岀浉鍏冲紩鐢ㄥ凡杩佺Щ鍒版湰妯″潡銆?
/**
 * 瑁呭妯℃澘鎺ュ彛锛屾弿杩?CSV 涓瘡涓€琛岀殑缁撴瀯銆? * 鍖呭惈鍩虹妲戒綅銆佸搧璐ㄣ€佸浘鏍囥€佸悕绉般€佸睘鎬с€佽瘝鏉′互鍙? * 绛夌骇缂╂斁绛夌敓鎴愯澶囨墍闇€鐨勪俊鎭€? */
export interface EquipmentTemplate {
  id: string;
  slot: string;
  quality: string;
  icon: string;
  nameZh: string;
  nameEn: string;
  specialZh?: string;
  specialEn?: string;
  attributes: Record<string, number>;
  affixes: Array<{ type: string; value: number }>;
  levelOffset: number;
  scalePerLevel: number;
}

// 浠ヤ笅鏄?CSV 瑙ｆ瀽宸ュ叿鍑芥暟锛岀敤浜庡皢瀛楃涓茶浆鎹负 JSON 瀵硅薄鎴栬瘝鏉℃暟缁勩€?const parseJsonObject = (value: string): Record<string, number> => {
  if (!value.trim()) return {};
  const parsed = JSON.parse(value);
  if (!parsed || typeof parsed !== 'object' || Array.isArray(parsed)) return {};
  const result: Record<string, number> = {};
  Object.entries(parsed as Record<string, unknown>).forEach(([key, raw]) => {
    const numberValue = Number(raw);
    if (Number.isFinite(numberValue)) {
      result[key] = numberValue;
    }
  });
  return result;
};
const parseAffixes = (value: string): Array<{ type: string; value: number }> => {
  if (!value.trim()) return [];
  try {
    const parsed = JSON.parse(value);
    if (!Array.isArray(parsed)) return [];

    const isAffixEntry = (entry: unknown): entry is { type?: unknown; value?: unknown } => {
      return typeof entry === 'object' && entry !== null;
    };

    return parsed
      .map((entry) => {
        if (!isAffixEntry(entry)) {
          return { type: '', value: NaN };
        }
        return {
          type: String(entry.type ?? '').trim(),
          value: Number(entry.value ?? 0),
        };
      })
      .filter((entry) => entry.type.length > 0 && Number.isFinite(entry.value));
  } catch {
    return [];
  }
};

// CSV 琛岃В鏋愬櫒锛屾敮鎸佸甫鍙屽紩鍙风殑鍗曞厓鏍煎拰杞箟銆?const parseCsvLine = (line: string): string[] => {
  const cells: string[] = [];
  let current = '';
  let inQuotes = false;

  for (let index = 0; index < line.length; index++) {
    const ch = line[index];
    const next = line[index + 1];

    if (ch === '"') {
      if (inQuotes && next === '"') {
        current += '"';
        index += 1;
      } else {
        inQuotes = !inQuotes;
      }
      continue;
    }

    if (ch === ',' && !inQuotes) {
      cells.push(current.trim());
      current = '';
      continue;
    }

    current += ch;
  }

  cells.push(current.trim());
  return cells;
};

let cachedTemplates: EquipmentTemplate[] | null = null;

/**
 * 浠?embedded CSV 鏂囨湰涓鍙栬澶囨ā鏉垮苟缂撳瓨銆? * csvRaw 鐢?Vite 鐨?`?raw` 瀵煎叆鎻愪緵銆? */
export const getEquipmentTemplates = (): EquipmentTemplate[] => {
  if (cachedTemplates) {
    return cachedTemplates;
  }

  // 浣跨敤鏂囦欢椤堕儴瀵煎叆鐨勫師濮?CSV 鏂囨湰
  //锛圴ite 鐨?`?raw` 淇濊瘉涓哄瓧绗︿覆锛夈€?  //const csvRaw: string = require('./content/equipments.csv?raw');

  const lines = csvRaw
    .split(/\r?\n/)
    .map((line) => line.trim())
    .filter((line) => line.length > 0 && !line.startsWith('#'));

  if (lines.length <= 1) {
    cachedTemplates = [];
    return [];
  }

  const header = parseCsvLine(lines[0]);

  const templates = lines.slice(1).map((line: string, rowIndex: number) => {
    const values = parseCsvLine(line);
    const row: Record<string, string> = {};
    header.forEach((key, index) => {
      row[key] = values[index] ?? '';
    });

    const id = row.id?.trim() || `csv_item_${rowIndex + 1}`;
    return {
      id,
      slot:    row.slot?.trim()    || 'Error',
      quality: row.quality?.trim() || 'Error',
      icon:    row.icon?.trim()    || 'Error',
      nameZh:  row.name_zh?.trim() || row.name_en?.trim() || `瑁呭${id}`,
      nameEn:  row.name_en?.trim() || row.name_zh?.trim() || `瑁呭${id}`,
      specialZh: row.special_zh?.trim() || row.special_en?.trim() || `Error Special`,
      specialEn: row.special_en?.trim() || row.special_zh?.trim() || `Error Special`,
      attributes: parseJsonObject(row.attributes || ''),
      affixes:    parseAffixes(row.affixes || ''),
      levelOffset: Math.floor(Number(row.levelOffset) || 0),
      scalePerLevel:  Number(row.scalePerLevel) || 0,
    } satisfies EquipmentTemplate;
  });

  cachedTemplates = templates;
  return templates;
};


===================== [D:\download\LootingRPG\src\config\game\gameConfig.ts] =====================
import type { GameState, PlayerStats, Equipment } from '../../shared/types/game';
import { PLAYER_GROWTH } from './progression';
/**
 * 娓告垙鍏ㄥ眬閰嶇疆瀵硅薄
 * - INITIAL_STATE: 鍏ㄩ儴娓告垙鐘舵€佺殑鍒濆蹇収
 *   鐢ㄤ簬鏂板瓨妗ｅ垱寤恒€侀噸缃互鍙婂湪璁＄畻涓綔涓哄熀鍑嗗€笺€? *   鍏朵粬妯″潡渚嬪 "playerStats.ts" 浼氬紩鐢ㄦ瀵硅薄鑾峰彇鍩虹鏁板€笺€? */
const basePlayerStats: PlayerStats = {
  level: 1, xp: 0, attack: PLAYER_GROWTH.baseAttack,
  hp: PLAYER_GROWTH.baseHp,
  defense: PLAYER_GROWTH.baseDefense,
  critRate: `${PLAYER_GROWTH.baseCritRate}`, // 鐧惧垎鏁板瓧绗︿覆褰㈠紡
  damageBonus: 0, lifesteal: 0,
  thorns: 0, elemental: 0, attackSpeed: 0, gold: 0,
};

import { SLOTS } from './equipment';

export const INITIAL_STATE: GameState = {
  playerStats: basePlayerStats,
  droppedEquipment: null,
  backpack: [] as Equipment[],
  systemMessage: '',
  currentEquipment: Object.fromEntries(SLOTS.map((s) => [s, null])) as Record<string, Equipment | null>,
  pityCounts: {
    legendary: 0,
    mythic: 0,
  },
  battle: {
    activeSession: null,
    history: [],
  },
};

// 鍚庣画鍙互鍦ㄦ娣诲姞鍏朵粬涓庢父鎴忔牳蹇冩湁鍏崇殑闈欐€侀厤缃」锛屼緥濡傛帀钀界巼銆佺粡楠岃〃绛夈€


===================== [D:\download\LootingRPG\src\config\game\monsterSchema.ts] =====================
import monsterConfig from '@data/config/game/monsterConfig.json';
export type MonsterTrait          = typeof monsterConfig.traits[number];
export type ThreatType            = typeof monsterConfig.threatTypes[number];
export type MonsterType           = typeof monsterConfig.monsterTypes[number];
export type MonsterScalingProfile = keyof typeof monsterConfig.scalingProfileStats;
export type ScalingProfileStats = { [key in MonsterScalingProfile]: EntityStats };
export type StrategyTag           = typeof monsterConfig.strategy.tag[number];
export type CounterStatKey        = typeof monsterConfig.strategy.counterGoalScoreMap[keyof typeof monsterConfig.strategy.counterGoalScoreMap];
export const SCALING_PROFILES: ScalingProfileStats =
  (monsterConfig as any).scalingProfileStats as ScalingProfileStats;
export interface RawMonsterBaseStats { hp?: number; attack?: number; defense?: number}
// 鍩虹鐢熷懡/鏀诲嚮/闃插尽涓夊洿锛屽彲渚涚帺瀹跺拰鎬墿缁熶竴浣跨敤
export interface EntityStats { hp: number; attack: number; defense: number; }
export interface RawBossCounterGoal {
  title?: string; titleKey?: string;
  stat?: string; threshold?: number;
  successText?: string; successTextKey?: string;
  failText?: string; failTextKey?: string
}
export interface RawMonsterData {
  id?: string;
  icon?: string;
  monsterType?: MonsterType;
  baseStats?: RawMonsterBaseStats;
  scalingProfile?: string;
  skillSet?: string[];
  traits?: MonsterTrait[];
  uniqueTraits?: MonsterTrait[];
  threatTypes?: string[];
  background?: string;
  dropdict?: Record<string, number>;
}
export interface RawBossData extends RawMonsterData {
  bossIdentity?: {
    theme?: string;
    introLine?: string;
    introLineKey?: string;
    battleLogLine?: string;
    battleLogLineKey?: string;
    phasePrompts?: Record<string, string>;
  };
  counterGoal?: RawBossCounterGoal;
  counterGoalLabel?: string;
}
export type MonsterBaseStats = EntityStats;
export interface BossIdentity {
  theme: string;
  introLine: string;
  battleLogLine: string;
  phasePrompts?: Partial<Record<'entering' | 'fighting' | 'dying' | 'dropping', string>>;
}
export interface BossCounterGoal {
  title: string;
  stat: CounterStatKey;
  threshold: number;
  successText: string;
  failText: string;
}
//璇嶆潯璇勫垎鏄犲皠琛?export const traitScoreMap: Record<MonsterTrait, Partial<Record<StrategyTag, number>>> = monsterConfig.strategy.traitScoreMap;
//**瀵规姉鐩爣璁″垎琛?export const counterGoalScoreMap: Record<string, StrategyTag> = monsterConfig.strategy.counterGoalScoreMap;
export interface Monster {
  id:    string;     // 鍞竴鏍囪瘑绗?  name:  string;     // 鏄剧ず鍚嶇О
  icons: string[];   // 鍥炬爣鍒楄〃锛岃嚦灏戜竴涓?  level: number;     // 鎬墿绛夌骇锛屽奖鍝嶅睘鎬у拰鎺夎惤
  monsterType:    MonsterType;          /// 鎬墿绫诲瀷
  baseStats:      MonsterBaseStats;     /// 鍩虹灞炴€э紝鍖呭惈hp銆乤ttack鍜宒efense
  scalingProfile: MonsterScalingProfile;/// 灞炴€ф垚闀跨被鍨嬶紝褰卞搷灞炴€ч殢绛夌骇鐨勫闀挎柟寮?  skillSet?: string[];   /// 
  maxHp: number;  /// 
  attack: number; /// 
  defense: number;/// 
  traits?: MonsterTrait[];/// 
  threatTypes?: ThreatType[];
  /// 鎬墿鑳屾櫙鏁呬簨鏂囨湰锛屼粎鐢ㄤ簬UI鏄剧ず锛屼笉褰卞搷娓告垙閫昏緫
  background?: string;  
  bossIdentity?: BossIdentity;  ///> 浠匓oss鎬墿鎷ユ湁鐨勮韩浠戒俊鎭紝鍖呮嫭涓婚銆佷粙缁嶈鍜屾垬鏂楁棩蹇楄
  counterGoal?:  BossCounterGoal;
  ///> 鎬墿鐗瑰畾鐨勮鏁扮洰鏍囪揪鎴愮姸鎬侊紝浠呯敤浜嶶I鏄剧ず锛屽疄闄呴€昏緫浠嶄互鐜╁stats涓哄噯
  counterGoalLabel?: string;
  ///> 鎬墿鐗瑰畾鐨勮鏁扮洰鏍囪揪鎴愮姸鎬侊紝浠呯敤浜嶶I鏄剧ず锛屽疄闄呴€昏緫浠嶄互鐜╁stats涓哄噯
  counterGoalPassed?: boolean;
  ///> 鎬墿鐗瑰畾鐨勬帀钀藉瓧鍏革紝鏍煎紡涓?{ [equipmentTemplateId]: chance }锛岀敤浜庤鐩栭粯璁ゆ帀钀介€昏緫
  dropdict?: Record<string, number>;
}


===================== [D:\download\LootingRPG\src\config\game\progression.ts] =====================
export const PLAYER_GROWTH = {
  baseAttack: 50,
  attackPerLevel: 5,
  baseHp: 300,
  hpPerLevel: 20,
  baseDefense: 5,
  defensePerLevel: 2,
  baseCritRate: 5,
  xpPerLevel: 100,
};


===================== [D:\download\LootingRPG\src\config\map\ChapterData.ts] =====================
/**
 * @deprecated 杩佺Щ杩囨浮灞傦細璇蜂紭鍏堜粠 `src/domains/map/model/chapters.ts` 寮曠敤銆? */
export type {
  NodeWave,
  MapNodeDef,
  MapChapterDef,
} from '../../domains/map/model/chapters';

/**
 * @deprecated 杩佺Щ杩囨浮灞傦細璇蜂紭鍏堜粠 `src/domains/map/model/chapters.ts` 寮曠敤銆? */
export { MAP_CHAPTERS } from '../../domains/map/model/chapters';


===================== [D:\download\LootingRPG\src\config\map\mapNode.ts] =====================
import nodeUiConfig from '@data/config/map/mapNode.json';
export type ChapterTheme = typeof nodeUiConfig.chapterNodeStyles extends Record<infer K, unknown> ? K : never;
export interface NodeEncounterStyle {
  shape: string; size: string; iconColor: string; ringColor: string;
  glowColor: string; particleColor: string; bgGradient: string; borderStyle: string;
}
export type MapEncounterType = typeof nodeUiConfig.encounterTypes[number];
export interface ThemeColors { primary: string; primaryLight: string; primaryDark: string;}
export const themeColors: Record<ChapterTheme, ThemeColors> = nodeUiConfig.THEME_COLORS;
export const defaultEncounterStyles: Record<MapEncounterType, NodeEncounterStyle> = nodeUiConfig.defaultEncounterStyles;
export const chapterNodeStyles: Record<ChapterTheme, Record<MapEncounterType, NodeEncounterStyle>> = nodeUiConfig.chapterNodeStyles;
export const MAP_NODE_CONFIG = nodeUiConfig.MAP_NODE_CONFIG as {
  bossIconSize: number;
  normalIconSize: number;
  starCount: Record<MapEncounterType, number>;
  floatDelayBase: number;
  floatDelayIncrement: number;
  animationDuration: { float: number; hover: number; glow: number; particle: number };
  hoverScale: number;
  hoverY: number;
  tapScale: number;
};

export const HEADER_CONFIG = {
  titleSize: 'text-base',
  subtitleSize: 'text-[10px]',
  infoBadgePadding: 'px-2 py-1',
  progressBarHeight: 4,
};

export const themeHeaderColors: Record<ChapterTheme, { primary: string; secondary: string; glow: string; border: string; text: string }> = nodeUiConfig.THEME_HEADER_COLORS;


===================== [D:\download\LootingRPG\src\config\runtime\storage.ts] =====================
export const STORAGE_KEY = 'ai_rpg_save_local';
export const PROFILE_INDEX_KEY = 'ai_rpg_profiles';
export const ACTIVE_PROFILE_KEY = 'ai_rpg_active_profile';


===================== [D:\download\LootingRPG\src\config\themes\ThemeContext.tsx] =====================
import { createContext, useContext, useState, useEffect, useCallback, type ReactNode } from 'react';
import type { Theme, ThemeContextValue } from './types';
import DarkScareTheme from '@data/config/themes/DarkScare.json';
import ArcaneMysticTheme from '@data/config/themes/ArcaneMystic.json';

const themes: Theme[] = [DarkScareTheme, ArcaneMysticTheme];

const STORAGE_KEY = 'game-theme';

const ThemeContext = createContext<ThemeContextValue | null>(null);

function getStoredTheme(): string {
  try {
    return localStorage.getItem(STORAGE_KEY) || 'dark-scare';
  } catch {
    return 'dark-scare';
  }
}

export function ThemeProvider({ children }: { children: ReactNode }) {
  const [currentThemeId, setCurrentThemeId] = useState<string>(getStoredTheme);
  const [theme, setTheme] = useState<Theme>(() => {
    return themes.find(t => t.id === currentThemeId) || themes[0];
  });

  const setThemeById = useCallback((themeId: string) => {
    const found = themes.find(t => t.id === themeId);
    if (found) {
      setCurrentThemeId(themeId);
      setTheme(found);
        localStorage.setItem(STORAGE_KEY, themeId);
    }
  }, []);

  useEffect(() => {
    const root = document.documentElement;
    root.style.setProperty('--color-game-bg', theme.colors.gameBg);
    root.style.setProperty('--color-game-card', theme.colors.gameCard);
    root.style.setProperty('--color-game-border', theme.colors.gameBorder);
    root.style.setProperty('--color-game-accent', theme.colors.gameAccent);
    root.style.setProperty('--color-game-cta', theme.colors.gameCta);
    root.style.setProperty('--color-quality-common', theme.colors.quality.common);
    root.style.setProperty('--color-quality-uncommon', theme.colors.quality.uncommon);
    root.style.setProperty('--color-quality-rare', theme.colors.quality.rare);
    root.style.setProperty('--color-quality-epic', theme.colors.quality.epic);
    root.style.setProperty('--color-quality-legendary', theme.colors.quality.legendary);
    root.style.setProperty('--color-quality-mythic', theme.colors.quality.mythic);
  }, [theme]);

  return (
    <ThemeContext.Provider value={{ theme, setTheme: setThemeById, themes }}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme(): ThemeContextValue {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
}


===================== [D:\download\LootingRPG\src\config\themes\types.ts] =====================
export interface ThemeColors {
  gameBg: string;
  gameCard: string;
  gameBorder: string;
  gameAccent: string;
  gameCta: string;
  quality: {
    common: string;
    uncommon: string;
    rare: string;
    epic: string;
    legendary: string;
    mythic: string;
  };
}

export interface ThemeGradients {
  body: string;
}

export interface Theme {
  id: string;
  name: string;
  description: string;
  colors: ThemeColors;
  gradients: ThemeGradients;
}

export interface ThemeContextValue {
  theme: Theme;
  setTheme: (themeId: string) => void;
  themes: Theme[];
}


===================== [D:\download\LootingRPG\src\config\ui\tokens.ts] =====================
export const UI_DIMENSIONS = {
  monsterIconSize: 22,
  codexIconSize: 32,
  nodeIconSize: 14,
  waveBadgeWidth: 40,
  waveBadgeHeight: 16,
  progressBarWidth: 20,
  progressBarHeight: 2,
};

export const UI_STYLES = {
  nodeWaveLabel: 'text-[8px] px-1 rounded-bl bg-black/60',
};


===================== [D:\download\LootingRPG\src\domains\battle\engine\ActionResolver.ts] =====================
import type { BattleAction, BattleSession } from '../../../shared/types/game';
import type { BattleUnitInstance } from '../../../types/battle/BattleUnit';
import { resolveDamage } from './DamagePipeline';
import type { BattleEventBus } from './EventBus';
const isApplyDamageEvent = (
  event: BattleSession['events'][number],
): event is Extract<BattleSession['events'][number], { type: 'apply_damage' }> => event.type === 'apply_damage';

const getUnitById = (session: BattleSession, unitId: string): BattleUnitInstance | undefined => {
  if (session.player.id === unitId) {
    return session.player;
  }
  return session.enemies.find((enemy) => enemy.id === unitId);
};

export const resolveAction = (
  session: BattleSession,
  action: BattleAction,
  eventBus: BattleEventBus,
): BattleSession => {
  const source = getUnitById(session, action.sourceId);
  if (!source || source.currentHp <= 0) {
    return session;
  }

  if (action.type !== 'basic_attack') {
    return session;
  }

  for (const targetId of action.targetIds) {
    const target = getUnitById(session, targetId);
    if (!target || target.currentHp <= 0) {
      continue;
    }

    const eventCountBefore = eventBus.getEvents().length;
    resolveDamage(
      {
        source,
        target,
        baseDamage: 0,
        critMultiplier: 1,
        modifiers: [],
      },
      eventBus,
    );

    const latestEvents = eventBus.getEvents().slice(eventCountBefore);
    const dealt = latestEvents
      .filter(isApplyDamageEvent)
      .filter((event) => event.sourceId === source.id && event.targetId === target.id)
      .reduce((total, event) => total + event.amount, 0);
    session.logs.push(`[Battle] Turn ${session.turn}: ${source.name} dealt ${dealt} to ${target.name}.`);
  }

  return session;
};


===================== [D:\download\LootingRPG\src\domains\battle\engine\BattleEngine.ts] =====================
import type { BattleSession } from '../../../shared/types/game';
import { BattleEventBus } from './EventBus';
import { resolveTurn } from './TurnManager';

export class BattleEngine {
  static resolveTurn(session: BattleSession): BattleSession {
    const eventBus = new BattleEventBus();
    return resolveTurn(session, eventBus);
  }
}


===================== [D:\download\LootingRPG\src\domains\battle\engine\DamagePipeline.ts] =====================
import { clamp, computeCritMultiplier, computeDamage, computeEffectiveDefense, computeEffectiveLifesteal } from '../battleMaths';
import type { BattleUnitInstance } from '../../../types/battle/BattleUnit';
import type { BattleEventBus } from './EventBus';

export interface DamageModifier {
  type: string;
  apply: (ctx: DamageContext) => void;
}

export interface DamageContext {
  source: BattleUnitInstance;
  target: BattleUnitInstance;
  baseDamage: number;
  critMultiplier: number;
  modifiers: DamageModifier[];
}

export const resolveDamage = (ctx: DamageContext, eventBus: BattleEventBus): void => {
  const didCrit = Math.random() < (ctx.source.derivedStats.critRate ?? 0);
  ctx.critMultiplier = computeCritMultiplier(didCrit, 0.6);

  const effectiveDefense = computeEffectiveDefense(
    ctx.target.baseStats.defense,
    ctx.source.derivedStats.elementalBonus ?? 0,
  );

  ctx.baseDamage = computeDamage(
    ctx.source.baseStats.attack,
    effectiveDefense,
    ctx.critMultiplier,
  );

  for (const modifier of ctx.modifiers) {
    modifier.apply(ctx);
  }

  const appliedDamage = Math.max(1, Math.floor(ctx.baseDamage));

  eventBus.emit({
    type: 'apply_damage',
    sourceId: ctx.source.id,
    targetId: ctx.target.id,
    amount: appliedDamage,
  });

  const effectiveLifesteal = computeEffectiveLifesteal(ctx.source.derivedStats.lifestealRate ?? 0);
  if (effectiveLifesteal > 0) {
    const heal = Math.floor(appliedDamage * effectiveLifesteal);
    if (heal > 0) {
      eventBus.emit({
        type: 'apply_heal',
        sourceId: ctx.source.id,
        targetId: ctx.source.id,
        amount: heal,
      });
    }
  }

  const thornsRate = clamp(ctx.target.derivedStats.thornsRate ?? 0, 0, 0.4);
  if (thornsRate > 0) {
    const reflectDamage = Math.floor(appliedDamage * thornsRate);
    if (reflectDamage > 0) {
      eventBus.emit({
        type: 'apply_damage',
        sourceId: ctx.target.id,
        targetId: ctx.source.id,
        amount: reflectDamage,
      });
    }
  }
};


===================== [D:\download\LootingRPG\src\domains\battle\engine\EffectResolver.ts] =====================
import type {
  ApplyDamageEvent,
  ApplyHealEvent,
  BattleEvent,
  BattleSession,
  UnitDiedEvent,
} from '../../../shared/types/game';
import type { BattleUnitInstance } from '../../../types/battle/BattleUnit';

const findUnit = (session: BattleSession, unitId: string): BattleUnitInstance | undefined => {
  if (session.player.id === unitId) {
    return session.player;
  }
  return session.enemies.find((enemy) => enemy.id === unitId);
};

function handleApplyDamage(
  session: BattleSession,
  event: ApplyDamageEvent,
): UnitDiedEvent | undefined {
  const target = findUnit(session, event.targetId);
  if (!target) {
    return;
  }

  target.currentHp -= event.amount;

  if (target.currentHp <= 0) {
    target.currentHp = 0;
    return {
      type: 'unit_died',
      unitId: target.id,
    };
  }

  return;
}

function handleApplyHeal(session: BattleSession, event: ApplyHealEvent): void {
  const target = findUnit(session, event.targetId);
  if (!target) {
    return;
  }

  const maxHp = target.baseStats.hp;
  target.currentHp = Math.min(maxHp, target.currentHp + event.amount);
}

function handleUnitDied(session: BattleSession, event: UnitDiedEvent): void {
  const unit = findUnit(session, event.unitId);
  if (!unit) {
    return;
  }

  unit.currentHp = 0;
  session.logs.push(`[Battle] ${unit.name} defeated.`);
}

export function resolveEffects(
  session: BattleSession,
  events: BattleEvent[],
): BattleSession {
  const pendingEvents: BattleEvent[] = [...events];

  while (pendingEvents.length > 0) {
    const event = pendingEvents.shift();
    if (!event) {
      break;
    }

    session.events.push(event);

    switch (event.type) {
      case 'apply_damage': {
        const deathEvent = handleApplyDamage(session, event);
        if (deathEvent) {
          pendingEvents.push(deathEvent);
        }
        break;
      }
      case 'apply_heal':
        handleApplyHeal(session, event);
        break;
      case 'unit_died':
        handleUnitDied(session, event);
        break;
      default:
        break;
    }
  }

  return session;
}


===================== [D:\download\LootingRPG\src\domains\battle\engine\EventBus.ts] =====================
import type { BattleEvent } from '../../../shared/types/game';

export class BattleEventBus {
  private readonly events: BattleEvent[] = [];

  emit(event: BattleEvent): void {
    this.events.push(event);
  }

  getEvents(): BattleEvent[] {
    return [...this.events];
  }

  drainEvents(): BattleEvent[] {
    const snapshot = [...this.events];
    this.events.length = 0;
    return snapshot;
  }
}


===================== [D:\download\LootingRPG\src\domains\battle\engine\TurnManager.ts] =====================
import type { BattleAction, BattleSession } from '../../../shared/types/game';
import type { BattleUnitInstance } from '../../../types/battle/BattleUnit';
import type { BattleEventBus } from './EventBus';
import { resolveAction } from './ActionResolver';
import { resolveEffects } from './EffectResolver';

const cloneBattleUnit = (unit: BattleUnitInstance): BattleUnitInstance => ({
  ...unit,
  baseStats: { ...unit.baseStats },
  derivedStats: { ...unit.derivedStats },
  skills: [...unit.skills],
  passives: [...unit.passives],
  elements: [...unit.elements],
  tags: [...unit.tags],
  meta: unit.meta ? { ...unit.meta } : undefined,
});

const cloneSession = (session: BattleSession): BattleSession => ({
  ...session,
  player: cloneBattleUnit(session.player),
  enemies: session.enemies.map((enemy) => cloneBattleUnit(enemy)),
  logs: [...session.logs],
  events: [],
});

const getWaveId = (unit: BattleUnitInstance, fallback: string): string => {
  const value = unit.meta?.waveId;
  return typeof value === 'string' ? value : fallback;
};

const isAlive = (unit: BattleUnitInstance): boolean => unit.currentHp > 0;

const getCurrentWaveAliveEnemies = (session: BattleSession): BattleUnitInstance[] => {
  const currentWaveId = session.waveOrder[session.currentWaveIndex];
  if (!currentWaveId) {
    return [];
  }
  return session.enemies.filter((enemy, index) => getWaveId(enemy, `wave-${index + 1}`) === currentWaveId && isAlive(enemy));
};

const updateBattleOutcome = (session: BattleSession): void => {
  const playerAlive = isAlive(session.player);
  const enemyAlive = session.enemies.some(isAlive);

  if (!playerAlive) {
    session.status = 'defeat';
    session.phase = 'finished';
    return;
  }

  if (!enemyAlive) {
    session.status = 'victory';
    session.phase = 'finished';
    return;
  }

  session.status = 'fighting';
};

const advanceWaveIfNeeded = (session: BattleSession): void => {
  while (session.currentWaveIndex < session.waveOrder.length) {
    const aliveEnemies = getCurrentWaveAliveEnemies(session);
    if (aliveEnemies.length > 0) {
      break;
    }
    session.currentWaveIndex += 1;
  }
};

export const resolveTurn = (session: BattleSession, eventBus: BattleEventBus): BattleSession => {
  if (session.status !== 'fighting') {
    return session;
  }
  const nextSession = cloneSession(session);
  nextSession.turn += 1;
  nextSession.phase = 'resolving';

  advanceWaveIfNeeded(nextSession);
  let aliveEnemies = getCurrentWaveAliveEnemies(nextSession);

  if (aliveEnemies.length === 0) {
    updateBattleOutcome(nextSession);
    eventBus.emit({ type: 'turn_end' });
    nextSession.events = eventBus.drainEvents();
    return nextSession;
  }

  const playerAction: BattleAction = {
    id: `action_${nextSession.turn}_player`,
    type: 'basic_attack',
    sourceId: nextSession.player.id,
    targetIds: [aliveEnemies[0].id],
  };

  resolveAction(nextSession, playerAction, eventBus);
  const playerActionEvents = eventBus.drainEvents();
  resolveEffects(nextSession, playerActionEvents);
  updateBattleOutcome(nextSession);
  if (nextSession.status !== 'fighting') {
    eventBus.emit({ type: 'turn_end' });
    nextSession.events.push(...eventBus.drainEvents());
    return nextSession;
  }

  advanceWaveIfNeeded(nextSession);
  aliveEnemies = getCurrentWaveAliveEnemies(nextSession);
  if (aliveEnemies.length === 0) {
    updateBattleOutcome(nextSession);
    eventBus.emit({ type: 'turn_end' });
    nextSession.events = eventBus.drainEvents();
    return nextSession;
  }

  nextSession.phase = 'enemy_turn';
  for (const enemy of aliveEnemies) {
    const enemyAction: BattleAction = {
      id: `action_${nextSession.turn}_${enemy.id}`,
      type: 'basic_attack',
      sourceId: enemy.id,
      targetIds: [nextSession.player.id],
    };

    resolveAction(nextSession, enemyAction, eventBus);
  }

  const enemyActionEvents = eventBus.drainEvents();
  resolveEffects(nextSession, enemyActionEvents);

  advanceWaveIfNeeded(nextSession);
  updateBattleOutcome(nextSession);
  if (nextSession.status === 'fighting') {
    nextSession.phase = 'player_input';
  }

  eventBus.emit({ type: 'turn_end' });
  nextSession.events.push(...eventBus.drainEvents());
  return nextSession;
};


===================== [D:\download\LootingRPG\src\domains\battle\services\monsterScaling.ts] =====================
import type { EntityStats } from '../../../shared/types/game';
import type { Monster } from '../../../config/game/monsterSchema';
import { SCALING_PROFILES } from '../../../config/game/monsterSchema';

export const getMapMonsterBaselineByLevel = (recommendedLevel: number): EntityStats => {
  const level = Math.max(1, recommendedLevel);
  return {
    hp: Math.floor(120 + (level - 1) * 14),
    attack: Math.floor(16 + (level - 1) * 1.35),
    defense: Math.floor(7 + (level - 1) * 0.72),
  };
};
export const resolveMonsterTemplateStats = (
  monster: Pick<Monster, 'baseStats' | 'scalingProfile'>,
  mapBaseline: EntityStats,
): { maxHp: number } & EntityStats => {
  const profile = SCALING_PROFILES[monster.scalingProfile] ?? SCALING_PROFILES.normal;
  return {
    maxHp:   Math.floor(mapBaseline.hp      * monster.baseStats.hp      * profile.hp),
    hp :     Math.floor(mapBaseline.hp      * monster.baseStats.hp      * profile.hp),
    attack:  Math.floor(mapBaseline.attack  * monster.baseStats.attack  * profile.attack),
    defense: Math.floor(mapBaseline.defense * monster.baseStats.defense * profile.defense),
  };
};


===================== [D:\download\LootingRPG\src\domains\battle\services\monsterStats.ts] =====================
import type { CounterStatKey, Monster } from '../../../shared/types/game';
import type { FinalPlayerCombatStats } from '../../player/model/combat';
import { getCombatProfile } from '../../player/model/combat';
import i18n from '../../../i18n';
import { getMapNodeById } from '../../map/services/nodeLookup';
import { getMapMonsterBaselineByLevel, resolveMonsterTemplateStats } from './monsterScaling';

export interface FinalMonsterCombatStats {
  maxHp: number;
  attack: number;
  defense: number;
  damageReduction: number;
  shieldReduction: number;
  rageMultiplier: number;
  bossSkillInterval: number;
  statusProcMultiplier: number;
  objectiveLabel: string | null;
  objectivePassed: boolean;
}

const clamp = (value: number, min: number, max: number): number => Math.max(min, Math.min(max, value));

const defenseToReductionRate = (
  defenseValue: number,
  hardCapRate: number,
  growthRate: number,
): number => {
  const normalized = Math.max(0, defenseValue);
  const rate = 1 - Math.exp(-growthRate * normalized);
  return clamp(rate, 0, hardCapRate);
};

const readPlayerCounterStat = (player: FinalPlayerCombatStats, stat: CounterStatKey): number => {
  if (stat === 'attack') return player.attack;
  if (stat === 'defense') return player.defense;
  if (stat === 'hp') return player.maxHp;
  if (stat === 'elemental') return player.elementalBonus;
  if (stat === 'lifesteal') return player.lifestealRate * 100;
  if (stat === 'thorns') return player.thornsRate * 100;
  if (stat === 'attackSpeed') return player.speed;
  return 0;
};

export const getFinalMonsterStats = (
  monster: Monster,
  playerLevel: number,
  encounterCount: number,
  isBoss: boolean,
  finalPlayer: FinalPlayerCombatStats,
  mapNodeId?: string,
): FinalMonsterCombatStats => {
  const monsterLevel = Math.max(1, Number(monster.level) || 1);
  const monsterLevelFactor = 1 + (monsterLevel - 1) * 0.08;
  const levelFactor = 1 + Math.max(0, playerLevel - 1) * 0.08;
  const encounterFactor = 1 + Math.min(0.65, encounterCount * 0.003);
  const hpFactor = isBoss ? 1.55 : 1.28;
  const attackFactor = isBoss ? 1.36 : 1.22;
  const defenseFactor = isBoss ? 1.32 : 1.18;
  const combatProfile = getCombatProfile();

  const mapNode = mapNodeId ? getMapNodeById(mapNodeId) : undefined;
  const mapBaseline = getMapMonsterBaselineByLevel(mapNode?.recommendedLevel ?? playerLevel);
  const templateStats = resolveMonsterTemplateStats(monster, mapBaseline);

  let maxHp = Math.floor(templateStats.maxHp * levelFactor * encounterFactor * hpFactor * monsterLevelFactor);
  let attack = Math.floor(templateStats.attack * levelFactor * encounterFactor * attackFactor * combatProfile.monsterDamageMultiplier * monsterLevelFactor);
  let defense = Math.floor(templateStats.defense * levelFactor * encounterFactor * defenseFactor * (1 + (monsterLevel - 1) * 0.06));

  let objectivePassed = true;
  let objectiveLabel: string | null = null;

  if (monster.monsterType === 'boss' && monster.counterGoal) {
    const currentValue = readPlayerCounterStat(finalPlayer, monster.counterGoal.stat);
    objectivePassed = currentValue >= monster.counterGoal.threshold;
    objectiveLabel = objectivePassed
      ? i18n.t('codex.counterGoal.passed', { title: monster.counterGoal.title, detail: monster.counterGoal.successText })
      : i18n.t('codex.counterGoal.failed', { title: monster.counterGoal.title, detail: monster.counterGoal.failText });

    if (objectivePassed) {
      attack = Math.floor(attack * 0.95);
      defense = Math.floor(defense * 0.9);
    } else {
      maxHp = Math.floor(maxHp * 1.22);
      attack = Math.floor(attack * 1.18);
      defense = Math.floor(defense * 1.15);
    }
  }

  const damageReduction = defenseToReductionRate(defense, 0.62, 0.011);

  return {
    maxHp: Math.max(1, maxHp),
    attack: Math.max(1, attack),
    defense: Math.max(0, defense),
    damageReduction,
    shieldReduction: 0.6,
    rageMultiplier: 1.3,
    bossSkillInterval: combatProfile.bossSkillInterval,
    statusProcMultiplier: combatProfile.statusProcMultiplier,
    objectiveLabel,
    objectivePassed,
  };
};

export const calculateFinalMonsterStats = getFinalMonsterStats;

interface TurnSnapshotOptions {
  monsterIsShocked: boolean;
  shieldTurns: number;
  monsterRageActive: boolean;
}

export interface TurnCombatSnapshot {
  playerAttack: number;
  monsterAttack: number;
  playerDamageReduction: number;
  monsterDamageReduction: number;
  shieldMultiplier: number;
}

export const getTurnCombatSnapshot = (
  finalPlayer: FinalPlayerCombatStats,
  finalMonster: FinalMonsterCombatStats,
  options: TurnSnapshotOptions,
): TurnCombatSnapshot => {
  const monsterDamageReduction = finalMonster.damageReduction * (options.monsterIsShocked ? 0.8 : 1);
  const monsterAttack = finalMonster.attack * (options.monsterRageActive ? finalMonster.rageMultiplier : 1);

  return {
    playerAttack: finalPlayer.attack,
    monsterAttack,
    playerDamageReduction: finalPlayer.damageReduction,
    monsterDamageReduction: clamp(monsterDamageReduction, 0, 0.85),
    shieldMultiplier: options.shieldTurns > 0 ? finalMonster.shieldReduction : 1,
  };
};


===================== [D:\download\LootingRPG\src\domains\battle\services\session.ts] =====================
import type { BattleResult, BattleSession, GameState, MapProgressState} from '../../../shared/types/game';
import type { BattleUnitInstance, BattleUnitSchema } from '../../../types/battle/BattleUnit';
import type { MapChapterDef, MapNodeDef, NodeWave } from '../../map/model/chapters';
import { getFinalPlayerStats } from '../../player/model/combat';
import { getFinalMonsterStats } from './monsterStats';
import { getMonsterById } from '../../monster/config';
import { applyMapNodeResult } from '../../map/services/progress';
import { PLAYER_GROWTH } from '../../game/config/progression';
import { recalculatePlayerStats } from '../../player/services/recalculatePlayerStats';
import { generateEquipment } from '../../inventory/services/equipment';
import { createBattleUnit } from '../UnitFactory';
import { BattleEngine } from '../engine/BattleEngine';
import i18n from '../../../i18n';
interface BattleTransition {
  nextGameState: GameState;
  nextMapProgress: MapProgressState;
  logs: string[];
  focusNodeId?: string;
  error?: string;
}

const toBattleLog = (message: string) => `[Battle] ${message}`;

const getUnitMetaString = (unit: BattleUnitInstance, key: string): string | undefined => {
  const value = unit.meta?.[key];
  return typeof value === 'string' ? value : undefined;
};

const getUnitMetaBoolean = (unit: BattleUnitInstance, key: string): boolean => {
  return unit.meta?.[key] === true;
};

const getUnitMetaDropDict = (unit: BattleUnitInstance): Record<string, number> | undefined => {
  const value = unit.meta?.dropdict;
  if (!value || typeof value !== 'object' || Array.isArray(value)) {
    return undefined;
  }
  return value as Record<string, number>;
};

const getWaveId = (unit: BattleUnitInstance, fallback: string): string => {
  return getUnitMetaString(unit, 'waveId') ?? fallback;
};

const ensureNodeWaves = (node: MapNodeDef): NodeWave[] => {
  if (!node.waves || node.waves.length === 0) {
    throw new Error(`Node ${node.id} has no waves configured.`);
  }
  return node.waves;
};
const normalizeSessionWaves = (session: BattleSession): BattleSession => {
  const enemies = (session.enemies ?? []).map((enemy, index) => ({
    ...enemy,
    meta: {
      ...(enemy.meta ?? {}),
      waveId: getWaveId(enemy, `wave-${index + 1}`),
    },
  }));

  const inferredWaveOrder = Array.from(new Set(enemies.map((enemy, index) => getWaveId(enemy, `wave-${index + 1}`))));
  const existingWaveOrder = Array.isArray(session.waveOrder) ? session.waveOrder : [];
  const waveOrder = existingWaveOrder.length > 0
    ? existingWaveOrder.filter((waveId) => inferredWaveOrder.includes(waveId))
    : inferredWaveOrder;
  const safeWaveOrder = waveOrder.length > 0 ? waveOrder : inferredWaveOrder;
  const maxWaveIndex = Math.max(0, safeWaveOrder.length - 1);
  const currentWaveIndex = Number.isFinite(session.currentWaveIndex)
    ? Math.max(0, Math.min(maxWaveIndex, session.currentWaveIndex))
    : 0;

  return {
    ...session,
    enemies,
    waveOrder: safeWaveOrder,
    currentWaveIndex,
    phase: session.phase ?? 'player_input',
    events: Array.isArray(session.events) ? session.events : [],
  };
};
const buildEnemyUnit = (
  node: MapNodeDef,
  wave: NodeWave,
  waveId: string,
  monsterId: string,
  enemyIndex: number,
  playerLevel: number,
  playerFinal: ReturnType<typeof getFinalPlayerStats>,
): BattleUnitInstance => {
  const monster = getMonsterById(monsterId);
  if (!monster) {
    throw new Error(`Monster '${monsterId}' not found in content config.`);
  }

  const isBoss = node.encounterType === 'boss' || monster.monsterType === 'boss';
  const finalMonster = getFinalMonsterStats(monster, playerLevel, enemyIndex, isBoss, playerFinal, node.id);

  const monsterSchema: BattleUnitSchema = {
    id: `${waveId}-${monster.id}-${enemyIndex}`,
    name: monster.name,
    faction: 'monster',
    baseStats: {
      hp: finalMonster.maxHp,
      attack: finalMonster.attack,
      defense: finalMonster.defense,
    },
    skills: monster.skillSet ?? [],
    passives: [],
    elements: [],
    tags: [monster.monsterType],
    aiProfile: 'default',
    derivedStats: {
      damageReduction: finalMonster.damageReduction,
    },
    meta: {
      monsterId: monster.id,
      icon: monster.icons[0] ?? '馃懢',
      waveId,
      waveLabel: wave.label,
      isBoss,
      dropdict: monster.dropdict,
    },
  };

  return createBattleUnit(monsterSchema, playerLevel);
};
const resolveBattleResult = (
  gameState: GameState,
  mapProgress: MapProgressState,
  chapters: MapChapterDef[],
  session: BattleSession,
  won: boolean,
): BattleTransition => {
  const nodeChapter = chapters.find((chapter) => chapter.id === session.chapterId);
  const node = nodeChapter?.nodes.find((entry) => entry.id === session.nodeId);

  if (!nodeChapter || !node) {
    return {
      nextGameState: {
        ...gameState,
        battle: {
          ...gameState.battle,
          activeSession: null,
        },
      },
      nextMapProgress: mapProgress,
      logs: [toBattleLog('Battle ended but map node could not be resolved.')],
      error: 'Map node not found',
    };
  }

  const mapResult = applyMapNodeResult({
    progress: mapProgress,
    chapters,
    chapterId: nodeChapter.id,
    nodeId: node.id,
    won,
  });

  let nextState: GameState = {
    ...gameState,
    battle: {
      ...gameState.battle,
      activeSession: null,
    },
  };

  let xpGained = 0;
  let goldGained = 0;
  const logs: string[] = [];

  if (won) {
    xpGained = Math.max(15, node.recommendedLevel * 6 + session.enemies.length * 8);
    goldGained = node.firstClearRewardGold;

    const rewardEnemy = session.enemies.find((enemy) => getUnitMetaBoolean(enemy, 'isBoss')) ?? session.enemies[session.enemies.length - 1];
    const rewardDropDict = rewardEnemy ? getUnitMetaDropDict(rewardEnemy) : undefined;
    const drop = rewardEnemy
      ? generateEquipment(
          { monsterType: getUnitMetaBoolean(rewardEnemy, 'isBoss') ? 'boss' : 'normal', dropdict: rewardDropDict },
          gameState.pityCounts,
          gameState.playerStats.level,
        )
      : null;

    let nextXp = gameState.playerStats.xp + xpGained;
    let nextLevel = gameState.playerStats.level;
    while (nextXp >= nextLevel * PLAYER_GROWTH.xpPerLevel) {
      nextXp -= nextLevel * PLAYER_GROWTH.xpPerLevel;
      nextLevel += 1;
    }

    nextState = recalculatePlayerStats({
      ...nextState,
      playerStats: {
        ...nextState.playerStats,
        xp: nextXp,
        level: nextLevel,
        gold: nextState.playerStats.gold + goldGained,
      },
      pityCounts: drop?.newPity ?? nextState.pityCounts,
      droppedEquipment: drop?.item ?? null,
      backpack: drop?.item ? [...nextState.backpack, drop.item] : nextState.backpack,
    });

    logs.push(toBattleLog(`${session.nodeName} cleared.`));
    logs.push(toBattleLog(`Gained ${xpGained} XP and ${goldGained} gold.`));
    if (nextLevel > gameState.playerStats.level) {
      logs.push(toBattleLog(`Level up to Lv.${nextLevel}.`));
    }
    if (drop?.item) {
      logs.push(toBattleLog(`Loot acquired: ${drop.item.name}.`));
    }

    if (mapResult.unlockedNodeId) {
      logs.push(toBattleLog(`Unlocked node ${mapResult.unlockedNodeId}.`));
    }
    if (mapResult.unlockedChapterId) {
      logs.push(toBattleLog(`Unlocked chapter ${mapResult.unlockedChapterId}.`));
    }
  } else {
    logs.push(toBattleLog(`${session.nodeName} challenge failed.`));
  }

  const history: BattleResult = {
    sessionId: session.id,
    chapterId: session.chapterId,
    nodeId: session.nodeId,
    won,
    turns: session.turn,
    xpGained,
    goldGained,
    finishedAt: Date.now(),
  };

  nextState = {
    ...nextState,
    battle: {
      activeSession: null,
      history: [...nextState.battle.history.slice(-39), history],
    },
  };

  return {
    nextGameState: nextState,
    nextMapProgress: mapResult.nextProgress,
    logs,
    focusNodeId: won ? mapResult.unlockedNodeId : session.nodeId,
  };
};
export const startBattleSession = (
  gameState: GameState,
  chapter: MapChapterDef,
  node: MapNodeDef,
): { nextGameState: GameState; logs: string[]; error?: string } => {
  try {
    /// 1. 楠岃瘉鑺傜偣閰嶇疆
    // 纭繚鑺傜偣鏈夋尝娆￠厤缃紝骞朵笖姣忎釜娉㈡鑷冲皯鏈変竴涓€墿
    const nodeWaves = ensureNodeWaves(node);
    //  2. 璁＄畻鐜╁鏈€缁堝睘鎬?    const playerFinal = getFinalPlayerStats(gameState.playerStats, gameState.battle.history.length);
    //  3. 鍚堟硶娉㈡杩囨护锛氬彧淇濈暀閭ｄ簺閰嶇疆浜嗘€墿鐨勬尝娆★紝骞朵负姣忎釜鎬墿鐢熸垚涓€涓敮涓€鐨勬晫浜篒D锛堟牸寮忥細waveId-monsterId-index锛?    const validWaves = nodeWaves
      .map((wave, index) => ({ wave, waveId: wave.id || `wave-${index + 1}` }))
      .filter(({ wave }) => Array.isArray(wave.monsters) && wave.monsters.length > 0);
    //  4. 鏋勫缓鏁屾柟鍗曚綅锛氱粺涓€鍒涘缓涓?BattleUnitInstance
    const enemies: BattleUnitInstance[] = [];
    let enemyIndex = 0;
    //  5. 鎴樻枟浼氳瘽鏋勫缓锛氬皢鎵€鏈変俊鎭暣鍚堝埌涓€涓?BattleSession 瀵硅薄涓紝
    //     鍖呭惈鐜╁灞炴€с€佹晫浜哄垪琛ㄣ€佸綋鍓嶆尝娆＄姸鎬佺瓑
    for (const { wave, waveId } of validWaves) {
      for (const waveMonster of wave.monsters) {
        enemies.push(
          buildEnemyUnit(node, wave, waveId, waveMonster.monsterId, enemyIndex, gameState.playerStats.level, playerFinal),
        );
        enemyIndex += 1;
      }
    }

    if (enemies.length === 0) {
      throw new Error(`Node ${node.id} has no valid monsters in waves.`);
    }
    // 6. 閿欒澶勭悊锛氬鏋滃湪浠讳綍姝ラ涓彂鐢熼敊璇紙渚嬪閰嶇疆缂哄け銆佹暟鎹紓甯哥瓑锛夛紝
    // 鎹曡幏閿欒骞惰繑鍥炰竴涓寘鍚敊璇俊鎭殑缁撴灉瀵硅薄锛岀‘淇濊皟鐢ㄦ柟鑳藉姝ｇ‘澶勭悊寮傚父鎯呭喌銆?    const playerUnit = createBattleUnit(
      {
        id: 'player',
        name: 'Player',
        faction: 'player',
        baseStats: {
          hp: playerFinal.maxHp,
          attack: playerFinal.attack,
          defense: playerFinal.defense,
        },
        skills: [],
        passives: [],
        elements: [],
        tags: ['player'],
        derivedStats: {
          damageReduction: playerFinal.damageReduction,
          critRate: playerFinal.critRate,
          lifestealRate: playerFinal.lifestealRate,
          thornsRate: playerFinal.thornsRate,
          elementalBonus: playerFinal.elementalBonus,
        },
      },
      gameState.playerStats.level,
    );

    const session: BattleSession = {
      id: `battle_${Date.now()}`,
      chapterId: chapter.id,
        chapterName: i18n.t(`map.${chapter.id}`),
      nodeId: node.id,
      nodeName: node.name,
      encounterType: node.encounterType,
      turn: 0,
      player: playerUnit,
      enemies,
      waveOrder: validWaves.map((entry) => entry.waveId),
      currentWaveIndex: 0,
      phase: 'player_input',
      status: 'fighting',
      events: [],
      logs: [toBattleLog(`Entered ${i18n.t(`map.${chapter.id}`)} - ${node.name}.`)],
    };
    // 7. 杩斿洖缁撴灉瀵硅薄锛氬寘鍚洿鏂板悗鐨勬父鎴忕姸鎬併€佹棩蹇椾俊鎭互鍙婂彲鑳界殑閿欒淇℃伅
    return {
      nextGameState: {
        ...gameState,
        battle: {
          ...gameState.battle,
          activeSession: session,
        },
      },
      logs: [toBattleLog(`Challenge started: ${i18n.t(`map.${chapter.id}`)} / ${node.name}.`)],
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return {
      nextGameState: gameState,
      logs: [toBattleLog(`Cannot start battle: ${message}`)],
      error: message,
    };
  }
};

export const runBattlePlayerAttack = (
  gameState: GameState,
  mapProgress: MapProgressState,
  chapters: MapChapterDef[],
): BattleTransition => {
  const sessionRaw = gameState.battle.activeSession;
  if (!sessionRaw || sessionRaw.status !== 'fighting') {
    return {
      nextGameState: gameState,
      nextMapProgress: mapProgress,
      logs: [],
      error: 'No active battle session',
    };
  }

  const session = normalizeSessionWaves(sessionRaw);
  const nextSession = BattleEngine.resolveTurn(session);

  if (nextSession.status === 'victory') {
    return resolveBattleResult(
      {
        ...gameState,
        battle: { ...gameState.battle, activeSession: nextSession },
      },
      mapProgress,
      chapters,
      nextSession,
      true,
    );
  }

  if (nextSession.status === 'defeat') {
    return resolveBattleResult(
      {
        ...gameState,
        battle: { ...gameState.battle, activeSession: nextSession },
      },
      mapProgress,
      chapters,
      nextSession,
      false,
    );
  }

  return {
    nextGameState: {
      ...gameState,
      battle: { ...gameState.battle, activeSession: nextSession },
    },
    nextMapProgress: mapProgress,
    logs: nextSession.logs.slice(-3),
  };
};

export const runBattleRetreat = (
  gameState: GameState,
  mapProgress: MapProgressState,
  chapters: MapChapterDef[],
): BattleTransition => {
  const sessionRaw = gameState.battle.activeSession;
  if (!sessionRaw) {
    return {
      nextGameState: gameState,
      nextMapProgress: mapProgress,
      logs: [],
      error: 'No active battle session',
    };
  }

  const session = normalizeSessionWaves(sessionRaw);

  const nextSession: BattleSession = {
    ...session,
    status: 'defeat',
    phase: 'finished',
    logs: [...session.logs, toBattleLog('You retreated from battle.')],
  };

  return resolveBattleResult(
    {
      ...gameState,
      battle: {
        ...gameState.battle,
        activeSession: nextSession,
      },
    },
    mapProgress,
    chapters,
    nextSession,
    false,
  );
};


===================== [D:\download\LootingRPG\src\domains\battle\battleMaths.ts] =====================
// battleMath.ts

export const clamp = (v: number, min: number, max: number) =>
  Math.max(min, Math.min(max, v));

/**
 * 鏀婚槻姣斾激瀹虫ā鍨嬶紙闃茬垎鐐革級
 * damage = A虏 / (A + D)
 */
export const computeDamage = (
  attack: number,
  defense: number,
  critMultiplier: number,
  flatBonus: number = 0,
): number => {
  const effectiveAttack = attack * critMultiplier + flatBonus;
  const safeDefense = Math.max(1, defense);

  const damage =
    (effectiveAttack * effectiveAttack) /
    (effectiveAttack + safeDefense);

  return Math.max(1, Math.floor(damage));
};

/**
 * 鏆村嚮浼ゅ閫掑噺
 */
export const computeCritMultiplier = (
  didCrit: boolean,
  critDamage: number,
): number => {
  if (!didCrit) return 1;

  const effectiveCritDamage =
    critDamage / (1 + critDamage * 0.6);

  return 1 + effectiveCritDamage;
};

/**
 * 鍏冪礌绌块€忥紙涓嶆槸鍔犱激锛?
 */
export const computeEffectiveDefense = (
  defense: number,
  elementalPenetration: number,
): number => {
  const pen = clamp(elementalPenetration, 0, 0.6);
  return defense * (1 - pen);
};

/**
 * 鍚歌閫掑噺
 */
export const computeEffectiveLifesteal = (rate: number): number => {
  return rate / (1 + rate);
};


===================== [D:\download\LootingRPG\src\domains\battle\UnitFactory.ts] =====================
// UnitFactory.ts
// 璐熻矗鍒涘缓鎴樻枟鍗曚綅瀹炰緥鐨勫伐鍘傚嚱鏁?
// 閫氳繃浼犲叆鍗曚綅鐨勫熀纭€鏁版嵁鍜岀瓑绾э紝鐢熸垚涓€涓畬鏁寸殑鎴樻枟鍗曚綅瀵硅薄
// 鎴樻枟灞備笉瑕佸啀鐩存帴璇诲彇 monster JSON
// 蹇呴』閫氳繃 UnitFactory 鐢熸垚鎴樻枟鍗曚綅
import { BattleUnitSchema } from '@src/types/battle/BattleUnit'
import type { BattleUnitInstance } from '@src/types/battle/BattleUnit'
export function createBattleUnit(
  data: BattleUnitSchema,
  level: number
): BattleUnitInstance {
  return {
    id: data.id,
    name: data.name,
    faction: data.faction,
    level,
    baseStats: { ...data.baseStats },
    currentHp: data.baseStats.hp,
    derivedStats: {
      damageReduction: data.derivedStats?.damageReduction ?? 0,
      critRate: data.derivedStats?.critRate,
      lifestealRate: data.derivedStats?.lifestealRate,
      thornsRate: data.derivedStats?.thornsRate,
      elementalBonus: data.derivedStats?.elementalBonus,
    },
    skills: [...data.skills],
    passives: data.passives ?? [],
    elements: data.elements ?? [],
    tags: data.tags ?? [],
    meta: {
      ...(data.meta ?? {}),
      aiProfile: data.aiProfile ?? 'default',
    },
  }
}


===================== [D:\download\LootingRPG\src\domains\game\config\progression.ts] =====================
/**
 * @deprecated 杩佺Щ杩囨浮灞傦細褰撳墠浠嶇敱 `src/config/game/progression.ts` 浣滀负绋冲畾鏉ユ簮銆? */
export * from '../../../config/game/progression';


===================== [D:\download\LootingRPG\src\domains\inventory\services\actions.ts] =====================
import type { Equipment, GameState } from '../../../shared/types/game';
import { QUALITY_CONFIG, LOCK_COST, REROLL_BASE_COST } from '../../../config/game/equipment';
import { attemptEnhancement } from './enhancement';
import { rerollAffixes } from './equipment';
import i18n from '../../../i18n';

export type InventoryAction =
  | { type: 'equip'; itemId: string }
  | { type: 'sell'; itemId: string }
  | { type: 'enchant'; itemId: string }
  | { type: 'unequip_slot'; slot: string }
  | { type: 'reroll'; itemId: string; lockTypes?: string[] };

export interface InventoryActionResult {
  nextState: GameState;
  logs: string[];
}

const findItemById = (state: GameState, itemId: string): Equipment | undefined => {
  return (
    state.backpack.find((item) => item.id === itemId) ??
    (Object.values(state.currentEquipment) as Array<Equipment | null>).find((item) => item?.id === itemId) ??
    undefined
  );
};

export const applyInventoryAction = (state: GameState, action: InventoryAction): InventoryActionResult => {
  const nextState = structuredClone(state);
  const logs: string[] = [];

  const logSystemMessage = (message: string) => {
    nextState.systemMessage = message;
    logs.push(message);
  };

  if (action.type === 'equip') {
    const item = nextState.backpack.find((entry) => entry.id === action.itemId);
    if (!item) return { nextState, logs };

    const slotKey = item.slot;
    const oldItem = nextState.currentEquipment[slotKey];

    item.equipped = true;
    nextState.currentEquipment[slotKey] = item;
    nextState.backpack = nextState.backpack.filter((entry) => entry.id !== item.id && !entry.equipped);

    if (oldItem) {
      oldItem.equipped = false;
      nextState.backpack = [...nextState.backpack, oldItem];
    }

    logSystemMessage(i18n.t('message.equipped', { name: item.name }));
    return { nextState, logs };
  }

  if (action.type === 'unequip_slot') {
    const item = nextState.currentEquipment[action.slot];
    if (!item) return { nextState, logs };

    item.equipped = false;
    nextState.currentEquipment[action.slot] = null;
    nextState.backpack = [...nextState.backpack.filter((entry) => entry.id !== item.id), item];

    logSystemMessage(i18n.t('message.unequipped', { name: item.name }));
    return { nextState, logs };
  }

  if (action.type === 'sell') {
    const itemIndex = nextState.backpack.findIndex((entry) => entry.id === action.itemId);
    if (itemIndex < 0) return { nextState, logs };

    const item = nextState.backpack[itemIndex];
    const price = QUALITY_CONFIG[item.quality]?.price ?? 0;
    nextState.playerStats.gold += price;
    nextState.backpack.splice(itemIndex, 1);

    logSystemMessage(i18n.t('message.sold_item', { name: item.name, price }));
    return { nextState, logs };
  }

  if (action.type === 'enchant') {
    logs.push(...attemptEnhancement(nextState, action.itemId));
    return { nextState, logs };
  }

  if (action.type === 'reroll') {
    const item = findItemById(nextState, action.itemId);
    if (!item) return { nextState, logs };

    const lockTypes = action.lockTypes ?? [];
    const cost = REROLL_BASE_COST * ((item.enhancementLevel || 0) + 1) + lockTypes.length * LOCK_COST;

    if (nextState.playerStats.gold < cost) {
      logs.push(i18n.t('message.not_enough_gold_reroll'));
      return { nextState, logs };
    }

    nextState.playerStats.gold -= cost;
    const previous = item.affixes.length;
    rerollAffixes(item, { lockTypes });
    const rerolledCount = Math.max(0, previous - lockTypes.length);

    logSystemMessage(
      i18n.t('message.reroll_complete', {
        name: item.name,
        count: rerolledCount,
      }),
    );

    return { nextState, logs };
  }

  return { nextState, logs };
};


===================== [D:\download\LootingRPG\src\domains\inventory\services\autoSell.ts] =====================
import { QUALITIES } from '../../../config/game/equipment';

export const createAutoSellQualityMap = (): Record<string, boolean> => {
  return QUALITIES.reduce((acc, quality) => {
    acc[quality] = false;
    return acc;
  }, {} as Record<string, boolean>);
};


===================== [D:\download\LootingRPG\src\domains\inventory\services\enhancement.ts] =====================
import { calculateEnchantCost, applyEnchant } from './equipment';
import i18n from '../../../i18n';
import type { Equipment, GameState } from '../../../shared/types/game';

/**
 * 寮哄寲鍑芥暟: 灏濊瘯寮哄寲鎸囧畾鐨勮澶囷紝杩斿洖鏃ュ織淇℃伅
 */
export function attemptEnhancement(state: GameState, target: string): string[] {
  const logs: string[] = [];
  const logSystemMessage = (message: string) => {
    state.systemMessage = message;
    logs.push(message);
  };

  const item =
    state.backpack.find((i) => i.id === target) ||
    (Object.values(state.currentEquipment) as (Equipment | null)[]).find((i) => i?.id === target);

  if (item) {
    if ((item.enhancementLevel || 0) >= 20) {
      logs.push(i18n.t('message.enchant_maxed'));
      return logs;
    }

    const cost = calculateEnchantCost(item);
    if (state.playerStats.gold >= cost) {
      state.playerStats.gold -= cost;
      const lv = item.enhancementLevel || 0;
      const success = calculateEnhancementSuccess(lv);
      if (success) {
        applyEnchant(item);
        logSystemMessage(
          i18n.t('message.enchant_success', {
            name: item.name,
            level: item.enhancementLevel,
          }),
        );
      } else {
        logSystemMessage(i18n.t('message.enchant_fail'));
      }
    } else {
      logs.push(i18n.t('message.not_enough_gold_enchant'));
    }
  }

  return logs;
}

export function calculateEnhancementSuccess(lv: number): boolean {
  if (lv < 5) return true;
  if (lv < 10) return Math.random() < 0.6;
  if (lv < 15) return Math.random() < 0.3;
  if (lv < 20) return Math.random() < 0.1;
  return false;
}


===================== [D:\download\LootingRPG\src\domains\inventory\services\equipment.ts] =====================
import {
  QUALITIES,
  AFFIX_SCALING,
  AFFIX_COUNT_BY_QUALITY,
  ENCHANT_BASE_COST,
  ENCHANT_SCALE_BY_QUALITY,
  ENCHANT_COST_MULTIPLIER_BY_QUALITY,
} from '../../../config/game/equipment';
import { getEquipmentTemplates, type EquipmentTemplate } from '../../../config/game/equipment';
import type { Equipment, EquipmentAffix, EquipmentAffixValue } from '../../../shared/types/game';
import i18next from 'i18next';

const AFFIX_POOL: EquipmentAffix[] = ['crit_chance', 'lifesteal', 'damage_bonus', 'thorns', 'hp_bonus'];

const createAffix = (type: EquipmentAffix, qualityIndex: number): EquipmentAffixValue => {
  const idx = Math.min(Math.max(0, qualityIndex), QUALITIES.length - 1);
  const scaling = (AFFIX_SCALING as Record<string, number[]>)[type] ?? [];
  const value = scaling[idx] ?? 0;
  return { type, value };
};

const getLocaleKey = (): 'zh' | 'en' =>
  (i18next.language || 'zh').toLowerCase().startsWith('zh') ? 'zh' : 'en';

const inferMainStat = (attributes: Record<string, number>, slot: string): string => {
  const preferredBySlot = slot === 'weapon' ? 'attack' : slot === 'armor' || slot === 'helmet' ? 'hp' : 'defense';
  if (attributes[preferredBySlot] !== undefined) {
    return preferredBySlot;
  }

  const ranked = Object.entries(attributes).sort((a, b) => b[1] - a[1]);
  return ranked[0]?.[0] || preferredBySlot;
};

const pickRandom = <T,>(list: T[]): T => list[Math.floor(Math.random() * list.length)];

const buildFromTemplate = (template: EquipmentTemplate, playerLevel: number): Equipment => {
  const localeKey = getLocaleKey();
  const level = playerLevel + template.levelOffset;
  const scale = level * template.scalePerLevel;

  const attributes = Object.fromEntries(
    Object.entries(template.attributes).map(([key, value]) => [key, Math.round(value * scale)]),
  );

  const affixes = template.affixes.map((entry) => ({
    type: entry.type as EquipmentAffix,
    value: Math.round(entry.value * scale),
  }));

  const name = localeKey === 'zh' ? template.nameZh : template.nameEn;
  const special = localeKey === 'zh' ? template.specialZh : template.specialEn;

  return {
    id: `${template.id}_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 7)}`,
    icon: template.icon,
    level,
    name,
    quality: template.quality,
    slot: template.slot,
    attributes,
    affixes,
    enhancementLevel: 0,
    mainStat: inferMainStat(attributes, template.slot),
    equipped: false,
    special,
    localeNames: {
      zh: template.nameZh,
      en: template.nameEn,
    },
  };
};

const normalizePity = (pity: { legendary: number; mythic: number }): { legendary: number; mythic: number } => ({
  legendary: Number(pity.legendary ?? 0),
  mythic: Number(pity.mythic ?? 0),
});

const pickTemplateOrThrow = (templates: EquipmentTemplate[]): EquipmentTemplate => {
  const selected = selectTemplate(templates);
  if (selected) return selected;

  if (templates.length === 0) {
    throw new Error('UniqueEquipments.csv has no valid rows.');
  }
  return pickRandom(templates);
};

const selectTemplate = (templates: EquipmentTemplate[]): EquipmentTemplate | null => {
  const eligible = templates;
  if (eligible.length === 0) return null;
  return pickRandom(eligible);
};

const pickFromDropDict = (
  templates: EquipmentTemplate[],
  dropdict?: Record<string, number>,
): EquipmentTemplate | null => {
  if (!dropdict) return null;

  const templateById = new Map(templates.map((template) => [template.id, template]));
  const candidates = Object.entries(dropdict)
    .map(([id, chance]) => ({ id, chance: Number(chance), template: templateById.get(id) }))
    .filter((entry) => entry.template && Number.isFinite(entry.chance) && entry.chance > 0) as Array<{
    id: string;
    chance: number;
    template: EquipmentTemplate;
  }>;

  if (candidates.length === 0) return null;

  const total = candidates.reduce((sum, entry) => sum + entry.chance, 0);
  let roll = Math.random() * total;

  for (const entry of candidates) {
    roll -= entry.chance;
    if (roll <= 0) return entry.template;
  }

  return candidates[candidates.length - 1].template;
};

export const calculateEnchantCost = (item: Equipment): number => {
  const qIdx = Math.max(0, QUALITIES.indexOf(item.quality));
  const base = ENCHANT_BASE_COST;
  const mult = ENCHANT_COST_MULTIPLIER_BY_QUALITY[qIdx] ?? 1;
  return Math.max(0, Math.floor(base * (item.enhancementLevel + 1) * mult));
};

export const previewEnchant = (item: Equipment, times = 1): Equipment => {
  const copy: Equipment = structuredClone(item);
  const qIdx = Math.max(0, QUALITIES.indexOf(copy.quality));
  const scale = ENCHANT_SCALE_BY_QUALITY[qIdx] ?? 0.05;
  for (let i = 0; i < times; i++) {
    copy.enhancementLevel = (copy.enhancementLevel || 0) + 1;
    Object.entries(copy.attributes).forEach(([k, v]) => {
      copy.attributes[k] = Math.max(0, Math.round((v as number) * (1 + scale)));
    });
    if (Array.isArray(copy.affixes)) {
      copy.affixes = copy.affixes.map((a) => ({
        type: a.type,
        value: Math.max(0, Math.round(a.value * (1 + scale))),
      }));
    }
  }
  return copy;
};

export const applyEnchant = (item: Equipment): Equipment => {
  const qIdx = Math.max(0, QUALITIES.indexOf(item.quality));
  const scale = ENCHANT_SCALE_BY_QUALITY[qIdx] ?? 0.05;
  item.enhancementLevel = (item.enhancementLevel || 0) + 1;
  Object.entries(item.attributes).forEach(([k, v]) => {
    item.attributes[k] = Math.max(0, Math.round((v as number) * (1 + scale)));
  });
  if (Array.isArray(item.affixes)) {
    item.affixes = item.affixes.map((a) => ({
      type: a.type,
      value: Math.max(0, Math.round(a.value * (1 + scale))),
    }));
  }
  return item;
};

export const rerollAffixes = (item: Equipment, options?: { lockTypes?: string[] }): Equipment => {
  const qIdx = Math.max(0, QUALITIES.indexOf(item.quality));
  const lockTypes = options?.lockTypes ?? [];
  const existing = Array.isArray(item.affixes) ? item.affixes.slice() : [];
  const kept = existing.filter((a) => lockTypes.includes(a.type));
  const needed = Math.max(0, (AFFIX_COUNT_BY_QUALITY[qIdx] ?? 0) - kept.length);
  const pool = AFFIX_POOL.filter((p) => !lockTypes.includes(p));
  const newAffixes: EquipmentAffixValue[] = [];
  for (let i = 0; i < needed && pool.length > 0; i++) {
    const idx = Math.floor(Math.random() * pool.length);
    const type = pool.splice(idx, 1)[0];
    newAffixes.push(createAffix(type as EquipmentAffix, qIdx));
  }
  item.affixes = [...kept, ...newAffixes];
  return item;
};

export const generateEquipment = (
  monster: { monsterType?: 'normal' | 'elite' | 'boss'; dropdict?: Record<string, number> },
  pity: { legendary: number; mythic: number },
  playerLevel: number,
): { item: Equipment; newPity: { legendary: number; mythic: number } } => {
  const newPity = normalizePity(pity);
  newPity.legendary += 1;
  newPity.mythic += 1;

  const templates = getEquipmentTemplates();
  const selected = pickFromDropDict(templates, monster.dropdict) ?? pickTemplateOrThrow(templates);

  return {
    item: buildFromTemplate(selected, playerLevel),
    newPity,
  };
};

export const createCustomEquipment = (quality: string, slot: string, playerLevel = 1): Equipment => {
  const templates = getEquipmentTemplates().filter((template) => {
    if (template.slot !== slot) return false;
    if (template.quality !== quality) return false;
    return true;
  });

  const allTemplates = getEquipmentTemplates();
  const selected = templates.length > 0 ? pickRandom(templates) : pickTemplateOrThrow(allTemplates);

  return buildFromTemplate(selected, playerLevel);
};


===================== [D:\download\LootingRPG\src\domains\inventory\services\equipmentTotals.ts] =====================
import type { Equipment, EquipmentAffixValue } from '../../../shared/types/game';

export interface EquipmentTotals {
  attributes: Record<string, number>;
  affixes: Record<string, number>;
}

export function getEquipmentTotals(equips: Record<string, Equipment | null>): EquipmentTotals {
  const attributes: Record<string, number> = {};
  const affixes: Record<string, number> = {};

  Object.values(equips).forEach((item) => {
    if (!item) return;
    Object.entries(item.attributes).forEach(([key, value]) => {
      const num = typeof value === 'number' ? value : Number(value) || 0;
      attributes[key] = (attributes[key] || 0) + num;
    });

    item.affixes.forEach((a: EquipmentAffixValue) => {
      affixes[a.type] = (affixes[a.type] || 0) + a.value;
    });
  });

  return { attributes, affixes };
}


===================== [D:\download\LootingRPG\src\domains\inventory\services\quickSell.ts] =====================
import { QUALITIES, QUALITY_CONFIG } from '../../../config/game/equipment';
import type { Equipment, GameState } from '../../../shared/types/game';
import { t } from 'i18next';

const getQualityLabel = (qualityKey: string): string => t(`quality.${qualityKey}`);

export const quickSellByQualityRange = (
  state: GameState,
  minQuality: string,
  maxQuality: string,
): { nextState: GameState; message: string } => {
  const minIndex = QUALITIES.indexOf(minQuality);
  const maxIndex = QUALITIES.indexOf(maxQuality);

  if (minIndex < 0 || maxIndex < 0) {
    return {
      nextState: state,
      message: t('message.invalid_quality_range'),
    };
  }

  const lower = Math.min(minIndex, maxIndex);
  const upper = Math.max(minIndex, maxIndex);

  const nextState = structuredClone(state);
  const keep: Equipment[] = [];
  let soldCount = 0;
  let earnedGold = 0;

  nextState.backpack.forEach((item) => {
    const qualityIndex = QUALITIES.indexOf(item.quality);
    const inRange = qualityIndex >= lower && qualityIndex <= upper;

    if (inRange) {
      soldCount += 1;
      earnedGold += QUALITY_CONFIG[item.quality].price;
    } else {
      keep.push(item);
    }
  });

  if (soldCount === 0) {
    const message = t('message.no_items_in_range', {
      min: getQualityLabel(QUALITIES[lower]),
      max: getQualityLabel(QUALITIES[upper]),
    });
    nextState.systemMessage = message;
    return { nextState, message };
  }

  nextState.backpack = keep;
  nextState.playerStats.gold += earnedGold;
  const message = t('message.quick_sell_result', {
    min: getQualityLabel(QUALITIES[lower]),
    max: getQualityLabel(QUALITIES[upper]),
    count: soldCount,
    gold: earnedGold,
  });
  nextState.systemMessage = message;
  return { nextState, message };
};


===================== [D:\download\LootingRPG\src\domains\map\model\chapters.ts] =====================
import chapterData from '@data/config/map/ChapterData.json';
import { MapEncounterType, ChapterTheme } from '../../../config/map/mapNode';

interface RawNodeWave {
  id: string;
  label?: string;
  monsters: { monsterId: string }[];
}

interface RawMapNode {
  id: string;
  name: string;
  recommendedLevel: number;
  encounterType: string;
  firstClearRewardGold: number;
  waves?: RawNodeWave[];
}

interface RawMapChapter {
  id: string;
  name: string;
  levelRange: string;
  theme: string;
  nodes: RawMapNode[];
}

export interface NodeWave {
  id: string;
  label?: string;
  monsters: { monsterId: string }[];
}

export interface MapNodeDef {
  id: string;
  name: string;
  recommendedLevel: number;
  encounterType: MapEncounterType;
  firstClearRewardGold: number;
  waves?: NodeWave[];
}

export interface MapChapterDef {
  id: string;
  name: string;
  levelRange: string;
  theme: ChapterTheme;
  nodes: MapNodeDef[];
}

const rawChapters = chapterData.MAP_CHAPTERS as RawMapChapter[];

export const MAP_CHAPTERS: MapChapterDef[] = rawChapters.map((chapter) => ({
  ...chapter,
  theme: chapter.theme as ChapterTheme,
  nodes: chapter.nodes.map((node) => ({
    ...node,
    encounterType: node.encounterType as MapEncounterType,
  })),
}));


===================== [D:\download\LootingRPG\src\domains\map\services\nodeLookup.ts] =====================
import type { MapNodeDef } from '../model/chapters';
import { MAP_CHAPTERS } from '../model/chapters';

export const getMapNodeById = (nodeId: string): MapNodeDef | undefined => {
  for (const chapter of MAP_CHAPTERS) {
    const found = chapter.nodes.find((node) => node.id === nodeId);
    if (found) return found;
  }
  return undefined;
};


===================== [D:\download\LootingRPG\src\domains\map\services\progress.ts] =====================
import type { MapChapterDef } from '../model/chapters';
import type { MapProgressState } from '../../../shared/types/game';

export const createInitialMapProgress = (chapters: MapChapterDef[]): MapProgressState => {
  const firstChapter = chapters[0];
  const firstNode = firstChapter?.nodes[0];

  return {
    selectedChapterId: firstChapter?.id ?? 'chapter-1',
    unlockedChapters: firstChapter ? [firstChapter.id] : [],
    unlockedNodes: firstNode ? [firstNode.id] : [],
    clearedNodes: [],
    failedAttempts: {},
  };
};

export const normalizeMapProgress = (
  progress: MapProgressState | undefined,
  chapters: MapChapterDef[],
): MapProgressState => {
  const base = createInitialMapProgress(chapters);
  if (!progress) return base;

  const chapterIds = new Set(chapters.map((chapter) => chapter.id));
  const nodeIds = new Set(chapters.flatMap((chapter) => chapter.nodes.map((node) => node.id)));

  const unlockedChapters = Array.from(new Set(progress.unlockedChapters ?? [])).filter((id) => chapterIds.has(id));
  if (base.unlockedChapters.length > 0 && unlockedChapters.length === 0) {
    unlockedChapters.push(base.unlockedChapters[0]);
  }

  const unlockedNodes = Array.from(new Set(progress.unlockedNodes ?? [])).filter((id) => nodeIds.has(id));
  base.unlockedNodes.forEach((id) => {
    if (!unlockedNodes.includes(id)) unlockedNodes.push(id);
  });

  const clearedNodes = Array.from(new Set(progress.clearedNodes ?? [])).filter((id) => nodeIds.has(id));

  const failedAttempts: Record<string, number> = {};
  Object.entries(progress.failedAttempts ?? {}).forEach(([nodeId, attempts]) => {
    if (!nodeIds.has(nodeId)) return;
    failedAttempts[nodeId] = Math.max(0, Number(attempts) || 0);
  });

  const selectedChapterId = chapterIds.has(progress.selectedChapterId)
    ? progress.selectedChapterId
    : (unlockedChapters[0] ?? base.selectedChapterId);

  return {
    selectedChapterId,
    unlockedChapters,
    unlockedNodes,
    clearedNodes,
    failedAttempts,
  };
};

export const isChapterUnlocked = (progress: MapProgressState, chapterId: string) =>
  progress.unlockedChapters.includes(chapterId);

export const getNextNode = (chapter: MapChapterDef, nodeId: string) => {
  const idx = chapter.nodes.findIndex((n) => n.id === nodeId);
  if (idx < 0 || idx + 1 >= chapter.nodes.length) return undefined;
  return chapter.nodes[idx + 1];
};

export const getNextChapter = (chapters: MapChapterDef[], chapterId: string) => {
  const idx = chapters.findIndex((c) => c.id === chapterId);
  if (idx < 0 || idx + 1 >= chapters.length) return undefined;
  return chapters[idx + 1];
};

export const isNodeUnlocked = (progress: MapProgressState, nodeId: string) =>
  progress.unlockedNodes.includes(nodeId);

export const isNodeCleared = (progress: MapProgressState, nodeId: string) =>
  progress.clearedNodes.includes(nodeId);

export const getNodeAttempts = (progress: MapProgressState, nodeId: string) =>
  progress.failedAttempts[nodeId] ?? 0;

export const getChapterProgress = (
  progress: MapProgressState,
  chapter: MapChapterDef,
): { cleared: number; total: number; completed: boolean } => {
  const total = chapter.nodes.length;
  const cleared = chapter.nodes.reduce((acc, node) => acc + (isNodeCleared(progress, node.id) ? 1 : 0), 0);
  return {
    cleared,
    total,
    completed: total > 0 && cleared === total,
  };
};

interface ApplyNodeResultInput {
  progress: MapProgressState;
  chapters: MapChapterDef[];
  chapterId: string;
  nodeId: string;
  won: boolean;
}

export interface ApplyNodeResultOutput {
  nextProgress: MapProgressState;
  firstClear: boolean;
  unlockedNodeId?: string;
  unlockedChapterId?: string;
  chapterCompleted: boolean;
}

export const applyMapNodeResult = ({ progress, chapters, chapterId, nodeId, won }: ApplyNodeResultInput): ApplyNodeResultOutput => {
  const nextProgress = normalizeMapProgress(progress, chapters);

  if (!won) {
    nextProgress.failedAttempts[nodeId] = (nextProgress.failedAttempts[nodeId] ?? 0) + 1;
    return {
      nextProgress,
      firstClear: false,
      chapterCompleted: false,
    };
  }

  const firstClear = !nextProgress.clearedNodes.includes(nodeId);
  if (firstClear) {
    nextProgress.clearedNodes.push(nodeId);
  }

  if (!nextProgress.unlockedNodes.includes(nodeId)) {
    nextProgress.unlockedNodes.push(nodeId);
  }

  if (nextProgress.failedAttempts[nodeId]) {
    delete nextProgress.failedAttempts[nodeId];
  }

  const chapter = chapters.find((c) => c.id === chapterId);
  let unlockedNodeId: string | undefined;
  let unlockedChapterId: string | undefined;

  if (chapter) {
    const nextNode = getNextNode(chapter, nodeId);
    if (nextNode && !nextProgress.unlockedNodes.includes(nextNode.id)) {
      nextProgress.unlockedNodes.push(nextNode.id);
      unlockedNodeId = nextNode.id;
    }

    const chapterCompleted = chapter.nodes.every((node) => nextProgress.clearedNodes.includes(node.id));
    if (chapterCompleted) {
      const nextChapter = getNextChapter(chapters, chapterId);
      if (nextChapter && !nextProgress.unlockedChapters.includes(nextChapter.id)) {
        nextProgress.unlockedChapters.push(nextChapter.id);
        unlockedChapterId = nextChapter.id;
        const first = nextNode ? undefined : nextChapter.nodes[0];
        if (first && !nextProgress.unlockedNodes.includes(first.id)) {
          nextProgress.unlockedNodes.push(first.id);
          if (!unlockedNodeId) {
            unlockedNodeId = first.id;
          }
        }
      }
    }

    return {
      nextProgress,
      firstClear,
      unlockedNodeId,
      unlockedChapterId,
      chapterCompleted,
    };
  }

  return {
    nextProgress,
    firstClear,
    unlockedNodeId,
    unlockedChapterId,
    chapterCompleted: false,
  };
};


===================== [D:\download\LootingRPG\src\domains\monster\services\monsterCatalog.ts] =====================
import type { Monster } from '../../../shared/types/game';
import { BOSS_MONSTERS_DATA, NORMAL_MONSTERS_DATA } from '../config';
import i18n from '../../../i18n';

export const attachMonsterLore = (monster: Monster): Monster => {
  const backgroundKey = monster.background;
  const background = backgroundKey ? i18n.t(backgroundKey) : i18n.t('codex.backgroundFallback');
  const rawBoss = monster.monsterType === 'boss' ? monster.bossIdentity : undefined;
  const rawBossRecord = rawBoss as unknown as Record<string, unknown> | undefined;
  const introLineKey = typeof rawBossRecord?.introLineKey === 'string' ? rawBossRecord.introLineKey : undefined;
  const battleLogLineKey = typeof rawBossRecord?.battleLogLineKey === 'string' ? rawBossRecord.battleLogLineKey : undefined;
  const bossIdentity = rawBoss
    ? {
        ...rawBoss,
        introLine: i18n.t(introLineKey || rawBoss.introLine || ''),
        battleLogLine: i18n.t(battleLogLineKey || rawBoss.battleLogLine || ''),
        phasePrompts: {
          entering: rawBoss.phasePrompts?.entering ? i18n.t(rawBoss.phasePrompts.entering) : '',
          fighting: rawBoss.phasePrompts?.fighting ? i18n.t(rawBoss.phasePrompts.fighting) : '',
          dying: rawBoss.phasePrompts?.dying ? i18n.t(rawBoss.phasePrompts.dying) : '',
          dropping: rawBoss.phasePrompts?.dropping ? i18n.t(rawBoss.phasePrompts.dropping) : '',
        },
      }
    : undefined;

  return { ...monster, background, bossIdentity };
};

export const NORMAL_MONSTERS: Monster[] = NORMAL_MONSTERS_DATA.map((monster) => attachMonsterLore(monster));
export const BOSS_MONSTERS: Monster[] = BOSS_MONSTERS_DATA.map((monster) => attachMonsterLore(monster));


===================== [D:\download\LootingRPG\src\domains\monster\config.ts] =====================
import type { Monster, MonsterScalingProfile, MonsterTrait } from '../../shared/types/game';
import { type RawMonsterData, type RawBossData } from '../../config/game/monsterSchema';
import { getMapMonsterBaselineByLevel, resolveMonsterTemplateStats } from '../battle/services/monsterScaling';
import monsterConfig from '@data/config/game/monsters.json';
import { t } from 'i18next';

const { normal: rawNormal, boss: rawBoss } = monsterConfig;
const isBossData = (m: RawMonsterData | RawBossData): m is RawBossData => {
  return 'counterGoal' in m || 'bossIdentity' in m;
};

const localizeAdditionalFields = (
  monster: RawMonsterData | RawBossData,
): RawMonsterData | RawBossData => {
  const result = { ...monster } as typeof monster;
  if (isBossData(monster) && monster.counterGoal) {
    (result as RawBossData).counterGoal = {
      ...monster.counterGoal,
      title: monster.counterGoal.titleKey ? t(monster.counterGoal.titleKey) : monster.counterGoal.title,
      successText: monster.counterGoal.successTextKey
        ? t(monster.counterGoal.successTextKey)
        : t(monster.counterGoal.successText || ''),
      failText: monster.counterGoal.failTextKey
        ? t(monster.counterGoal.failTextKey)
        : t(monster.counterGoal.failText || ''),
    } as RawBossData['counterGoal'];
  }

  if (isBossData(monster) && monster.bossIdentity) {
    (result as RawBossData).bossIdentity = {
      ...monster.bossIdentity,
      introLine: monster.bossIdentity.introLineKey
        ? t(monster.bossIdentity.introLineKey)
        : monster.bossIdentity.introLine,
      battleLogLine: monster.bossIdentity.battleLogLineKey
        ? t(monster.bossIdentity.battleLogLineKey)
        : monster.bossIdentity.battleLogLine,
    } as RawBossData['bossIdentity'];
  }

  return result;
};

const TRAIT_TO_SKILL: Record<string, string> = {
  lifesteal: 'lifeSteal',
  double_attack: 'doubleStrike',
  thorns: 'thornAura',
  shield_on_start: 'shieldStart',
  rage_on_low_hp: 'rageMode',
};

const normalizeSkillSet = (
  monster: RawMonsterData | RawBossData,
): string[] => {
  if (Array.isArray(monster.skillSet)) return monster.skillSet;
  const traits: MonsterTrait[] = Array.isArray(monster.traits) ? monster.traits : [];
  const skills = traits.map((trait) => TRAIT_TO_SKILL[trait]).filter(Boolean);
  return Array.from(new Set(skills));
};

const toMonster = (monster: RawMonsterData | RawBossData): Monster => {
  const icons = [monster.icon as string];
  const monsterType = monster.monsterType;
  const baseStats = {
    hp:      Number(monster.baseStats?.hp),
    attack:  Number(monster.baseStats?.attack),
    defense: Number(monster.baseStats?.defense),
  };
  const scalingProfile = monster.scalingProfile as MonsterScalingProfile;
  const previewStats = resolveMonsterTemplateStats(
    { baseStats, scalingProfile },
    getMapMonsterBaselineByLevel(1),
  );
  return {
    ...(localizeAdditionalFields(monster) as Monster),
    icons,
    level: 1,
    monsterType,
    baseStats,
    scalingProfile,
    skillSet: normalizeSkillSet(monster),
    maxHp:   previewStats.maxHp,
    attack:  previewStats.attack,
    defense: previewStats.defense,
    name: t(`monster.${monster.id}`, { defaultValue: monster.id ?? 'unknown_monster' }),
    dropdict: Object.fromEntries( Object.entries(monster.dropdict ?? {})
      .map(([id, chance]) => [id, chance]))
  } as Monster;
};

export const NORMAL_MONSTERS_DATA: Monster[] = rawNormal.map(toMonster);
export const BOSS_MONSTERS_DATA:   Monster[] = rawBoss.map(toMonster);
const ALL_MONSTERS_DATA: Monster[] = [...NORMAL_MONSTERS_DATA, ...BOSS_MONSTERS_DATA];

export const getMonsterById = (id: string): Monster | undefined => {
  return ALL_MONSTERS_DATA.find((monster) => monster.id === id);
};


===================== [D:\download\LootingRPG\src\domains\player\model\combat.ts] =====================
import type { PlayerStats } from '../../../shared/types/game';

export interface CombatProfile {
  playerDamageMultiplier: number;
  monsterDamageMultiplier: number;
  statusProcMultiplier: number;
  turnBonus: number;
  bossSkillInterval: number;
}

export interface FinalPlayerCombatStats {
  maxHp: number;
  attack: number;
  defense: number;
  damageReduction: number;
  critRate: number;
  elementalBonus: number;
  lifestealRate: number;
  thornsRate: number;
  speed: number;
}

const clamp = (value: number, min: number, max: number): number => Math.max(min, Math.min(max, value));

const toNumber = (value: unknown): number => {
  if (typeof value === 'number') return value;
  if (typeof value === 'string') {
    const parsed = Number(value.replace('%', '').trim());
    return Number.isFinite(parsed) ? parsed : 0;
  }
  return 0;
};

const toSoftCappedPercent = (
  rawPercent: number,
  softCapPercent: number,
  hardCapPercent: number,
  growthRate: number,
): number => {
  const normalized = clamp(rawPercent, 0, 100);
  if (normalized <= softCapPercent) return normalized;

  const overflow = normalized - softCapPercent;
  const scaled = 1 - Math.exp(-growthRate * overflow);
  const softened = softCapPercent + (hardCapPercent - softCapPercent) * scaled;
  return clamp(softened, 0, hardCapPercent);
};

const defenseToReductionRate = (
  defenseValue: number,
  hardCapRate: number,
  growthRate: number,
): number => {
  const normalized = clamp(defenseValue, 0, 100);
  const rate = 1 - Math.exp(-growthRate * normalized);
  return clamp(rate, 0, hardCapRate);
};

const DEFAULT_COMBAT_PROFILE: CombatProfile = {
  playerDamageMultiplier: 1,
  monsterDamageMultiplier: 1,
  statusProcMultiplier: 1,
  turnBonus: 0,
  bossSkillInterval: 3,
};

export const getCombatProfile = (): CombatProfile => DEFAULT_COMBAT_PROFILE;

export const getFinalPlayerStats = (
  source: PlayerStats,
  encounterCount: number,
): FinalPlayerCombatStats => {
  const combatProfile = DEFAULT_COMBAT_PROFILE;
  const rawCritPercent = toNumber(source.critRate);
  const rawLifestealPercent = toNumber(source.lifesteal);
  const rawThornsPercent = toNumber(source.thorns);
  const rawDefense = Math.floor(source.defense);
  const levelFactor = 1 + (source.level - 1) * 0.08;
  const encounterFactor = 1 + Math.min(0.65, encounterCount * 0.003);

  const critPercent = toSoftCappedPercent(rawCritPercent, 50, 75, 0.08);
  const lifestealPercent = toSoftCappedPercent(rawLifestealPercent, 30, 45, 0.12);
  const thornsPercent = toSoftCappedPercent(rawThornsPercent, 20, 35, 0.1);
  const damageReduction = defenseToReductionRate(rawDefense, 0.68, 0.01);

  return {
    maxHp: Math.floor(source.hp * levelFactor * encounterFactor),
    attack: Math.floor(source.attack * levelFactor * encounterFactor * combatProfile.playerDamageMultiplier),
    defense: Math.floor(rawDefense * levelFactor * encounterFactor),
    damageReduction,
    critRate: clamp(critPercent / 100, 0, 0.8),
    elementalBonus: toNumber(source.elemental),
    lifestealRate: clamp(lifestealPercent / 100, 0, 0.45),
    thornsRate: clamp(thornsPercent / 100, 0, 0.35),
    speed: toNumber(source.attackSpeed),
  };
};

export const calculateFinalPlayerStats = (
  source: PlayerStats,
  encounterCount: number,
) => getFinalPlayerStats(source, encounterCount);


===================== [D:\download\LootingRPG\src\domains\player\services\derivedStats.ts] =====================
import type { GameState } from '../../../shared/types/game';

export interface DerivedStatItem {
  key: string;
  label: string;
  value: string;
  rawValue: number;
  icon: React.ReactNode;
  accent: string;
}

export function getDerivedStats(gameState: GameState): Omit<DerivedStatItem, 'icon'>[] {
  const ps = gameState.playerStats;
  type DerivedSourceKey = 'damageBonus' | 'lifesteal' | 'thorns' | 'elemental' | 'attackSpeed';

  const statSpecs: Array<{
    en: DerivedSourceKey;
    key: string;
    accent: string;
    fmt: (v: number) => string;
  }> = [
    { en: 'damageBonus', key: 'dmg', accent: 'border-orange-400/35 bg-orange-500/10 text-orange-200', fmt: (v) => `${v}%` },
    { en: 'lifesteal', key: 'ls', accent: 'border-red-400/35 bg-red-500/10 text-red-200', fmt: (v) => `${v}%` },
    { en: 'thorns', key: 'thorns', accent: 'border-emerald-400/35 bg-emerald-500/10 text-emerald-200', fmt: (v) => `${v}%` },
    { en: 'elemental', key: 'element', accent: 'border-cyan-400/35 bg-cyan-500/10 text-cyan-200', fmt: (v) => `+${v}` },
    { en: 'attackSpeed', key: 'spd', accent: 'border-red-400/35 bg-red-500/10 text-red-200', fmt: (v) => `+${v}` },
  ];

  return statSpecs.map(({ en, key, accent, fmt }) => {
    const raw = ps[en];
    return { key, label: en, value: fmt(raw), rawValue: raw, accent };
  });
}


===================== [D:\download\LootingRPG\src\domains\player\services\recalculatePlayerStats.ts] =====================
import { INITIAL_STATE } from '../../../config/game/gameConfig';
import { PLAYER_GROWTH } from '../../../config/game/progression';
import type { GameState } from '../../../shared/types/game';
import { getEquipmentTotals } from '../../inventory/services/equipmentTotals';

export const recalculatePlayerStats = (state: GameState): GameState => {
  const next = structuredClone(state);
  const level = next.playerStats.level;
  const baseAttack = INITIAL_STATE.playerStats.attack + (level - 1) * PLAYER_GROWTH.attackPerLevel;
  const baseHp = INITIAL_STATE.playerStats.hp + (level - 1) * PLAYER_GROWTH.hpPerLevel;
  const baseDefense = INITIAL_STATE.playerStats.defense + (level - 1) * PLAYER_GROWTH.defensePerLevel;
  const baseCritRate = Number(PLAYER_GROWTH.baseCritRate);

  let attackBonus = 0;
  let hpBonus = 0;
  let defenseBonus = 0;
  let critBonus = 0;
  let damageBonusPercent = 0;
  let lifestealPercent = 0;
  let thornsPercent = 0;
  let elementalBonus = 0;
  let attackSpeedBonus = 0;

  const { attributes, affixes } = getEquipmentTotals(next.currentEquipment);
  attackBonus += attributes.attack || 0;
  hpBonus += attributes.hp || 0;
  defenseBonus += attributes.defense || 0;
  critBonus += attributes.crit || 0;
  elementalBonus += attributes.elemental || 0;
  attackSpeedBonus += attributes.attackSpeed || 0;
  lifestealPercent += attributes.lifesteal || 0;

  critBonus += affixes.crit_chance || 0;
  lifestealPercent += affixes.lifesteal || 0;
  damageBonusPercent += affixes.damage_bonus || 0;
  thornsPercent += affixes.thorns || 0;
  hpBonus += affixes.hp_bonus || 0;

  const crit = Math.max(0, Math.round((baseCritRate + critBonus) * 10) / 10);
  const attackBeforeMultiplier = baseAttack + attackBonus;
  const finalAttack = Math.floor(attackBeforeMultiplier * (1 + Math.max(0, damageBonusPercent) / 100));

  next.playerStats.attack = finalAttack;
  next.playerStats.hp = Math.floor(baseHp + hpBonus);
  next.playerStats.defense = Math.max(0, Math.floor(baseDefense + defenseBonus));
  next.playerStats.critRate = `${crit}`;
  next.playerStats.damageBonus = Math.max(0, Math.round(damageBonusPercent));
  next.playerStats.lifesteal = Math.max(0, Math.round(lifestealPercent));
  next.playerStats.thorns = Math.max(0, Math.round(thornsPercent));
  next.playerStats.elemental = Math.max(0, Math.round(elementalBonus));
  next.playerStats.attackSpeed = Math.max(0, Math.round(attackSpeedBonus));

  return next;
};


===================== [D:\download\LootingRPG\src\hooks\game\useAutoSell.ts] =====================
import { useState, useCallback } from 'react';
import { createAutoSellQualityMap } from '../../domains/inventory/services/autoSell';

/**
 * 鑷姩鍞崠鍝佽川鏄犲皠绠＄悊
 */
export function useAutoSell() {
  const [autoSellQualities, setAutoSellQualities] = useState<Record<string, boolean>>(createAutoSellQualityMap());

  const toggleQuality = useCallback((quality: string) => {
    setAutoSellQualities((prev) => ({ ...prev, [quality]: !prev[quality] }));
  }, []);

  return {
    autoSellQualities,
    toggleQuality,
    setAutoSellQualities,
  } as const;
}


===================== [D:\download\LootingRPG\src\hooks\game\useBattleSession.ts] =====================
import { useCallback } from 'react';
import { runBattlePlayerAttack, runBattleRetreat, startBattleSession } from '../../domains/battle/services/session';
import { MAP_CHAPTERS } from '../../config/map/ChapterData';
import type { GameState, MapProgressState } from '../../shared/types/game';
import type { ActiveTab } from '../../shared/types/game';

interface UseBattleSessionParams {
  gameState: GameState;
  mapProgress: MapProgressState;
  setGameState: React.Dispatch<React.SetStateAction<GameState>>;
  setMapProgress: React.Dispatch<React.SetStateAction<MapProgressState>>;
  addLog: (msg: string) => void;
  setActiveTab: React.Dispatch<React.SetStateAction<ActiveTab>>;
  setFocusMapNode: React.Dispatch<React.SetStateAction<string | null>>;
}

/**
 * 鎻愪緵鎴樻枟鐩稿叧鐨勫揩鎹峰鐞嗗嚱鏁帮紝灏?domain 鏈嶅姟杩斿洖鐨勭粨鏋滃簲鐢ㄥ洖 React 鐘舵€佸苟璁板綍鏃ュ織
 */
export function useBattleSession({
  gameState,
  mapProgress,
  setGameState,
  setMapProgress,
  addLog,
  setActiveTab,
  setFocusMapNode,
}: UseBattleSessionParams) {
  const handleBattleAttack = useCallback(() => {
    const result = runBattlePlayerAttack(gameState, mapProgress, MAP_CHAPTERS);
    setGameState(result.nextGameState);
    setMapProgress(result.nextMapProgress);
    if (result.focusNodeId) {
      setFocusMapNode(result.focusNodeId);
      setActiveTab('map');
    }
    result.logs.forEach(addLog);
  }, [gameState, mapProgress, addLog, setGameState, setMapProgress, setFocusMapNode, setActiveTab]);

  const handleBattleRetreat = useCallback(() => {
    const result = runBattleRetreat(gameState, mapProgress, MAP_CHAPTERS);
    setGameState(result.nextGameState);
    setMapProgress(result.nextMapProgress);
    setActiveTab('map');
    if (result.focusNodeId) {
      setFocusMapNode(result.focusNodeId);
    }
    result.logs.forEach(addLog);
  }, [gameState, mapProgress, addLog, setGameState, setMapProgress, setFocusMapNode, setActiveTab]);

  const handleEnterMapNode = useCallback(
    (
      node: Parameters<typeof startBattleSession>[2],
      chapter: Parameters<typeof startBattleSession>[1],
    ) => {
      const battle = startBattleSession(gameState, chapter, node);
      setGameState(battle.nextGameState);
      battle.logs.forEach(addLog);
    },
    [gameState, addLog, setGameState],
  );

  return {
    handleBattleAttack,
    handleBattleRetreat,
    handleEnterMapNode,
  } as const;
}


===================== [D:\download\LootingRPG\src\hooks\game\useDebug.ts] =====================
import { useCallback } from 'react';
import { createCustomEquipment } from '../../domains/inventory/services/equipment';
import type { Equipment, GameState } from '../../shared/types/game';

interface UseDebugParams {
  gameState: GameState;
  setGameState: React.Dispatch<React.SetStateAction<GameState>>;
  addLog: (msg: string) => void;
}

/**
 * 鎻愪緵璋冭瘯宸ュ叿锛堢洰鍓嶄粎鏄坊鍔犺嚜瀹氫箟瑁呭锛?
 */
export function useDebug({ gameState, setGameState, addLog }: UseDebugParams) {
  const handleDebugAddItems = useCallback(
    (quality: string, slot: string, count: number, level?: number) => {
      const items: Equipment[] = [];
      const lv = Math.floor(level ?? gameState.playerStats.level);

      for (let i = 0; i < count; i += 1) {
        items.push(createCustomEquipment(quality, slot, lv));
      }

      setGameState((prev) => ({ ...prev, backpack: [...prev.backpack, ...items] }));
      addLog(`[Debug] Added ${count} ${quality} ${slot} items (Lv.${lv}) to backpack`);
    },
    [gameState.playerStats.level, setGameState, addLog],
  );

  return { handleDebugAddItems } as const;
}


===================== [D:\download\LootingRPG\src\hooks\game\useGameLogger.ts] =====================
import { useState, useCallback } from 'react';

/**
 * 绠€鍗曠殑鏃ュ織绠＄悊 hook锛岃礋璐ｇ淮鎶ゆ秷鎭垪琛ㄥ拰娣诲姞鏂版棩蹇椼€?
 * 鐢卞悇涓笟鍔?hook/缁勪欢璋冪敤锛岀敤浜庡湪鐣岄潰涓婃樉绀鸿繍琛屾椂淇℃伅銆?
 */
export function useGameLogger(initialLogs: string[] = ['[System] Game started.']) {
  const [logs, setLogs] = useState<string[]>(initialLogs);

  const addLog = useCallback((msg: string) => {
    if (!msg) return;
    const time = new Date().toLocaleTimeString();
    setLogs((prev) => [...prev.slice(-99), `[${time}] ${msg}`]);
  }, []);

  return {
    logs,
    setLogs,
    addLog,
  } as const;
}


===================== [D:\download\LootingRPG\src\hooks\game\useInventoryActions.ts] =====================
import { useCallback } from 'react';
import type { GameState } from '../../shared/types/game';
import { quickSellByQualityRange as quickSellBackpackByRange } from '../../domains/inventory/services/quickSell';
import { applyInventoryAction, type InventoryAction } from '../../domains/inventory/services/actions';
import { recalculatePlayerStats } from '../../domains/player/services/recalculatePlayerStats';

interface UseInventoryActionsParams {
  gameState: GameState;
  loading: boolean;
  setGameState: React.Dispatch<React.SetStateAction<GameState>>;
  setLoading: (loading: boolean) => void;
  addLog: (msg: string) => void;
  reportError: (err: unknown, context?: { action?: string }) => void;
}

export const useInventoryActions = ({
  setGameState,
  setLoading,
  addLog,
  reportError,
}: UseInventoryActionsParams) => {
  const quickSellByQualityRange = useCallback((minQuality: string, maxQuality: string) => {
    setGameState((prev) => {
      const result = quickSellBackpackByRange(prev, minQuality, maxQuality);
      addLog(result.message);
      return recalculatePlayerStats(result.nextState);
    });
  }, [setGameState, addLog]);

  const processAction = useCallback((action: InventoryAction) => {
    setLoading(true);

    setTimeout(() => {
      try {
        setGameState((prev) => {
          try {
            const result = applyInventoryAction(prev, action);
            result.logs.forEach(addLog);
            return recalculatePlayerStats(result.nextState);
          } catch (error) {
            reportError(error, { action: action.type });
            return prev;
          }
        });
      } finally {
        setLoading(false);
      }
    });
  }, [setLoading, setGameState, addLog, reportError]);

  return {
    quickSellByQualityRange,
    processAction,
  };
};


===================== [D:\download\LootingRPG\src\hooks\game\useMapProgress.ts] =====================
import { useState } from 'react';
import type { ActiveTab, MapProgressState } from '../../shared/types/game';
import { createInitialMapProgress } from '../../domains/map/services/progress';
import { MAP_CHAPTERS } from '../../config/map/ChapterData';

/**
 * 绠＄悊鍦板浘鐩稿叧鐨?UI 鐘舵€侊細杩涘害銆侀€変腑鏍囩鍙婄劍鐐硅妭鐐?
 */
export function useMapProgress() {
  const [mapProgress, setMapProgress] = useState<MapProgressState>(() =>
    createInitialMapProgress(MAP_CHAPTERS),
  );
  const [activeTab, setActiveTab] = useState<ActiveTab>('map');
  const [focusMapNode, setFocusMapNode] = useState<string | null>(null);

  return {
    mapProgress,
    setMapProgress,
    activeTab,
    setActiveTab,
    focusMapNode,
    setFocusMapNode,
  } as const;
}


===================== [D:\download\LootingRPG\src\hooks\profile\useProfileSave.ts] =====================
import type { GameState, MapProgressState, SavePayload, SaveProfile } from '../../shared/types/game';
import { createInitialMapProgress, normalizeMapProgress } from '../../domains/map/services/progress';
import { ACTIVE_PROFILE_KEY, PROFILE_INDEX_KEY, STORAGE_KEY } from '../../config/runtime/storage';
import { createFreshInitialState, normalizeGameState } from '../../app/state';
import { createAutoSellQualityMap } from '../../domains/inventory/services/autoSell';
import { recalculatePlayerStats } from '../../domains/player/services/recalculatePlayerStats';
import { MAP_CHAPTERS } from '../../config/map/ChapterData';
import { useState, useEffect } from 'react';
/// 涓汉瀛樻。绠＄悊閫昏緫锛屽寘鍚垱寤?鍔犺浇/淇濆瓨/鍒犻櫎瀛樻。锛屼互鍙婂鍏ュ鍑哄姛鑳?interface UseProfileSaveParams {
  gameState: GameState; logs: string[]; autoSellQualities: Record<string, boolean>; mapProgress: MapProgressState;
  setGameState: React.Dispatch<React.SetStateAction<GameState>>;
  setLogs:      React.Dispatch<React.SetStateAction<string[]>>;
  setAutoSellQualities: React.Dispatch<React.SetStateAction<Record<string, boolean>>>;
  setMapProgress:  React.Dispatch<React.SetStateAction<MapProgressState>>;
  addLog: (msg: string) => void;
}
/// 瀛樻。閿悕鐢熸垚鍑芥暟锛屽熀浜?profileId 鐢熸垚瀵瑰簲鐨?localStorage 閿悕
const getProfileSaveKey = (profileId: string) => `${STORAGE_KEY}_${profileId}`;
/// 涓汉瀛樻。绠＄悊 Hook锛屾彁渚涘瓨妗ｅ垪琛ㄣ€佸綋鍓嶆椿璺冨瓨妗?ID銆佽璇佺姸鎬侊紝浠ュ強鐧诲綍/鍒涘缓/鍒犻櫎/瀵煎叆/瀵煎嚭瀛樻。鐨勫鐞嗗嚱鏁?export function useProfileSave({
  gameState, logs, autoSellQualities, mapProgress,
  setGameState, setLogs, setAutoSellQualities, setMapProgress, addLog,
}: UseProfileSaveParams) {
  const [profiles, setProfiles] = useState<SaveProfile[]>([]);
  const [activeProfileId, setActiveProfileId] = useState<string | null>(null);
  const [isAuthenticated, setIsAuthenticated] = useState(false);

  const handleLogout = () => {
    setIsAuthenticated(false);
    setActiveProfileId(null);
  };
  /// 鍒濆鍔犺浇锛氫粠 localStorage 璇诲彇瀛樻。鍒楄〃鍜屾渶鍚庢椿璺冪殑瀛樻。 ID锛屽皾璇曞姞杞藉搴斿瓨妗?  useEffect(() => {
    const profileText = localStorage.getItem(PROFILE_INDEX_KEY);
    const lastProfileId = localStorage.getItem(ACTIVE_PROFILE_KEY);
    if (profileText) {
      try {
        const parsed = JSON.parse(profileText) as SaveProfile[];
        const nextProfiles = Array.isArray(parsed) ? parsed : [];
        setProfiles(nextProfiles);

        if (lastProfileId && nextProfiles.some((profile) => profile.id === lastProfileId)) {
          setActiveProfileId(lastProfileId);
          setIsAuthenticated(true);
          loadProfile(lastProfileId);
        }
      } catch {
        setProfiles([]);
      }
    }
  }, []);

  useEffect(() => {
    if (!isAuthenticated || !activeProfileId) return;

    const profileKey = getProfileSaveKey(activeProfileId);
    const profileExists = Boolean(localStorage.getItem(profileKey));
    if (!profileExists) {
      const freshGameState = createFreshInitialState();
      const freshLogs = ['[System] Local save cache cleared. Rebuilt with latest initial state.'];
      const freshMapProgress = createInitialMapProgress(MAP_CHAPTERS);
      const freshAutoSell = createAutoSellQualityMap();

      setGameState(freshGameState);
      setLogs(freshLogs);
      setMapProgress(freshMapProgress);
      setAutoSellQualities(freshAutoSell);

      localStorage.setItem(
        profileKey,
        JSON.stringify({
          gameState: freshGameState,
          logs: freshLogs,
          autoSellQualities: freshAutoSell,
          mapProgress: freshMapProgress,
        } satisfies SavePayload),
      );

      setProfiles((prev) => {
        const next = prev.map((profile) =>
          profile.id === activeProfileId ? { ...profile, updatedAt: Date.now() } : profile,
        );
        localStorage.setItem(PROFILE_INDEX_KEY, JSON.stringify(next));
        return next;
      });

      addLog('Local cache was empty. Rebuilt save with latest initial state.');
      return;
    }

    const payload: SavePayload = { gameState, logs, autoSellQualities, mapProgress };
    localStorage.setItem(getProfileSaveKey(activeProfileId), JSON.stringify(payload));

    setProfiles((prev) => {
      const next = prev.map((profile) =>
        profile.id === activeProfileId ? { ...profile, updatedAt: Date.now() } : profile,
      );
      localStorage.setItem(PROFILE_INDEX_KEY, JSON.stringify(next));
      return next;
    });
  }, [activeProfileId, autoSellQualities, gameState, isAuthenticated, logs, mapProgress]);

  const convertAutoSell = (orig: Record<string, boolean> = {}) => {
    const base = createAutoSellQualityMap();
    Object.entries(orig).forEach(([k, v]) => {
      if (k in base) {
        base[k] = v;
      }
    });
    return base;
  };

  const loadProfile = (profileId: string) => {
    const payloadText = localStorage.getItem(getProfileSaveKey(profileId));
    if (!payloadText) {
      setGameState(createFreshInitialState());
      setLogs(['[System] New player save created.']);
      setAutoSellQualities(createAutoSellQualityMap());
      setMapProgress(createInitialMapProgress(MAP_CHAPTERS));
      return;
    }

    try {
      const payload = JSON.parse(payloadText) as SavePayload;
      setGameState(recalculatePlayerStats(normalizeGameState(payload.gameState)));
      setLogs(payload.logs?.length ? payload.logs : ['[System] Save loaded.']);
      setAutoSellQualities(convertAutoSell(payload.autoSellQualities));
      setMapProgress(normalizeMapProgress(payload.mapProgress, MAP_CHAPTERS));
    } catch {
      setGameState(createFreshInitialState());
      setLogs(['[System] Save data corrupted. Reset to a fresh save.']);
      setAutoSellQualities(createAutoSellQualityMap());
      setMapProgress(createInitialMapProgress(MAP_CHAPTERS));
    }
  };


  const handleLogin = (profileId: string) => {
    setActiveProfileId(profileId);
    setIsAuthenticated(true);
    loadProfile(profileId);
    localStorage.setItem(ACTIVE_PROFILE_KEY, profileId);
  };

  const handleCreateProfile = (name: string) => {
    const id = `profile_${Date.now()}`;
    const profile: SaveProfile = {
      id,
      name,
      updatedAt: Date.now(),
    };

    setProfiles((prev) => {
      const next = [profile, ...prev];
      localStorage.setItem(PROFILE_INDEX_KEY, JSON.stringify(next));
      return next;
    });

    localStorage.setItem(
      getProfileSaveKey(id),
      JSON.stringify({
        gameState: createFreshInitialState(),
        logs: ['[System] New player save created.'],
        mapProgress: createInitialMapProgress(MAP_CHAPTERS),
      } satisfies SavePayload),
    );
    handleLogin(id);
  };

  const handleDeleteProfile = (profileId: string) => {
    setProfiles((prev) => {
      const next = prev.filter((profile) => profile.id !== profileId);
      localStorage.setItem(PROFILE_INDEX_KEY, JSON.stringify(next));
      return next;
    });

    localStorage.removeItem(getProfileSaveKey(profileId));

    if (activeProfileId === profileId) {
      setIsAuthenticated(false);
      setActiveProfileId(null);
      setGameState(createFreshInitialState());
      setLogs(['[System] Please sign in to a player save.']);
      setAutoSellQualities(createAutoSellQualityMap());
      setMapProgress(createInitialMapProgress(MAP_CHAPTERS));
    }
  };

  const handleExportSave = () => {
    if (!activeProfileId) return;
    const payload: SavePayload = {
      gameState,
      logs,
      autoSellQualities,
      mapProgress,
    };

    const data = JSON.stringify(payload, null, 2);
    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `LootingRPG_Save.json`;
    link.click();
    URL.revokeObjectURL(url);
    addLog('Save exported as JSON file.');
  };

  const handleImportSave = () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'application/json';
    input.onchange = async (event) => {
      const file = (event.target as HTMLInputElement).files?.[0];
      if (!file) return;

      try {
        const text = await file.text();
        const parsed = JSON.parse(text) as SavePayload;

        const isRecord = (value: unknown): value is Record<string, unknown> => {
          return typeof value === 'object' && value !== null;
        };

        if (!isRecord(parsed) || !('gameState' in parsed)) {
          throw new Error('Invalid save payload');
        }

        const payload = parsed;
        loadProfile('');
        setGameState(recalculatePlayerStats(normalizeGameState(payload.gameState)));
        setLogs(payload.logs?.length ? payload.logs : ['[System] Save imported successfully.']);
        setAutoSellQualities(payload.autoSellQualities ?? createAutoSellQualityMap());
        setMapProgress(normalizeMapProgress(payload.mapProgress, MAP_CHAPTERS));
        addLog('Save imported from JSON file.');
      } catch {
        addLog('Import failed: invalid JSON payload.');
      }
    };
    input.click();
  };

  return {
    profiles,
    activeProfileId,
    isAuthenticated,
    handleLogin, handleCreateProfile, handleDeleteProfile, handleExportSave, handleImportSave, loadProfile, handleLogout,
  };
}


===================== [D:\download\LootingRPG\src\infra\i18n\labels.ts] =====================
import { t } from 'i18next';

export const getQualityLabel = (qualityKey: string): string => t(`quality.${qualityKey}`);
export const getSlotLabel = (slotKey: string): string => t(`slot.${slotKey}`);
export const getStatLabel = (statKey: string): string => t(`stat.${statKey}`);


===================== [D:\download\LootingRPG\src\shared\types\assets.d.ts] =====================
declare module '*.csv?raw' {
  const content: string;
  export default content;
}


===================== [D:\download\LootingRPG\src\shared\types\game.ts] =====================
import type { EntityStats } from '../../config/game/monsterSchema';
import type { BattleUnitInstance } from '../../types/battle/BattleUnit';
export type { Monster } from '../../config/game/monsterSchema';
export type { MonsterTrait, MonsterBaseStats, MonsterScalingProfile, ThreatType, BossIdentity, BossCounterGoal, CounterStatKey, EntityStats, ScalingProfileStats } from '../../config/game/monsterSchema';

export type BattlePhase =
  | 'player_input'
  | 'resolving'
  | 'enemy_turn'
  | 'finished';

export interface BattleAction {
  id: string;
  type: 'basic_attack' | 'skill' | 'passive';
  sourceId: string;
  targetIds: string[];
  payload?: Record<string, unknown>;
}

export type ApplyDamageEvent = {
  type: 'apply_damage';
  sourceId: string;
  targetId: string;
  amount: number;
};

export type ApplyHealEvent = {
  type: 'apply_heal';
  sourceId: string;
  targetId: string;
  amount: number;
};

export type UnitDiedEvent = {
  type: 'unit_died';
  unitId: string;
};

export type TurnEndEvent = {
  type: 'turn_end';
};

export type BattleEvent = ApplyDamageEvent | ApplyHealEvent | UnitDiedEvent | TurnEndEvent;

export interface PlayerStats extends EntityStats     {
  level: number;
  xp: number;
  critRate: string;
  damageBonus: number;
  lifesteal: number;
  thorns: number;
  elemental: number;
  attackSpeed: number;
  gold: number;
}
export type EquipmentAffix = 'crit_chance' | 'lifesteal' | 'damage_bonus' | 'thorns' | 'hp_bonus';
export interface EquipmentAffixValue {
  type: EquipmentAffix;
  value: number;
}
export interface Equipment {
  id: string;
  icon: string;
  level: number;
  name: string;
  quality: string;
  slot: string;
  attributes: Record<string, number>;
  special?: string;
  affixes: EquipmentAffixValue[];
  enhancementLevel: number;
  mainStat: string;
  equipped: boolean;
  localeNames?: {
    zh?: string;
    en?: string;
  };
}

export type BattleSessionStatus = 'fighting' | 'victory' | 'defeat';

export interface BattleSession {
  id: string;            // 鍞竴鏍囪瘑绗︼紝鏍煎紡涓?"battle_timestamp"
  chapterId: string;     // 鎵€灞炵珷鑺侷D
  chapterName: string;   // 鎵€灞炵珷鑺傚悕绉帮紙鍐椾綑瀛楁锛屼究浜庡揩閫熻闂級
  nodeId: string;        // 鎵€灞炶妭鐐笽D
  nodeName: string;      // 鎵€灞炶妭鐐瑰悕绉帮紙鍐椾綑瀛楁锛屼究浜庡揩閫熻闂級
  encounterType: string; // 閬亣绫诲瀷锛堜緥濡?"normal"銆?elite"銆?boss"锛夛紝鐢ㄤ簬鍖哄垎涓嶅悓鐨勬垬鏂楀満鏅拰瑙勫垯
  turn: number;          // 褰撳墠鍥炲悎鏁帮紝浠?寮€濮嬮€掑
  phase: BattlePhase;
  player: BattleUnitInstance;
  enemies: BattleUnitInstance[];
  waveOrder: string[];         // 娉㈡椤哄簭鍒楄〃锛岃褰曞綋鍓嶆垬鏂椾腑鏁屼汉鎵€灞炵殑娉㈡椤哄簭锛屼究浜庡湪鎴樻枟鏃ュ織鍜岀晫闈笂鏄剧ず褰撳墠娉㈡鐘舵€?  currentWaveIndex: number;    // 褰撳墠娉㈡绱㈠紩锛屾寚绀虹帺瀹舵鍦ㄩ潰瀵瑰摢涓尝娆＄殑鏁屼汉锛屾垬鏂楄繃绋嬩腑浼氭牴鎹晫浜鸿鍑昏触鐨勬儏鍐佃繘琛屾洿鏂?  status: BattleSessionStatus; // 鎴樻枟鐘舵€侊紝鎸囩ず褰撳墠鎴樻枟鏄繘琛屼腑銆佽儨鍒┿€佸け璐ヨ繕鏄挙閫€锛屾垬鏂楄繃绋嬩腑浼氭牴鎹帺瀹跺拰鏁屼汉鐨勭姸鎬佽繘琛屾洿鏂?  events: BattleEvent[];
  logs: string[];              // 鎴樻枟鏃ュ織锛岃褰曟垬鏂楄繃绋嬩腑鍙戠敓鐨勪簨浠跺拰鎿嶄綔锛屼究浜庡洖鏀惧拰璋冭瘯
}

export interface BattleResult {
  sessionId: string;
  chapterId: string;
  nodeId: string;
  won: boolean;
  turns: number;
  xpGained: number;
  goldGained: number;
  finishedAt: number;
}
export interface BattleState {
  activeSession: BattleSession | null;
  history: BattleResult[];
}
export interface GameState {
  playerStats: PlayerStats;
  droppedEquipment: Equipment | null;
  backpack: Equipment[];
  systemMessage: string;
  currentEquipment: Record<string, Equipment | null>;
  pityCounts: {
    legendary: number;
    mythic: number;
  };
  battle: BattleState;
}
export type ActiveTab = 'map' | 'inventory' | 'forge' | 'codex';
export interface SaveProfile { id: string; name: string; updatedAt: number}

export interface MapProgressState {
  selectedChapterId: string;
  unlockedChapters: string[];
  unlockedNodes: string[];
  clearedNodes: string[];
  failedAttempts: Record<string, number>;
}

export interface SavePayload {
  gameState: GameState;
  logs: string[];
  autoSellQualities?: Record<string, boolean>;
  mapProgress?: MapProgressState;
}


===================== [D:\download\LootingRPG\src\types\battle\BattleUnit.ts] =====================
export interface BaseStats {
  hp: number
  attack: number
  defense: number
}

export interface BattleDerivedStats {
  damageReduction: number
  critRate?: number
  lifestealRate?: number
  thornsRate?: number
  elementalBonus?: number
}

export type Faction = 'player' | 'monster'

export interface BattleUnitInstance {
  id: string
  name: string
  faction: Faction
  level: number
  baseStats: BaseStats
  currentHp: number
  derivedStats: BattleDerivedStats
  skills: string[]
  passives: string[]
  elements: string[]
  tags: string[]
  meta?: Record<string, unknown>
}

export interface BattleUnitSchema {
  id: string
  name: string
  faction: Faction
  baseStats: BaseStats
  skills: string[]
  passives?: string[]
  elements?: string[]
  tags?: string[]
  aiProfile?: string
  derivedStats?: BattleDerivedStats
  meta?: Record<string, unknown>
}


===================== [D:\download\LootingRPG\src\types\game.ts] =====================
export * from '../shared/types/game';


===================== [D:\download\LootingRPG\src\App.tsx] =====================
import { ThemeProvider } from './config/themes/ThemeContext';
import { AppShell } from './app/AppShell';
import { GameProvider } from './app/GameContext';

export default function App() {
  return (
    <ThemeProvider>
      <GameProvider>
        <AppShell />
      </GameProvider>
    </ThemeProvider>
  );
}


===================== [D:\download\LootingRPG\src\i18n.ts] =====================
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';
import zhTranslation from '@data/locales/zh/translation.json';
import enTranslation from '@data/locales/en/translation.json';
const resources = {
  zh: { translation: zhTranslation },
  en: { translation: enTranslation },
};
i18n.use(initReactI18next).init({
  resources,
  lng: 'zh',
  fallbackLng: 'en',
  interpolation: {
    escapeValue: false,
  },
});

export default i18n;


===================== [D:\download\LootingRPG\src\main.tsx] =====================
import {StrictMode} from 'react';
import {createRoot} from 'react-dom/client';
import './i18n';  // initialize internationalization before app modules
import App from './App.tsx';
import './index.css';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
);


===================== [D:\download\LootingRPG\assets\data\config\game\equipment.json] =====================
{
  "statPool": [
    "attack", "hp", "defense",
    "crit", "critDamage",
    "attackSpeed", "lifesteal", "elemental"
  ],
  "slots": [
    { "id": "weapon", "name": "Weapon", "icon": "sword" },
    { "id": "helmet", "name": "Helmet", "icon": "user" },
    { "id": "armor", "name": "Armor", "icon": "shield" },
    { "id": "ring", "name": "Ring", "icon": "star" },
    { "id": "necklace", "name": "Necklace", "icon": "gem" },
    { "id": "boots", "name": "Boots", "icon": "package" }
  ],
  "qualities": [
    "common",
    "uncommon",
    "rare",
    "epic",
    "legendary",
    "mythic"
  ],
  "qualityConfig": {
    "common":   {"stats": 1,"price": 50,   "color": "quality-common",   "iconName": "shield" },
    "uncommon": {"stats": 2,"price": 100,  "color": "quality-uncommon", "iconName": "zap" },
    "rare":     {"stats": 3,"price": 300,  "color": "quality-rare",     "iconName": "gem" },
    "epic":     {"stats": 4,"price": 1000, "color": "quality-epic",     "iconName": "hexagon" },
    "legendary":{"stats": 5,"price": 5000, "color": "quality-legendary","iconName": "crown" },
    "mythic":   {"stats": 6,"price": 20000,"color": "quality-mythic",   "iconName": "star" }
  },
  "affixScaling": {
    "crit_chance": [1, 2, 3, 4, 6, 8],
    "lifesteal": [1, 2, 3, 4, 5, 7],
    "damage_bonus": [2, 4, 6, 8, 12, 18],
    "thorns": [2, 4, 6, 8, 12, 18],
    "hp_bonus": [8, 20, 32, 48, 80, 120]
  },
  "affixCountByQuality": [0, 1, 1, 2, 3, 4],
  "baseMultiplierByQuality": [1.0, 1.15, 1.35, 1.6, 2.0, 2.6],
  "enchantConfig": {
    "enchantBaseCost": 500,
    "rerollBaseCost": 300,
    "lockCost": 200,
    "enchantScaleByQuality": [0.05, 0.06, 0.07, 0.08, 0.10, 0.12],
    "enchantCostMultiplierByQuality": [1.0, 1.0, 1.05, 1.1, 1.25, 1.5]
  }
}


===================== [D:\download\LootingRPG\assets\data\config\game\equipments.csv] =====================
id,slot,quality,icon,attributes,affixes,levelOffset,scalePerLevel,name_zh,name_en,special_zh,special_en
u001_ashen_blade,weapon,legendary,鈿旓笍,"{""attack"":120,""attackSpeed"":12}","[{""type"":""damage_bonus"",""value"":18}]",equipment.0,0.035,鐏肩伆涔嬪垉,Ashen Blade,瀵逛骸鐏典激瀹虫彁鍗?25%,Deal +25% damage to undead
u002_warden_aegis,armor,mythic,馃洝锔?"{""hp"":360,""defense"":85}","[{""type"":""thorns"",""value"":22},{""type"":""hp_bonus"",""value"":120}]",equipment.1,0.04,姘稿澹佸瀿,Eternal Bulwark,鐢熷懡浣庝簬 30% 鏃惰幏寰楁姢鐩?Gain a shield when HP is below 30%
u003_skytrace_boots,boots,epic,馃憿,"{""attackSpeed"":26,""defense"":30}","[{""type"":""crit_chance"",""value"":8}]",equipment.0,0.02,閫愰鎴橀澊,Skytrace Boots,绉诲姩涓庡嚭鎵嬫洿杩呮嵎,Move and strike faster
u004_abyss_eye_ring,ring,mythic,馃拲,"{""elemental"":48,""attack"":72}","[{""type"":""lifesteal"",""value"":12},{""type"":""damage_bonus"",""value"":15}]",equipment.0,0.03,娓婄灣鎸囩幆,Abyss Eye Ring,鍏冪礌浼ゅ鎻愬崌骞堕檮甯﹀惛琛€,Boost elemental damage with lifesteal
u005_scout_medal,necklace,rare,馃摽,"{""attack"":38,""hp"":70}","[{""type"":""hp_bonus"",""value"":20}]",equipment.0,0.015,渚︽煡鍕嬬珷,Scout Medal,鏅€氭帰绱㈢ǔ瀹氬鐩?Stable bonus for regular exploration


===================== [D:\download\LootingRPG\assets\data\config\game\monsterConfig.json] =====================
{
  "monsterTypes": [ "normal", "elite", "boss" ],
  "scalingProfileStats": {
    "normal":  { "hp": 1.0, "attack": 1.0, "defense": 1.0 },
    "tank":    { "hp": 1.4, "attack": 0.8, "defense": 1.2 },
    "glass":   { "hp": 0.7, "attack": 1.5, "defense": 0.6 },
    "bruiser": { "hp": 1.2, "attack": 1.2, "defense": 0.9 },
    "striker": { "hp": 0.9, "attack": 1.3, "defense": 0.8 },
    "boss":    { "hp": 1.8, "attack": 1.3, "defense": 1.25 }
  },
  "threatTypes":  [ "burst_punish", "sustain_pressure", "tank_breaker", "attrition" ],
  "counterStatKeys": [ "attack" , "defense" , "hp" , "elemental" , "lifesteal" , "thorns" , "attackSpeed"],
  "traits": [ "thorns" , "lifesteal" , "double_attack" , "shield_on_start" , "rage_on_low_hp"],
  "strategy": {
    "tag": [ "offense" , "defense" , "sustain"],
    "traitScoreMap": {
      "thorns": { "defense": 2, "sustain": 1 },
      "lifesteal": { "offense": 1, "sustain": 2 },
      "double_attack": { "defense": 1, "offense": 2 },
      "shield_on_start": { "offense": 2, "defense": 1 },
      "rage_on_low_hp": { "defense": 2, "sustain": 1 }
    },
    "counterGoalScoreMap": {
      "attack": "offense",
      "elemental": "offense",
      "attackSpeed": "offense",
      "defense": "defense",
      "hp": "defense",
      "lifesteal": "sustain",
      "thorns": "sustain"
    }
  }
}


===================== [D:\download\LootingRPG\assets\data\config\game\monsters.json] =====================
{
  "normal": [
    {
    "id": "forest_slime",
    "name": "Slime",
    "faction": "monster",
    "baseStats": {
      "hp": 100,
      "attack": 12,
      "defense": 6,
      "speed": 8
    },
    "growthProfile": "normal",
    "elements": ["poison"],
    "tags": ["slime"],
    "positionPreference": "front",
    "skills": ["basic_attack"],
    "passives": [],
    "aiProfile": "simple_aggressive",
    "lootTable": "slime_loot_t1",
    "difficultyWeight": 1,
    
"icon": "馃煝",
"background": "monster.background.forest_slime",
"monsterType": "normal",
"threatTypes": ["attrition"],
"traits": ["lifesteal"],
"scalingProfile": "tank"
    },
    {
      "id": "skeleton",
      "icon": "馃拃",
      "background": "monster.background.skeleton",
      "monsterType": "normal",
      "threatTypes": [ "tank_breaker" ],
      "dropdict": {
        "u001_ashen_blade": 1
      },
      "baseStats": { 
       "hp": 1.08, 
       "attack": 1, 
       "defense": 1
      },
      "scalingProfile": "normal",
      "skillSet": []
    },
    {
      "id": "goblin",
      "icon": "馃懞",
      "background": "monster.background.goblin",
      "monsterType": "normal",
      "threatTypes": [ "burst_punish" ],
      "dropdict": { "u001_ashen_blade": 1 },
      "baseStats": {
        "hp": 0.92,
        "attack": 1.12,
        "defense": 0.88
      },
      "scalingProfile": "normal",
      "skillSet": []
    },
    {
      "id": "wolf",
      "icon": "馃惡",
      "background": "monster.background.wolf",
      "monsterType": "normal",
      "threatTypes": ["sustain_pressure"],
      "dropdict": { "u001_ashen_blade": 1 },
      "baseStats": {
        "hp": 1.0,
        "attack": 1.05,
        "defense": 0.95
      },
      "scalingProfile": "normal",
      "skillSet": []
    }
  ],
  "boss": [
    {
      "id": "abyss_demon",
      "icon": "馃懝",
      "background": "monster.background.abyss_demon",
      "bossIdentity": {
        "theme": "abyss",
        "introLineKey": "boss.abyss_demon.introLine",
        "battleLogLineKey": "boss.abyss_demon.battleLogLine",
        "phasePrompts": {
          "entering": "boss.abyss_demon.phase.entering",
          "fighting": "boss.abyss_demon.phase.fighting",
          "dying": "boss.abyss_demon.phase.dying",
          "dropping": "boss.abyss_demon.phase.dropping"
        }
      },
      "monsterType": "boss",
      "traits": [
        "rage_on_low_hp"
      ],
      "threatTypes": [
        "sustain_pressure",
        "attrition"
      ],
      "counterGoal": {
        "titleKey": "counter.abyss_demon",
        "stat": "defense",
        "threshold": 110,
        "successText": "counterSuccess.abyss_demon",
        "failText": "counterFail.abyss_demon"
      },
      "baseStats": {
        "hp": 3.58,
        "attack": 2.44,
        "defense": 2.86
      },
      "scalingProfile": "boss",
      "skillSet": [
        "rageMode"
      ]
    }
  ]
}



===================== [D:\download\LootingRPG\assets\data\config\map\ChapterData.json] =====================
{
  "MAP_CHAPTERS": [
    {
      "id": "chapter-1",
      "name": "鏂版墜鏋楀湴",
      "levelRange": "Lv.1-10",
      "theme": "鏋楀湴",
      "nodes": [
        {
          "id": "1-1", "name": "渚︽煡钀ュ湴", "recommendedLevel": 2, "encounterType": "normal", "firstClearRewardGold": 120,
          "waves": [
            { "id": "1-1-a", "label": "绗竴娉?, "monsters": [ { "monsterId": "forest_slime" }, { "monsterId": "forest_slime" } ] },
            { "id": "1-1-b", "label": "绗簩娉?, "monsters": [ { "monsterId": "forest_slime" }, { "monsterId": "forest_slime" }, { "monsterId": "forest_slime" }, { "monsterId": "forest_slime" } ] },
            { "id": "1-1-c", "label": "绗笁娉?, "monsters": [ { "monsterId": "forest_slime" }, { "monsterId": "forest_slime" } ] },
            { "id": "1-1-d", "label": "绗洓娉?, "monsters": [ { "monsterId": "forest_slime" }, { "monsterId": "forest_slime" }, { "monsterId": "forest_slime" } ] },
            { "id": "1-1-e", "label": "绗簲娉?, "monsters": [ { "monsterId": "forest_slime" }, { "monsterId": "forest_slime" }, { "monsterId": "forest_slime" } ] }
          ]
        },
        { "id": "1-2", "name": "鑻旂煶宄¤胺", "recommendedLevel": 4, "encounterType": "elite", "firstClearRewardGold": 160 },
        { "id": "1-3", "name": "鏋楀湴灏忓緞", "recommendedLevel": 6, "encounterType": "normal", "firstClearRewardGold": 180 },
        { "id": "1-4", "name": "鑽掓爲鍩哄湴", "recommendedLevel": 8, "encounterType": "elite", "firstClearRewardGold": 200 },
        { "id": "1-5", "name": "鍙や簳涔嬬煶", "recommendedLevel": 9, "encounterType": "elite", "firstClearRewardGold": 220 },
        { "id": "1-6", "name": "鍊掑鏂ˉ", "recommendedLevel": 10, "encounterType": "normal", "firstClearRewardGold": 240 },
        { "id": "1-7", "name": "瀵嗘灄绁潧", "recommendedLevel": 11, "encounterType": "elite", "firstClearRewardGold": 260 },
        { "id": "1-8", "name": "铔吔娲炵┐", "recommendedLevel": 12, "encounterType": "normal", "firstClearRewardGold": 280 },
        { "id": "1-9", "name": "椋庢毚鑽夊満", "recommendedLevel": 13, "encounterType": "elite", "firstClearRewardGold": 300 },
        { "id": "1-10", "name": "鏋楀湴棣栭宸㈢┐", "recommendedLevel": 14, "encounterType": "boss", "firstClearRewardGold": 400 }
      ]
    },
    {
      "id": "chapter-2",
      "name": "搴熷純鍦扮墷",
      "levelRange": "Lv.10-20",
      "theme": "鍦扮墷",
      "nodes": [
        { "id": "2-1", "name": "鐮寸鍥炲粖", "recommendedLevel": 12, "encounterType": "normal", "firstClearRewardGold": 160 },
        { "id": "2-2", "name": "骞藉奖鐗㈠", "recommendedLevel": 14, "encounterType": "elite", "firstClearRewardGold": 200 },
        { "id": "2-3", "name": "闅愬尶灏忕獰", "recommendedLevel": 16, "encounterType": "normal", "firstClearRewardGold": 220 },
        { "id": "2-4", "name": "婕嗛粦浠撳簱", "recommendedLevel": 18, "encounterType": "elite", "firstClearRewardGold": 240 },
        { "id": "2-5", "name": "姣掓皵鍥氬", "recommendedLevel": 19, "encounterType": "elite", "firstClearRewardGold": 260 },
        { "id": "2-6", "name": "鏂鏋㈢航", "recommendedLevel": 20, "encounterType": "normal", "firstClearRewardGold": 280 },
        { "id": "2-7", "name": "閾侀摼鐗㈤棬", "recommendedLevel": 22, "encounterType": "elite", "firstClearRewardGold": 300 },
        { "id": "2-8", "name": "鐩戠嫳娣辨笂", "recommendedLevel": 24, "encounterType": "normal", "firstClearRewardGold": 320 },
        { "id": "2-9", "name": "浜＄伒鍥氱", "recommendedLevel": 26, "encounterType": "elite", "firstClearRewardGold": 340 },
        { "id": "2-10", "name": "鍦扮墷棰嗕富鐜嬪骇", "recommendedLevel": 28, "encounterType": "boss", "firstClearRewardGold": 400 }
      ]
    },
    {
      "id": "chapter-3",
      "name": "鐔斿博娣辨笂",
      "levelRange": "Lv.20-35",
      "theme": "鐏北",
      "nodes": [
        { "id": "3-1", "name": "鐔旂伀", "recommendedLevel": 23, "encounterType": "normal", "firstClearRewardGold": 220 },
        { "id": "3-2", "name": "鐏扮儸绁潧", "recommendedLevel": 25, "encounterType": "elite", "firstClearRewardGold": 260 },
        { "id": "3-3", "name": "鐐界儹灏忓緞", "recommendedLevel": 27, "encounterType": "normal", "firstClearRewardGold": 280 },
        { "id": "3-4", "name": "鐔斿博婕╂丁", "recommendedLevel": 29, "encounterType": "elite", "firstClearRewardGold": 300 },
        { "id": "3-5", "name": "鐔斿博娲炵┐", "recommendedLevel": 30, "encounterType": "elite", "firstClearRewardGold": 320 },
        { "id": "3-6", "name": "鐐界劙鏂眰", "recommendedLevel": 32, "encounterType": "normal", "firstClearRewardGold": 340 },
        { "id": "3-7", "name": "鐔斿博绁潧", "recommendedLevel": 33, "encounterType": "elite", "firstClearRewardGold": 360 },
        { "id": "3-8", "name": "鐒﹀湡骞冲師", "recommendedLevel": 34, "encounterType": "normal", "firstClearRewardGold": 380 },
        { "id": "3-9", "name": "鐑堢劙宀楀摠", "recommendedLevel": 35, "encounterType": "elite", "firstClearRewardGold": 400 },
        { "id": "3-10", "name": "娣辨笂鏍稿績", "recommendedLevel": 36, "encounterType": "boss", "firstClearRewardGold": 520 }
      ]
    },
    {
      "id": "chapter-4",
      "name": "姘稿澧撳洯",
      "levelRange": "Lv.35-50",
      "theme": "浜＄伒",
      "nodes": [
        { "id": "4-1", "name": "鏋搴櫌", "recommendedLevel": 38, "encounterType": "normal", "firstClearRewardGold": 260 },
        { "id": "4-2", "name": "姝荤伒鎷卞粖", "recommendedLevel": 40, "encounterType": "elite", "firstClearRewardGold": 300 },
        { "id": "4-3", "name": "骞介瓊灏忓緞", "recommendedLevel": 42, "encounterType": "normal", "firstClearRewardGold": 320 },
        { "id": "4-4", "name": "鏆楀奖澧撶┐", "recommendedLevel": 44, "encounterType": "elite", "firstClearRewardGold": 340 },
        { "id": "4-5", "name": "鐏甸瓊", "recommendedLevel": 45, "encounterType": "elite", "firstClearRewardGold": 360 },
        { "id": "4-6", "name": "鑵愯殌绁潧", "recommendedLevel": 47, "encounterType": "normal", "firstClearRewardGold": 380 },
        { "id": "4-7", "name": "浜¤€呴暱", "recommendedLevel": 48, "encounterType": "elite", "firstClearRewardGold": 400 },
        { "id": "4-8", "name": "鏆楀奖骞垮満", "recommendedLevel": 49, "encounterType": "normal", "firstClearRewardGold": 420 },
        { "id": "4-9", "name": "浜＄伒绁潧", "recommendedLevel": 50, "encounterType": "elite", "firstClearRewardGold": 440 },
        { "id": "4-10", "name": "鍐ョ伅瀹堟湜", "recommendedLevel": 52, "encounterType": "boss", "firstClearRewardGold": 560 }
      ]
    }
  ]
}


===================== [D:\download\LootingRPG\assets\data\config\map\mapNode.json] =====================
{
  "encounterTypes": ["normal", "elite", "boss"],
  "chapterNodeStyles": {
    "鏋楀湴": {
      "normal": {
        "shape": "rounded-[30%_70%_70%_30%/30%_30%_70%_70%]",
        "size": "w-14 h-14",
        "iconColor": "text-emerald-200",
        "ringColor": "ring-emerald-800/50",
        "glowColor": "rgba(16, 150, 100, 0.4)",
        "particleColor": "bg-emerald-400",
        "bgGradient": "from-emerald-950 via-green-950 to-stone-950",
        "borderStyle": "border-emerald-800/30"
      },
      "elite": {
        "shape": "rounded-lg rotate-12",
        "size": "w-14 h-14",
        "iconColor": "text-lime-300",
        "ringColor": "ring-lime-700/60",
        "glowColor": "rgba(150, 200, 50, 0.5)",
        "particleColor": "bg-lime-500",
        "bgGradient": "from-lime-950 via-emerald-950 to-stone-900",
        "borderStyle": "border-lime-800/40"
      },
      "boss": {
        "shape": "rounded-[40%_60%_35%_65%/60%_30%_70%_40%]",
        "size": "w-18 h-18",
        "iconColor": "text-lime-200",
        "ringColor": "ring-lime-900/70",
        "glowColor": "rgba(100, 180, 60, 0.6)",
        "particleColor": "bg-lime-400",
        "bgGradient": "from-lime-950 via-emerald-900 to-stone-950",
        "borderStyle": "border-lime-800/50"
      }
    },
    "鍦扮墷": {
      "normal": {
        "shape": "rounded-sm",
        "size": "w-14 h-14",
        "iconColor": "text-stone-300",
        "ringColor": "ring-stone-600/50",
        "glowColor": "rgba(120, 120, 130, 0.4)",
        "particleColor": "bg-stone-400",
        "bgGradient": "from-stone-900 via-zinc-900 to-black",
        "borderStyle": "border-stone-700/40"
      },
      "elite": {
        "shape": "rounded-[2px]",
        "size": "w-14 h-14",
        "iconColor": "text-stone-200",
        "ringColor": "ring-stone-500/60",
        "glowColor": "rgba(150, 150, 160, 0.5)",
        "particleColor": "bg-stone-300",
        "bgGradient": "from-stone-800 via-zinc-800 to-stone-950",
        "borderStyle": "border-stone-600/50"
      },
      "boss": {
        "shape": "rounded-none",
        "size": "w-18 h-18",
        "iconColor": "text-stone-100",
        "ringColor": "ring-stone-400/70",
        "glowColor": "rgba(180, 180, 190, 0.6)",
        "particleColor": "bg-stone-200",
        "bgGradient": "from-stone-700 via-zinc-700 to-stone-900",
        "borderStyle": "border-stone-500/60"
      }
    },
    "鐏北": {
      "normal": {
        "shape": "rounded-tl-[40%] rounded-br-[50%]",
        "size": "w-14 h-14",
        "iconColor": "text-orange-200",
        "ringColor": "ring-orange-800/50",
        "glowColor": "rgba(200, 100, 20, 0.4)",
        "particleColor": "bg-orange-500",
        "bgGradient": "from-orange-950 via-red-950 to-stone-950",
        "borderStyle": "border-orange-800/40"
      },
      "elite": {
        "shape": "rounded-tl-[30%] rounded-tr-[60%] rounded-bl-[60%] rounded-br-[30%]",
        "size": "w-14 h-14",
        "iconColor": "text-orange-300",
        "ringColor": "ring-orange-700/60",
        "glowColor": "rgba(220, 120, 30, 0.5)",
        "particleColor": "bg-orange-400",
        "bgGradient": "from-orange-900 via-red-900 to-stone-950",
        "borderStyle": "border-orange-700/50"
      },
      "boss": {
        "shape": "rounded-tl-[60%] rounded-br-[60%] rounded-tr-[20%] rounded-bl-[20%]",
        "size": "w-18 h-18",
        "iconColor": "text-red-200",
        "ringColor": "ring-red-800/70",
        "glowColor": "rgba(220, 50, 20, 0.6)",
        "particleColor": "bg-red-500",
        "bgGradient": "from-red-900 via-orange-900 to-stone-950",
        "borderStyle": "border-red-700/60"
      }
    },
    "浜＄伒": {
      "normal": {
        "shape": "rounded-t-full rounded-b-sm",
        "size": "w-14 h-14",
        "iconColor": "text-red-200",
        "ringColor": "ring-red-800/50",
        "glowColor": "rgba(150, 30, 30, 0.4)",
        "particleColor": "bg-red-400",
        "bgGradient": "from-red-950 via-red-900 to-stone-950",
        "borderStyle": "border-red-800/40"
      },
      "elite": {
        "shape": "rounded-t-[60%] rounded-b-[40%]",
        "size": "w-14 h-14",
        "iconColor": "text-red-300",
        "ringColor": "ring-red-700/60",
        "glowColor": "rgba(180, 40, 40, 0.5)",
        "particleColor": "bg-red-400",
        "bgGradient": "from-red-900 via-red-900 to-stone-950",
        "borderStyle": "border-red-700/50"
      },
      "boss": {
        "shape": "rounded-t-[70%] rounded-b-[30%]",
        "size": "w-18 h-18",
        "iconColor": "text-red-200",
        "ringColor": "ring-red-800/70",
        "glowColor": "rgba(200, 50, 50, 0.6)",
        "particleColor": "bg-red-500",
        "bgGradient": "from-red-900 via-red-900 to-stone-950",
        "borderStyle": "border-red-700/60"
      }
    }
  },
  "defaultEncounterStyles": {
    "normal": { "shape": "rounded-xl", "size": "w-14 h-14", "iconColor": "text-red-200", "ringColor": "ring-red-800/50", "glowColor": "rgba(180, 40, 40, 0.4)", "particleColor": "bg-red-400", "bgGradient": "from-red-950 via-stone-900 to-black", "borderStyle": "border-red-800/40" },
    "elite": { "shape": "rounded-lg rotate-45", "size": "w-14 h-14", "iconColor": "text-amber-200", "ringColor": "ring-amber-900/60", "glowColor": "rgba(200, 100, 20, 0.5)", "particleColor": "bg-amber-600", "bgGradient": "from-amber-950 via-orange-950 to-stone-900", "borderStyle": "border-amber-800/50" },
    "boss": { "shape": "rounded-xl", "size": "w-18 h-18", "iconColor": "text-rose-200", "ringColor": "ring-rose-900/70", "glowColor": "rgba(220, 40, 60, 0.6)", "particleColor": "bg-rose-500", "bgGradient": "from-rose-950 via-red-950 to-stone-950", "borderStyle": "border-rose-800/60" }
  },
  "MAP_NODE_CONFIG": {
    "bossIconSize": 26,
    "normalIconSize": 22,
    "starCount": { "boss": 3, "elite": 2, "normal": 1 },
    "floatDelayBase": 0.3,
    "floatDelayIncrement": 0.08,
    "animationDuration": { "float": 2.5, "hover": 0.35, "glow": 1.5, "particle": 1.2 },
    "hoverScale": 1.1,
    "hoverY": -8,
    "tapScale": 0.95
  },
  "THEME_COLORS": {
    "鏋楀湴": { "primary": "#10b981", "primaryLight": "#6ee7b7", "primaryDark": "#047857" },
    "鍦扮墷": { "primary": "#78716c", "primaryLight": "#d6d3d1", "primaryDark": "#44403c" },
    "鐏北": { "primary": "#f97316", "primaryLight": "#fdba74", "primaryDark": "#c2410c" },
    "浜＄伒": { "primary": "#a855f7", "primaryLight": "#d8b4fe", "primaryDark": "#7e22ce" }
  },
  "THEME_HEADER_COLORS":{
      "鏋楀湴": { "primary": "emerald", "secondary": "green", 
                "glow": "rgba(16, 150, 100, 0.1)", "border": "emerald-900/30", "text": "emerald" },
      "鍦扮墷": { "primary": "stone",   "secondary": "zinc",  
                "glow": "rgba(120, 120, 130, 0.1)", "border": "stone-900/30", "text": "stone" },
      "鐏北": { "primary": "orange",  "secondary": "red",   
                "glow": "rgba(200, 100, 20, 0.1)", "border": "orange-900/30", "text" : "orange" },
      "浜＄伒": { "primary": "red",     "secondary": "red",   
                "glow": "rgba(150, 30, 30, 0.1)", "border": "red-900/30", "text": "red" }
  }
}


===================== [D:\download\LootingRPG\assets\data\config\map\nodeShapes.json] =====================
{
  "鏋楀湴": {
    "normal": "rounded-lg clip-path-forest",
    "elite": "rotate-45 rounded-sm clip-path-forest-elite",
    "boss": "rounded-2xl clip-path-forest-boss"
  },
  "鍦扮墷": {
    "normal": "rounded-sm clip-path-dungeon",
    "elite": "clip-path-dungeon-elite",
    "boss": "clip-path-dungeon-boss"
  },
  "鐏北": {
    "normal": "rounded-tl-3xl rounded-br-3xl clip-path-volcano",
    "elite": "clip-path-volcano-elite",
    "boss": "clip-path-volcano-boss"
  },
  "浜＄伒": {
    "normal": "rounded-xl clip-path-undead",
    "elite": "clip-path-undead-elite",
    "boss": "clip-path-undead-boss"
  }
}


===================== [D:\download\LootingRPG\assets\data\config\themes\ArcaneMystic.json] =====================
{
  "id": "arcane-mystic",
  "name": "濂ユ湳绁炵",
  "description": "绁炵绱綏鍏伴鏍?- 榄旀硶姘涘洿",
  "colors": {
    "gameBg": "#0F0A1A",
    "gameCard": "#1A1425",
    "gameBorder": "#2D2340",
    "gameAccent": "#8B5CF6",
    "gameCta": "#7C3AED",
    "quality": {
      "common": "#9CA3AF",
      "uncommon": "#10B981",
      "rare": "#3B82F6",
      "epic": "#8B5CF6",
      "legendary": "#F59E0B",
      "mythic": "#EC4899"
    }
  },
  "gradients": {
    "body": "radial-gradient(ellipse at 50% 0%, rgba(139, 92, 246, 0.12) 0%, transparent 50%), radial-gradient(ellipse at 80% 100%, rgba(236, 72, 153, 0.08) 0%, transparent 40%), linear-gradient(180deg, #0F0A1A 0%, #1A1425 100%)"
  }
}


===================== [D:\download\LootingRPG\assets\data\config\themes\DarkScare.json] =====================
{
  "id": "dark-scare",
  "name": "鏆楅粦鎭愭儳",
  "description": "鏆楅粦瑗垮够鎭愭€栭鏍?- 琛€绾㈣壊璋?,
  "colors": {
    "gameBg": "#0A0908",
    "gameCard": "#1C1917",
    "gameBorder": "#292524",
    "gameAccent": "#B45309",
    "gameCta": "#991B1B",
    "quality": {
      "common": "#A8A29E",
      "uncommon": "#22C55E",
      "rare": "#3B82F6",
      "epic": "#991B1B",
      "legendary": "#F59E0B",
      "mythic": "#DC2626"
    }
  },
  "gradients": {
    "body": "radial-gradient(ellipse at 50% 0%, rgba(180, 83, 9, 0.08) 0%, transparent 50%), radial-gradient(ellipse at 80% 100%, rgba(34, 197, 94, 0.05) 0%, transparent 40%), linear-gradient(180deg, #0A0908 0%, #1C1917 100%)"
  }
}


===================== [D:\download\LootingRPG\assets\data\locales\en\translation.json] =====================
{
  "quality.common": "Common",
  "quality.uncommon": "Uncommon",
  "quality.rare": "Rare",
  "quality.epic": "Epic",
  "quality.legendary": "Legendary",
  "quality.mythic": "Mythic",

  "map.lockedPrereq": "Unlock by completing previous chapter",
  "map.progress": "Progress",
  "map.recommended": "Recommended",
  "map.level": "Lv.{{level}}",
  "map.state.cleared": "Cleared",
  "map.state.warning": "Hard",
  "map.state.ready": "Ready",
  "map.state.locked": "Locked",
  "map.encounter.normal": "Normal",
  "map.encounter.elite": "Elite",
  "monster.elitePrefix": "Elite路",
  "map.encounter.boss": "BOSS",
  "map.encounter.wave": "Wave",
  "map.failures": "Failed {{count}} times",
  "map.selectChapter": "Select Region",
  "map.title": "Rare Earth Explorer",
  "map.chapters": "Chapters",
  "map.explore": "Map Exploration",
  "map.chapter-1": "Novice Woodland",
  "map.chapter-2": "Abandoned Dungeon",
  "map.chapter-3": "Lava Abyss",
  "map.chapter-4": "Eternal Night Graveyard",
  "椋庢毚娴峰哺": "Storm Coast",
  "鏈烘鑽掑煄": "Mechanical Ruins",
  "鏅剁皣楂樺師": "Crystal Plateau",
  "铏氱┖杈瑰": "Void Frontier",
  "鏄熸笂鍥炲粖": "Star Abyss Corridor",
  "缁堢剦鐜嬪骇": "Throne of the End",
  "渚︽煡钀ュ湴": "Scouting Camp",
  "鐮寸鍥炲粖": "Shattered Corridor",
  "鐔旂伀妗?: "Molten Bridge",
  "鏋搴櫌": "Bone Courtyard",
  "鏂疆鐮佸ご": "Broken Tide Pier",
  "閿堣殌杞︾珯": "Rusting Depot",
  "钃濇櫠鍙板湴": "Blue Crystal Terrace",
  "澶卞簭鍓嶅摠": "Disorder Outpost",
  "闄ㄦ槦闃舵": "Meteor Stairs",
  "缁堢剦鍓嶅涵": "Endtime Vestibule",
  "map.totalStars": "Total Stars:",
  "map.theme.鏋楀湴": "Woodland",
  "map.theme.鍦扮墷": "Dungeon",
  "map.theme.鐏北": "Volcano",
  "map.theme.浜＄伒": "Necropolis",
  "map.theme.椋庢毚": "Storm Coast",
  "map.theme.鏈烘": "Mechanical Ruins",
  "map.theme.鏅朵綋": "Crystal Plateau",
  "map.theme.铏氱┖": "Void Frontier",
  "map.theme.鏄熺┖": "Starfield",
  "map.theme.缁堢剦": "End Times",

  "slot.weapon": "Weapon",
  "slot.helmet": "Helmet",
  "slot.armor": "Armor",
  "slot.ring": "Ring",
  "slot.necklace": "Necklace",
  "slot.boots": "Boots",

  "stat.attack": "Attack",
  "stat.hp": "HP",
  "stat.defense": "Defense",
  "stat.crit": "Crit",
  "stat.critDamage": "Crit Damage",
  "skeleton": "The Ashlands are full of buried bones; these skeletons were once militia who still wander with broken blades after the kingdom fell.",
  "zombie": "When the bells tolled for the plague, the abbey refused to burn the dead 鈥?the rotten learned hate beneath hymns.",
  "goblin": "Cave goblins are born in collapsed shafts; they steal more than coin 鈥?they steal a winter's fire taken by nobles.",
  "wolf": "Packs of wolves prowl the woods, keen-scented and swift 鈥?a common threat in the novice woodland.",
  "wraith": "Wraiths are soldiers with forgotten names; vows unfulfilled leave their souls nailed to old battlefields.",
  "slime": "Slimes seem dull but have swallowed lost potions underground; their bodies churn with alchemical embers.",
  "bandit": "Bandits aren't born evil; many were driven to the roads by taxmen and hunger, learning to strike first to survive.",
  "cultist": "Cultists swear under the black moon, believing that offering goodness will buy them a dawn without hunger.",
  "giant_rat": "Giant rats haunt old sewers beneath the city that once stored grain; now only damp and gnawing remain.",
  "stone_golem": "Stone golems were forged by a dwarven king to guard gates; after the dynasty fell they still obey orders without friend or foe.",
  "lava_hound": "Lava hounds are born from volcanic fissures; legend says they chase the lost heart of a smithing god.",
  "poison_spider": "The venomous queen weaves webs in abandoned temples; every bone on the altar was once a pilgrim seeking redemption.",
  "frost_mage": "Frost mages hail from the northern academy; on the night the gates fell she wrote her final lesson into an eternal winter spell.",
  "harpy": "Harpy brood keep cliffside nests; beneath their wings is the lament of a stolen chick never soothed.",
  "mimic": "Mimics imitate the most alluring treasures; they swallow more than fingers 鈥?they swallow the greedy's last prayers.",
  "void_eye": "Void Eyes come from a star-fallen well; when they gaze, dreams fracture into black dust.",
  "forest_satyr": "The forest satyr once guarded the woods; after imperial logging he now summons vengeful beasts with his horn.",
  "shadow_assassin": "The shadow assassin was once the court's blade until he learned royal orders fall on innocent necks.",
  "bone_shaman": "Bone shamans light lamps for nameless dead, trading names for spells; each casting looks less like the living.",
  "iron_knight": "The iron-bound knight vowed lifetime service; when the king betrayed him, he gave his loyalty to the armor itself.",
  "plague_doctor": "The plague doctor walked with an empty satchel for years; the more he couldn't save, the more he believed suffering was truth.",
  "storm_elemental": "Storm elementals wrap old lighthouses; they remember sailors lighting a homecoming fire there.",
  "blood_bat": "The blood-bat king perches on ruined bell towers; legend says it was once a bell boy cursed to reshape the night.",
  "sand_wraith": "Sand wraiths guard buried city-states; sand covers crowns but not the weeping of the fallen.",
  "abyss_guard": "Abyss guards were reshaped from the garrison; their souls sewn to well-edges with iron, never leaving post.",
  "thorn_beast": "Thorn beasts stalk the wasteland with village banners on their spines, still looking for the home that couldn't hold.",
  "arcane_construct": "Arcane constructs were made by the mage council; after the council's fall they obey only 'remove heresy'.",
  "grave_keeper": "Grave keepers carved stones for the nameless for a century until war filled the cemetery with friends and he refused gentle words.",
  "ashen_warlock": "Ashen warlocks burned invaders to save home but found in the cheers they could no longer return to people.",
  "crystal_lurker": "Crystal lurkers sleep in crystal veins, replaying the dwarf-kingdom's final collapse in endless dreams.",
  "moon_huntress": "The moon huntress chases sinners through silver woods; her arrows never miss, yet she cannot find her missing sister.",
  "rot_brute": "Rot brutes were temple guards turned by black mire; they stand at gates like statues of regret.",
  "abyss_demon": "Abyss Demon Azral once led a tribunal; fallen, he still obsesses over weighing each soul's sins.",
  "ancient_dragon": "Ancient dragon Ignas guards a ruined capital; it remembers feasts shared with humans 鈥?now only ash contracts remain.",
  "dark_knight": "Dark Knight Mordrek was an exiled guardian; his armor holds an unforgiven loyalty.",
  "necromancer": "Necromancer Vira sought to raise plague children, but was lost among a thousand souls.",
  "storm_titan": "Storm Titan Oros was forged by gods to judge mortals; now it remembers thunder but not mercy.",
  "scarlet_queen": "Scarlet Queen Selina swallowed blood oaths on the night of the coup; she wrote throne and curse into her pulse.",
  "void_reaper": "Void Reaper Naeil walks the star gaps, reaping not only life but forgotten hope.",
  "clockwork_core": "The runaway core was once the city's power heart; when the coup cut power it treated the city as a fault to be cleared.",
  "stat.lifesteal": "Lifesteal",
  "stat.elemental": "Elemental",

  "stat.damage": "Damage Bonus",

  "monster.skeleton": "Skeleton Warrior",
  "monster.zombie": "Rotten Zombie",
  "monster.goblin": "Goblin",
  "monster.wolf": "Wolf",
  "monster.wraith": "Wraith",
  "monster.slime": "Slime",
  "monster.bandit": "Bandit",
  "monster.cultist": "Cultist",
  "monster.giant_rat": "Giant Rat",
  "monster.stone_golem": "Stone Golem",
  "monster.lava_hound": "Lava Hound",
  "monster.poison_spider": "Poison Spider",
  "monster.frost_mage": "Frost Mage",
  "monster.harpy": "Harpy",
  "monster.mimic": "Mimic",
  "monster.void_eye": "Void Eye",
  "monster.forest_satyr": "Forest Satyr",
  "monster.shadow_assassin": "Shadow Assassin",
  "monster.bone_shaman": "Bone Shaman",
  "monster.iron_knight": "Iron Knight",
  "monster.plague_doctor": "Plague Doctor",
  "monster.storm_elemental": "Storm Elemental",
  "monster.blood_bat": "Blood Bat",
  "monster.sand_wraith": "Sand Wraith",
  "monster.abyss_guard": "Abyss Guard",
  "monster.thorn_beast": "Thorn Beast",
  "monster.arcane_construct": "Arcane Construct",
  "monster.grave_keeper": "Grave Keeper",
  "monster.ashen_warlock": "Ashen Warlock",
  "monster.crystal_lurker": "Crystal Lurker",
  "monster.moon_huntress": "Moon Huntress",
  "monster.rot_brute": "Rot Brute",
  "monster.abyss_demon": "Abyss Demon",
  "monster.ancient_dragon": "Ancient Dragon",
  "monster.dark_knight": "Dark Knight",
  "monster.necromancer": "Necromancer",
  "monster.storm_titan": "Storm Titan",
  "monster.scarlet_queen": "Scarlet Queen",
  "monster.void_reaper": "Void Reaper",
  "monster.clockwork_core": "Clockwork Core",

  "label.boss": "BOSS",
  "label.monster": "Monster",

  "trait.thorns": "Thorns",
  "trait.lifesteal": "Lifesteal",
  "trait.double_attack": "Double Attack",
  "trait.shield_on_start": "Shield on start",
  "trait.rage_on_low_hp": "Rage on low HP",
  "trait.none": "No special traits",
  "trait": {
    "hints": {
      "thorns": ["This enemy punishes burst damage; high tempo can backfire.", "A safer approach is to increase survivability and sustain, extending effective combat time."],
      "lifesteal": ["This enemy excels at sustaining through fights; prolonging combat amplifies its advantage.", "Prepare continuous pressure to reduce its healing windows."],
      "double_attack": ["This enemy tends to attack in quick succession, creating momentary pressure.", "Prioritize survivability and damage mitigation to avoid being overwhelmed by chains."],
      "shield_on_start": ["This enemy starts with a strong defense; early bursts are less effective.", "Establish a steady rhythm and look for openings to break through."],
      "rage_on_low_hp": ["This enemy becomes more dangerous in the late phase; finishing moves are critical.", "Reserve late-stage resources to avoid being outpaced in the endgame."]
    }
  },
  "codex.title": "Monster Codex",
  "codex.tab.normal": "Normal",
  "codex.tab.boss": "Boss",
  "codex.listTitle": "Monster List",
  "codex.detailTitle": "Details",
  "codex.selectMonster": "Select a monster to view details",
  "codex.stat": {
    "hp": "HP",
    "attack": "Attack",
    "defense": "Defense"
  },
  "codex.traits": "Traits",
  "codex.threatTypes": "Threat Types",
  "codex.background": "Background",
  "codex.bossLevelLabel": "Boss-level enemy",
  "codex.counterGoal": "Counter Goal",
  "codex.tacticsTitle": "Strategy Hints",
  "codex.backgroundFallback": "This monster's history is fragmented and incomplete.",
  "codex.hints": {
    "bossIntro": "This is a boss encounter 鈥?focus your build around a single tactical core rather than spreading resources.",
    "normalIntro": "This is a regular encounter 鈥?prefer stable, general-purpose builds for consistent progression.",
    "counterGoal": "This enemy has a clear counter-goal; focus on one advantage dimension to strengthen.",
    "simple": "This enemy has a simple mechanic 鈥?balanced offense and defense usually suffices."
  },
  "tabs.inventory": "Inventory",
  "tabs.forge": "Forge",
  "tabs.codex": "Codex",
  "battle.title": "Battle",
  "battle.turn": "Turn",
  "battle.enemyProgress": "Enemy Progress",
  "battle.player": "Player",
  "battle.enemy": "Enemy",
  "battle.wave": "Wave",
  "battle.noEnemy": "No enemy",
  "battle.attack": "Attack",
  "battle.retreat": "Retreat",
  "label.legendary_pity": "Legendary pity:",
  "label.mythic_pity": "Mythic pity:",
  "button.equip": "Equip",
  "player.avatarTitle": "Adventurer",
  "label.experience": "Experience",
  "codex.threat": {
    "burst_punish": "Burst Punish",
    "sustain_pressure": "Sustain Pressure",
    "tank_breaker": "Tank Breaker",
    "attrition": "Attrition"
  },
  "codex.strategy": {
    "鍋忚繘鏀?: "Aggressive",
    "鍋忛槻瀹?: "Defensive",
    "鍋忕画鑸?: "Sustain"
  },
  "player": {
    "affixBonuses": "Affix Bonuses",
    "currentEquipment": "Current Equipment"
  },
  "login.title": "Player Login",
  "login.subtitle": "Select an existing profile to continue your adventure",
  "login.noProfiles": "No saved profiles 鈥?create a character on the right",
  "login.lastSaved": "Last saved:",
  "login.createTitle": "Create Character",
  "login.createSubtitle": "Enter a player name to create a local profile",
  "login.placeholder": "e.g. Night Hunter",
  "login.createEnter": "Create & Enter",
  "message.invalid_quality_range": "Quick鈥憇ell failed: invalid quality range.",
  "message.no_items_in_range": "No items in range ({{min}}鈥憑{max}}).",
  "message.quick_sell_result": "Quick鈥憇ell complete: {{min}}鈥憑{max}}, sold {{count}} items for {{gold}} gold.",
  "message.auto_sold_drop": "Auto鈥憇old [{{quality}}] {{name}} for {{gold}} gold",
  "message.dropped_item": "Dropped item [{{quality}}] {{name}}",
  "message.defeat_result": "Defeated {{target}}! Gained {{xp}} XP.{{levelUp}}",
  "message.wave_summary": "Cleared wave ({{wave}} enemies): +{{xp}} XP{{levelTip}}, added {{bag}} items, auto鈥憇old {{soldCount}} (+{{soldGold}} gold).",
  "message.wave_result": "You defeated {{wave}} monsters in one go!",
  "label.quality": "Quality",
  "label.price": "Price",
  "label.enchantLevel": "Enhance lvl",
  "label.name": "Name",
  "label.desc": "Desc",
  "label.asc": "Asc",
  "ui.autoSellHint": "Auto-sell (checked qualities will be sold on drop)",
  "message.calculating": "Calculating...",
  "ui.quickSellAndSort": "Quick sell (by quality range) & sort",
  "label.sellRange": "Sell range",
  "label.to": "to",
  "button.quickSell": "Quick sell",
  "label.sort": "Sort",
  "message.empty_inventory": "Inventory is empty",
  "label.equipped": "Equipped",
  "label.backpack": "Backpack",
  "ui.forgeCenter": "Forge Center",
  "ui.no_forge_items": "No items to forge",
  "button.enchant": "Enchant",
  "button.reroll": "Reroll",
  "ui.forge.preview_times": "Number of enchants",
  "ui.forge.cost": "Cost",
  "ui.forge.preview": "Preview",
  "ui.forge.apply": "Apply",
  "ui.forge.reroll": "Reroll",
  "ui.forge.lock": "Lock",
  "ui.forge.unlock": "Unlock",
  "ui.forge.confirm_title": "Confirm Enchant",
  "ui.forge.confirm_body": "This will consume resources and apply the enchant. Proceed?",
  "button.confirm": "Confirm",
  "button.cancel": "Cancel",

  "bossPhase.abyss_annihilation": "Abyss Annihilation",
  "bossPhase.dragon_annihilation": "Dragon Annihilation",
  "bossPhase.knight_reconstruct": "Knight Reconstruct",
  "bossPhase.necro_drain": "Necro Drain",
  "bossPhase.storm_annihilation": "Storm Annihilation",
  "bossPhase.queen_drain": "Queen Drain",
  "bossPhase.void_annihilation": "Void Annihilation",
  "bossPhase.core_reconstruct": "Core Reconstruct",

  "counter.abyss_demon": "Defensive Counter",
  "counterSuccess.abyss_demon": "Frontline Hold",
  "counterFail.abyss_demon": "Demon Rage Overpower",

  "counter.ancient_dragon": "High-Speed Decap",
  "counterSuccess.ancient_dragon": "Beat Dragon Breath",
  "counterFail.ancient_dragon": "Dragon Breath Crushes",

  "counter.dark_knight": "Armor Break",
  "counterSuccess.dark_knight": "Shield Penetrated",
  "counterFail.dark_knight": "Stalled by Shield",

  "counter.necromancer": "Sustain Suppression",
  "counterSuccess.necromancer": "Match Lifesteal",
  "counterFail.necromancer": "Drained by Souls",

  "counter.storm_titan": "Elemental Resistance",
  "counterSuccess.storm_titan": "Kill Before Rampage",
  "counterFail.storm_titan": "Titan Chains You",

  "counter.scarlet_queen": "Blood Pool",
  "counterSuccess.scarlet_queen": "Survive Queen Burst",
  "counterFail.scarlet_queen": "Crushed by Blood",

  "counter.void_reaper": "Thorns Duel",
  "counterSuccess.void_reaper": "Reaper Turned",
  "counterFail.void_reaper": "Hurt by Thorns",

  "counter.clockwork_core": "Burst Break",
  "counterSuccess.clockwork_core": "Stop Reconstruction",
  "counterFail.clockwork_core": "Core Stacks Shields",
  "label.crit_prefix": "Crit ",
  "label.lifesteal_plus": "Lifesteal +{{value}}",
  "label.lethal": "Lethal Strike",
  "label.terminated": "Terminated",
  "element.fire": "Fire Element",
  "element.ice": "Ice Element",
  "element.thunder": "Thunder Element",
  "element.poison": "Poison Element",
  "element.void": "Dark Element",
  "codex.counterGoal.passed": "Counter goal achieved: {{title}} ({{detail}})",
  "codex.counterGoal.failed": "Counter goal not achieved: {{title}} ({{detail}})",
  "button.challenge_monster": "Challenge Monster",
  "button.challenge_boss": "Challenge Boss",
  "button.challenge_wave": "Wave Assault",
  "label.drop": "Drop:",
  "label.affixes": "Affixes:",
  "message.equipped": "Equipped {{name}}",
  "message.unequipped": "Unequipped {{name}}",
  "message.sold_item": "Sold {{name}} for {{price}} gold",
  "message.enchant_success": "Enchant success! {{name}} is now +{{level}}",
  "message.enchant_fail": "Enchant failed... gold consumed.",
  "message.enchant_maxed": "This item has reached maximum enchant level +20.",
  "message.not_enough_gold_enchant": "Not enough gold to enchant.",
  "message.no_secondary_stats": "This item has no secondary stats to reroll.",
  "message.not_enough_gold_reroll": "Not enough gold to reroll.",
  "message.reroll_complete": "Reroll complete: {{name}} reset {{count}} secondary stats"
}


===================== [D:\download\LootingRPG\assets\data\locales\zh\translation.json] =====================
{
  "quality":{
    "common": "鏅€?,
    "uncommon": "浼樼",
    "rare": "绋€鏈?,
    "epic": "鍙茶瘲",
    "legendary": "浼犺",
    "mythic": "绁炶瘽"
  },
  "map.lockedPrereq": "瀹屾垚鍓嶇疆绔犺妭瑙ｉ攣",
  "map.totalStars": "鎬绘槦鏁?,
  "map.progress": "杩涘害",
  "map.recommended": "鎺ㄨ崘",
  "map.level": "Lv.{{level}}",
  "map.state.cleared": "宸查€氬叧",
  "map.state.warning": "鍋忛毦",
  "map.state.ready": "鍙寫鎴?,
  "map.state.locked": "鏈В閿?,
  "map.encounter.normal": "鏅€?,
  "map.encounter.elite": "绮捐嫳",
  "monster.elitePrefix": "绮捐嫳路",
  "map.encounter.boss": "BOSS",
  "map.encounter.wave": "缇ゆ€?,
  "map.failures": "澶辫触 {{count}} 娆?,
  "map.selectChapter": "閫夋嫨鍖哄煙",
  "map.title": "绋€鍦熸帰绱?,
  "map.chapters": "绔犺妭",
  "map.explore": "鍦板浘鎺㈢储",
  "map.chapter-1": "鏂版墜鏋楀湴",
  "map.chapter-2": "搴熷純鍦扮墷",
  "map.chapter-3": "鐔斿博娣辨笂",
  "map.chapter-4": "姘稿澧撳洯",
  "map.theme.鏋楀湴": "鏋楀湴",
  "map.theme.鍦扮墷": "鍦扮墷",
  "map.theme.鐏北": "鐏北",
  "map.theme.浜＄伒": "浜＄伒",

  "slot.weapon": "姝﹀櫒",
  "slot.helmet": "澶寸洈",
  "slot.armor": "鎶ょ敳",
  "slot.ring": "鎴掓寚",
  "slot.necklace": "椤归摼",
  "slot.boots": "闉嬪瓙",

  "stat.attack": "鏀诲嚮鍔?,
  "stat.hp": "鐢熷懡鍊?,
  "stat.defense": "闃插尽鍔?,
  "stat.crit": "鏆村嚮鐜?,
  "stat.critDamage": "鏆村嚮浼ゅ",
  "stat.attackSpeed": "鏀诲嚮閫熷害",
  "stat.lifesteal": "鍚歌",
  "stat.elemental": "鍏冪礌浼ゅ",
  "stat.damage": "浼ゅ鍔犳垚",

  "monster.skeleton": "楠烽珔鎴樺＋",
  "monster.zombie": "鑵愮儌鍍靛案",
  "monster.forest_slime": "妫灄鍙茶幈濮?,

  "label.boss": "BOSS",
  "label.monster": "鎬墿",

  "trait.thorns": "鍙嶄激",
  "trait.lifesteal": "鍚歌",
  "trait.double_attack": "浜岃繛鍑?,
  "trait.shield_on_start": "寮€灞€鎶ょ浘",
  "trait.rage_on_low_hp": "娈嬭鐙傛€?,
  "trait.none": "鏃犵壒娈婅瘝鏉?,
  "trait.hints": {
    "thorns": ["姝ゆ晫浜哄鐖嗗彂杈撳嚭鏈夊弽鍒惰兘鍔涳紝鑺傚杩囧揩瀹规槗琚弽鍣€?, "鏇寸ǔ濡ョ殑鍋氭硶鏄彁楂樼敓瀛樹笌缁埅锛屾媺闀挎湁鏁堜綔鎴樻椂闂淬€?],
    "lifesteal": ["姝ゆ晫浜烘搮闀垮湪缂犳枟涓洖绋筹紝涔呮嫋浼氭斁澶у叾浼樺娍銆?, "寤鸿鍑嗗鎸佺画鍘嬪埗鎵嬫锛屽噺灏戝叾鎭㈠绐楀彛銆?],
    "double_attack": ["姝ゆ晫浜烘湁杩炵画鎵撳嚮鍊惧悜锛屽鏄撳舰鎴愮灛鏃跺帇鍔涖€?, "寤鸿浼樺厛寮哄寲瀹归敊涓庡噺浼わ紝閬垮厤琚繛娈靛甫璧般€?],
    "shield_on_start": ["姝ゆ晫浜哄紑灞€闃茬嚎绋冲浐锛屽墠娈电‖鍐叉敹鐩婅緝浣庛€?, "鍏堝缓绔嬬ǔ瀹氳妭濂忥紝鍐嶅鎵剧牬鍙ｆ洿瀹规槗婊氳捣浼樺娍銆?],
    "rage_on_low_hp": ["姝ゆ晫浜哄湪娈嬪眬闃舵濞佽儊鏇撮珮锛屾敹灏惧鐞嗗緢鍏抽敭銆?, "寤鸿淇濈暀鍚庢璧勬簮锛岄伩鍏嶅湪缁堝眬琚弽鎺ㄣ€?]
  },
  "codex.title": "鎬墿鍥鹃壌",
  "codex.tab.normal": "鏅€?,
  "codex.tab.boss": "BOSS",
  "codex.listTitle": "鎬墿鍒楄〃",
  "codex.detailTitle": "璇︾粏淇℃伅",
  "codex.selectMonster": "閫夋嫨鎬墿鏌ョ湅璇︽儏",
  "codex.stat": { "hp": "鐢熷懡", "attack": "鏀诲嚮", "defense": "闃插尽"},
  "codex.traits": "璇嶆潯",
  "codex.threatTypes": "濞佽儊绫诲瀷",
  "codex.background": "鑳屾櫙浼犺",
  "codex.bossLevelLabel": "棣栭绾ф晫浜?,
  "codex.counterGoal": "瀵规姉鐩爣",
  "codex.tacticsTitle": "瀵圭瓥鎻愮ず",
  "codex.backgroundFallback": "杩欏悕鏁屼汉鐨勬棫鍙插凡鍦ㄩ涓畫缂恒€?,
  "codex.hints": {
    "bossIntro": "杩欐槸棣栭鎴橈紝寤鸿鍥寸粫鍗曚竴鎴樻湳鏍稿績鏋勭瓚锛屼笉瑕佸钩鍧囧垎閰嶈祫婧愩€?,
    "normalIntro": "杩欐槸甯歌閬亣鎴橈紝寤鸿鐢ㄧǔ瀹氭硾鐢ㄦ瀯绛戜繚鎸佽繛缁帹杩涖€?,
    "counterGoal": "璇ユ晫浜哄瓨鍦ㄦ槑纭鎶楁柟鍚戯紝寤鸿鍥寸粫涓€绉嶄紭鍔跨淮搴﹂泦涓己鍖栥€?,
    "simple": "璇ユ晫浜烘満鍒剁畝鍗曪紝淇濇寔鏀婚槻骞宠　閫氬父灏辫兘绋冲畾澶勭悊銆?
  },
  "tabs.inventory": "鑳屽寘浠撳簱",
  "tabs.forge": "寮哄寲涓績",
  "tabs.codex": "鎬墿鍥鹃壌",
  "battle.title": "鎴樻枟",
  "battle.turn": "鍥炲悎",
  "battle.enemyProgress": "鏁屼汉杩涘害",
  "battle.player": "鐜╁",
  "battle.enemy": "鏁屼汉",
  "battle.wave": "娉㈡",
  "battle.noEnemy": "鏆傛棤鏁屼汉",
  "battle.attack": "鏀诲嚮",
  "battle.retreat": "鎾ら€€",
  "label.legendary_pity": "浼犺淇濆簳:",
  "label.mythic_pity": "绁炶瘽淇濆簳:",
  "button.equip": "瑁呭",
  "player.avatarTitle": "鍐掗櫓鑰?,
  "label.experience": "缁忛獙",
  "codex.threat": {
    "burst_punish": "鐖嗗彂鍙嶅埗鍨?,
    "sustain_pressure": "鎸佺画鍘嬪埗鍨?,
    "tank_breaker": "鐮撮槻鍘嬪潶鍨?,
    "attrition": "娑堣€楄殨椋熷瀷"
  },
  "codex.strategy": {
    "offense": "鍋忚繘鏀?,
    "defense": "鍋忛槻瀹?,
    "sustain": "鍋忕画鑸?
  },
  "player": {
    "affixBonuses": "璇嶆潯鍔犳垚",
    "currentEquipment": "褰撳墠瑁呭"
  },
  "login.title": "鐜╁鐧诲綍",
  "login.subtitle": "閫夋嫨宸叉湁瀛樻。缁х画鍐掗櫓",
  "login.noProfiles": "鏆傛棤鐜╁瀛樻。锛岃鍙充晶鍒涘缓鏂拌鑹?,
  "login.lastSaved": "鏈€杩戜繚瀛?",
  "login.createTitle": "鍒涘缓瑙掕壊",
  "login.createSubtitle": "杈撳叆鐜╁鍚嶅苟鍒涘缓鏂扮殑鏈湴瀛樻。",
  "login.placeholder": "渚嬪:澶滆壊鐚庝汉",
  "login.createEnter": "鍒涘缓骞惰繘鍏?,
  "message.invalid_quality_range": "涓€閿敭鍗栧け璐?鍝佽川鑼冨洿鏃犳晥銆?,
  "message.no_items_in_range": "鎵€閫夎寖鍥?{{min}}-{{max}})娌℃湁鍙敭鍗栬澶囥€?,
  "message.quick_sell_result": "涓€閿敭鍗栧畬鎴?{{min}}-{{max}}锛屽叡鍑哄敭 {{count}} 浠讹紝鑾峰緱 {{gold}} 閲戝竵銆?,
  "message.auto_sold_drop": "鑷姩鍞崠:[{{quality}}] {{name}}锛岃幏寰楅噾甯?{{gold}}",
  "message.dropped_item": "鎺夎惤浜嗚澶?[{{quality}}] {{name}}",
  "message.defeat_result": "鎴愬姛鍑昏触{{target}}锛佽幏寰楃粡楠?{{xp}}銆倇{levelUp}}",
  "message.wave_summary": "鎬兢娓呭壙瀹屾垚({{wave}}鍙?:缁忛獙 +{{xp}}{{levelTip}}锛屽叆鍖?{{bag}} 浠讹紝鑷姩鍞崠 {{soldCount}} 浠?+{{soldGold}} 閲戝竵)銆?,
  "message.wave_result": "浣犱竴鍙ｆ皵鍑昏触浜?{{wave}} 鍙€墿锛?,
  "label.quality": "鍝佽川",
  "label.price": "鍞环",
  "label.enchantLevel": "寮哄寲绛夌骇",
  "label.name": "鍚嶇О",
  "label.desc": "闄嶅簭",
  "label.asc": "鍗囧簭",
  "ui.autoSellHint": "鑷姩鍞崠(鍕鹃€夊搧璐ㄥ悗锛屾垬鏂楁帀钀戒細鑷姩鍑哄敭)",
  "message.calculating": "璁＄畻涓?..",
  "ui.quickSellAndSort": "涓€閿敭鍗?鎸夊搧璐ㄨ寖鍥?涓庢帓搴?,
  "label.sellRange": "鍞崠鑼冨洿",
  "label.to": "鍒?,
  "button.quickSell": "涓€閿敭鍗?,
  "label.sort": "鎺掑簭",
  "message.empty_inventory": "鑳屽寘绌虹┖濡備篃",
  "label.equipped": "宸茶澶?,
  "label.backpack": "鑳屽寘",
  "ui.forgeCenter": "閿婚€犱腑蹇?,
  "ui.no_forge_items": "鏆傛棤鍙敾閫犺澶?,
  "button.enchant": "寮哄寲",
  "button.reroll": "娲楃粌",
  "ui.forge.preview_times": "寮哄寲娆℃暟",
  "ui.forge.cost": "娑堣€?,
  "ui.forge.preview": "鏌ョ湅棰勮",
  "ui.forge.apply": "搴旂敤寮哄寲",
  "ui.forge.reroll": "閲嶉摳",
  "ui.forge.lock": "閿佸畾",
  "ui.forge.unlock": "瑙ｉ攣",
  "ui.forge.confirm_title": "纭寮哄寲",
  "ui.forge.confirm_body": "灏嗘秷鑰楄祫婧愬苟搴旂敤寮哄寲锛岀‘瀹氬悧锛?,
  "button.confirm": "纭",
  "button.cancel": "鍙栨秷",

  "bossPhase.abyss_annihilation": "娣辨笂婀伃",
  "bossPhase.dragon_annihilation": "榫欑値澶╃綒",
  "bossPhase.knight_reconstruct": "榛搧閲嶆瀯",
  "bossPhase.necro_drain": "浜￠瓊姹插彇",
  "bossPhase.storm_annihilation": "闆烽渾婀伃",
  "bossPhase.queen_drain": "鐚╃孩姹查瓊",
  "bossPhase.void_annihilation": "铏氱┖婀伃",
  "bossPhase.core_reconstruct": "榻胯疆閲嶆瀯",

  "counter.abyss_demon": "鍘嬪埗鍙嶅嚮",
  "counterSuccess.abyss_demon": "姝ｉ潰绔欐々鍙帶",
  "counterFail.abyss_demon": "鎭堕瓟鐙傛€掍激瀹虫毚璧?,

  "counter.ancient_dragon": "楂橀€熸柀棣?,
  "counterSuccess.ancient_dragon": "鍙姠鍏堝帇鍒堕緳鎭?,
  "counterFail.ancient_dragon": "榫欐伅鑺傚鍘嬫浣?,

  "counter.dark_knight": "鐮寸敳闂ㄦ",
  "counterSuccess.dark_knight": "鍙揩閫熺┛鐩?,
  "counterFail.dark_knight": "琚姢鐩炬嫋鍏ユ秷鑰楁垬",

  "counter.necromancer": "缁埅鍘嬪埗",
  "counterSuccess.necromancer": "鍙窡涓婂惛琛€鎷夋壇",
  "counterFail.necromancer": "浼氳鎸佺画鎶藉共",

  "counter.storm_titan": "鍏冪礌鎶楀帇",
  "counterSuccess.storm_titan": "鍙湪鐙傛毚鍓嶆柀鏉€",
  "counterFail.storm_titan": "娉板潶浼氳繘鍏ヨ繛鍑绘敹鍓?,

  "counter.scarlet_queen": "寮洪煣琛€姹?,
  "counterSuccess.scarlet_queen": "鍙拺杩囧コ鐜嬬垎鍙戠獥",
  "counterFail.scarlet_queen": "琚繛鍑讳笌鍚歌纰惧帇",

  "counter.void_reaper": "鍙嶄激浜掓悘",
  "counterSuccess.void_reaper": "鍙弽鍘嬫敹鍓茶妭濂?,
  "counterFail.void_reaper": "杈撳嚭浼氳鍙嶄激鍙嶅櫖",

  "counter.clockwork_core": "鐖嗗彂鍑荤┛",
  "counterSuccess.clockwork_core": "鍙帇鍒堕噸鏋勫惊鐜?,
  "counterFail.clockwork_core": "鏍稿績灏嗘棤闄愬彔鐩?,
  "label.crit_prefix": "鏆村嚮 ",
  "label.lifesteal_plus": "鍚歌 +{{value}}",
  "label.lethal": "鑷村懡涓€鍑?,
  "label.terminated": "缁堢粨",
  "element.fire": "鐏厓绱?,
  "element.ice": "鍐板厓绱?,
  "element.thunder": "闆峰厓绱?,
  "element.poison": "姣掑厓绱?,
  "element.void": "鏆楀厓绱?,
  "trait": {
    "note": {
      "thorns": "鍙嶄激 {{damage}}",
      "lifesteal_enemy": "鏁屾柟鍚歌 +{{value}}",
      "double_attack": "鏁屾柟浜岃繛鍑?,
      "shield_on_start": "寮€鍦烘姢鐩?,
      "rage_on_low_hp": "娈嬭鐙傛€?
    }
  },
  "monster": {
    "background": {
      "skeleton":"鐏扮儸鍘熼噹涓婂煁楠ㄦ棤鏁帮紝杩欎簺楠烽珔鏇炬槸瀹堝煄鐨勬皯鍏碉紝鐜嬪浗瑕嗙伃鍚庝粛鎻＄潃鏂垉寰樺緤鍦ㄥ椋庨噷銆?,
      "zombie":  "鐦熺柅閽熷０鍝嶈捣閭ｅ勾锛屼慨閬撻櫌鎷掔粷鐒氬案锛岃厫鐑傚兊灏镐究鍦ㄧシ鍛婂０涓參鎱㈠浼氫簡浠囨仺銆?,
      "forest_slime": "妫灄鍙茶幈濮嗗湪娼箍鐨勬灄鍦颁腑娓歌崱锛屽惛鏀朵簡澶ч噺鐨勮厫娈栬川鍜岄瓟娉曟畫娓ｏ紝浣撳瀷閫愭笎鑶ㄨ儉銆?,
      "wolf" : "鐙肩兢鏇炬槸杩欑墖鍦熷湴鐨勫畧鎶よ€咃紝鐩村埌浜虹被鐨勭寧鏉€鍜屾爾鎭镜鍗犺瀹冧滑鍙樺緱鍑剁寷鑰岀粷鏈涖€? ,
      "goblin": "鍝ュ竷鏋楁槸鍦板簳娲炵┐鐨勫父浣忓眳姘戯紝鐙＄尵鑰屽ソ鎴橈紝鍠滄鏀堕泦鍐掗櫓鑰呴仐钀界殑瑁呭娈嬮銆?
    }
  },
  "boss": {
    "abyss_demon": {
      "introLine": "闃垮吂鎷夊皵寮€濮嬪鍒や綘鐨勮椽濠€?,
      "battleLogLine": "娣辨笂鍦ｅ吀缈婚〉锛岄粦鐏部鐫€浣犵殑褰卞瓙鐕冪儳銆?,
      "phase": {
        "entering": "瀹″垽搴殑閽熷０鍦ㄨ闅欏洖鑽°€?,
        "fighting": "闃垮吂鎷夊皵涓捐捣榛戠劙鍦ｅ嵃銆?,
        "dying": "瀹″垽璇嶆鍦ㄥ穿瑁傛垚鐏般€?,
        "dropping": "瀹″垽澶╁钩缁堜簬澶辫　銆?
      }
    }
  },
  "codex.counterGoal.passed": "瀵规姉鐩爣杈炬垚锛歿{title}}锛坽{detail}}锛?,
  "codex.counterGoal.failed": "瀵规姉鐩爣鏈揪鎴愶細{{title}}锛坽{detail}}锛?,
  "button.challenge_monster": "鎸戞垬鎬墿",
  "button.challenge_boss": "鎸戞垬 BOSS",
  "button.challenge_wave": "缇ゆ€潵琚?,
  "label.drop": "鎺夎惤:",
  "label.affixes": "璇嶆潯鍔犳垚:",
  "message.equipped": "宸茶澶?{{name}}",
  "message.unequipped": "宸插嵏涓?{{name}}",
  "message.sold_item": "鍑哄敭浜?{{name}}锛岃幏寰楅噾甯?{{price}}",
  "message.enchant_success": "寮哄寲鎴愬姛锛亄{name}} 鍙樹负 +{{level}}",
  "message.enchant_fail": "寮哄寲澶辫触... 閲戝竵宸叉秷鑰椼€?,
  "message.enchant_maxed": "璇ヨ澶囧凡杈惧埌鏈€澶у己鍖栫瓑绾?+20銆?,
  "message.not_enough_gold_enchant": "閲戝竵涓嶈冻锛屾棤娉曞己鍖栥€?,
  "message.no_secondary_stats": "璇ヨ澶囨棤鍙礂缁冨壇璇嶆潯銆?,
  "message.not_enough_gold_reroll": "閲戝竵涓嶈冻锛屾棤娉曟礂缁冦€?,
  "message.reroll_complete": "娲楃粌瀹屾垚锛歿{name}} 宸查噸缃?{{count}} 鏉″壇璇嶆潯"
}


===================== [D:\download\LootingRPG\src\app\context\auth.ts] =====================
export interface AuthContext {
  profiles: any[];
  activeProfileId: string | null;
  isAuthenticated: boolean;
  handleLogin: (id: string) => void;
  handleCreateProfile: (name: string) => void;
  handleDeleteProfile: (id: string) => void;
  handleExportSave: () => void;
  handleImportSave: () => void;
  handleLogoutAction: () => void;
  loadProfile: (id: string) => void;
}


===================== [D:\download\LootingRPG\src\app\context\autoSell.ts] =====================
export interface AutoSellContext {
  autoSellQualities: Record<string, boolean>;
  handleToggleAutoSellQuality: (quality: string) => void;
  setAutoSellQualities: React.Dispatch<React.SetStateAction<Record<string, boolean>>>;
}


===================== [D:\download\LootingRPG\src\app\context\battle.ts] =====================
export interface BattleContext {
  handleEnterMapNode: (
    node: import('../../config/map/ChapterData').MapNodeDef,
    chapter: import('../../config/map/ChapterData').MapChapterDef,
  ) => void;
  handleBattleAttack: () => void;
  handleBattleRetreat: () => void;
}


===================== [D:\download\LootingRPG\src\app\context\debug.ts] =====================
export interface DebugContext {
  handleDebugAddItems: (quality: string, slot: string, count: number, level?: number) => void;
}


===================== [D:\download\LootingRPG\src\app\context\index.ts] =====================
export * from './auth';
export * from './state';
export * from './log';
export * from './autoSell';
export * from './map';
export * from './battle';
export * from './inventory';
export * from './debug';
export * from './misc';


===================== [D:\download\LootingRPG\src\app\context\inventory.ts] =====================
export interface InventoryContext {
  quickSellByQualityRange: (minQuality: string, maxQuality: string) => void;
  handleEquip: (id: string) => void;
  handleSell: (id: string) => void;
  handleForge: (id: string) => void;
  handleReroll: (id: string, locks?: string[]) => void;
  handleUnequip: (slot: string) => void;
}


===================== [D:\download\LootingRPG\src\app\context\log.ts] =====================
export interface LogContext {
  logs: string[];
  addLog: (msg: string) => void;
  setLogs: React.Dispatch<React.SetStateAction<string[]>>;
}


===================== [D:\download\LootingRPG\src\app\context\map.ts] =====================
import type { MapProgressState, ActiveTab } from '../../types/game';

export interface MapContext {
  mapProgress: MapProgressState;
  setMapProgress: React.Dispatch<React.SetStateAction<MapProgressState>>;
  activeTab: ActiveTab;
  setActiveTab: React.Dispatch<React.SetStateAction<ActiveTab>>;
  focusMapNode: string | null;
  setFocusMapNode: React.Dispatch<React.SetStateAction<string | null>>;
}


===================== [D:\download\LootingRPG\src\app\context\misc.ts] =====================
export interface MiscContext {
  handleReset: () => void;
}


===================== [D:\download\LootingRPG\src\app\context\state.ts] =====================
import type { GameState } from '../../types/game';

export interface StateContext {
  gameState: GameState;
  dispatchGameState: React.Dispatch<
    | { type: 'RESET' }
    | { type: 'SET'; payload: GameState }
  >;
  loading: boolean;
  setLoading: React.Dispatch<React.SetStateAction<boolean>>;
  forgeSelectedId: string | null;
  setForgeSelectedId: React.Dispatch<React.SetStateAction<string | null>>;
}


===================== [D:\download\LootingRPG\src\app\state\globalState.ts] =====================
import { INITIAL_STATE } from '../../config/game/gameConfig';
import type { GameState } from '../../types/game';

/**
 * Creates a fresh initial game state for a new player
 */
export const createFreshInitialState = (): GameState => structuredClone(INITIAL_STATE);


===================== [D:\download\LootingRPG\src\app\state\index.ts] =====================
import { normalizeInventory } from './inventoryState';
import type { BattleSession, GameState } from '../../shared/types/game';

const normalizeBattleSession = (session: BattleSession | null): BattleSession | null => {
  if (!session) return null;

  const enemies = (session.enemies ?? []).map((enemy, index) => ({
    ...enemy,
    meta: {
      ...(enemy.meta ?? {}),
      waveId:
        typeof enemy.meta?.waveId === 'string'
          ? enemy.meta.waveId
          : `wave-${index + 1}`,
    },
  }));

  const inferredWaveOrder = Array.from(
    new Set(
      enemies.map((enemy, index) =>
        typeof enemy.meta?.waveId === 'string' ? enemy.meta.waveId : `wave-${index + 1}`,
      ),
    ),
  );
  const existingWaveOrder = Array.isArray(session.waveOrder) ? session.waveOrder : [];
  const waveOrder = existingWaveOrder.length > 0
    ? existingWaveOrder.filter((waveId) => inferredWaveOrder.includes(waveId))
    : inferredWaveOrder;

  const safeWaveOrder = waveOrder.length > 0 ? waveOrder : inferredWaveOrder;
  const maxIndex = Math.max(0, safeWaveOrder.length - 1);
  const currentWaveIndex = Number.isFinite(session.currentWaveIndex)
    ? Math.max(0, Math.min(maxIndex, session.currentWaveIndex))
    : 0;

  return {
    ...session,
    enemies,
    waveOrder: safeWaveOrder,
    currentWaveIndex,
    phase: session.phase ?? 'player_input',
    events: Array.isArray(session.events) ? session.events : [],
  };
};

/**
 * Normalizes the entire game state, including inventory and equipment
 */
export const normalizeGameState = (state: GameState): GameState => {
  const { normalizedBackpack, normalizedCurrent } = normalizeInventory(state.backpack, state.currentEquipment);

  return {
    ...state,
    backpack: normalizedBackpack,
    currentEquipment: normalizedCurrent,
    battle: {
      activeSession: normalizeBattleSession(state.battle?.activeSession ?? null),
      history: Array.isArray(state.battle?.history) ? state.battle.history : [],
    },
  };
};

// Re-export all state creation and management functions
export { createFreshInitialState } from './globalState';
export { normalizeInventory } from './inventoryState';

// Export the StateManager class
export { StateManager } from './stateManager';


===================== [D:\download\LootingRPG\src\app\state\inventoryState.ts] =====================
import type { Equipment } from '../../types/game';

/**
 * Normalizes equipment data and ensures structural consistency
 */
const normalizeEquipment = (item: Equipment): Equipment => {
  const quality = item.quality;
  const slot = item.slot;

  const attrs: Record<string, number> = {};
  Object.entries(item.attributes).forEach(([k, v]) => {
    attrs[k] = v;
  });

  const main = item.mainStat;

  return {
    ...item,
    level: Math.max(1, Number(item.level) || 1),
    quality,
    slot,
    icon: item.icon,
    attributes: attrs,
    mainStat: main,
    affixes: Array.isArray(item.affixes) ? item.affixes : [],
    localeNames: item.localeNames || undefined,
  };
};

/**
 * Normalizes the inventory and equipped items in the game state
 */
import { SLOTS } from '../../config/game/equipment';

export const normalizeInventory = (backpack: Equipment[], currentEquipment: Record<string, Equipment | null>) => {
  const normalizedBackpack = backpack.map((item) => ({ ...normalizeEquipment(item), equipped: false }));

  // ensure every configured slot exists in the normalized output
  const normalizedCurrent = Object.fromEntries(
    SLOTS.map((slot) => {
      const item = currentEquipment[slot] || null;
      return [slot, item ? { ...normalizeEquipment(item), equipped: true } : null];
    }),
  ) as Record<string, Equipment | null>;

  return {
    normalizedBackpack,
    normalizedCurrent,
  };
};


===================== [D:\download\LootingRPG\src\app\state\stateManager.ts] =====================
import { createFreshInitialState, normalizeGameState } from './index';
import type { GameState } from '../../types/game';

/**
 * State Manager - Unified interface for all game state operations
 * This provides a single entry point for state creation and management
 * to prevent the gameState.ts from becoming a God Object.
 */
export class StateManager {
  /**
   * Creates a complete fresh game state including player and inventory state
   */
  static createFreshGameState(): GameState {
    return createFreshInitialState();
  }

  /**
   * Normalizes game state data (e.g., after loading from save)
   */
  static normalizeState(state: GameState): GameState {
    return normalizeGameState(state);
  }
}

// Re-export for convenience
export { createFreshInitialState, normalizeGameState } from './index';


===================== [D:\download\LootingRPG\src\app\AppShell.tsx] =====================
import { LoginScreen } from '../components/auth/LoginScreen';
import { GameScreen }  from '../components/game/GameScreen';
import { useGame }     from './GameContext';

export function AppShell() {
  const {
    profiles,
    activeProfileId,
    isAuthenticated,
    gameState,
    loading,
    activeTab,
    autoSellQualities,
    forgeSelectedId,
    mapProgress,
    focusMapNode,
    setActiveTab,
    setMapProgress,
    setFocusMapNode,
    setForgeSelectedId,
    handleLogin,
    handleCreateProfile,
    handleDeleteProfile,
    handleExportSave,
    handleImportSave,
    handleLogoutAction,
    handleReset,
    handleEnterMapNode,
    handleBattleAttack,
    handleBattleRetreat,
    handleToggleAutoSellQuality,
    quickSellByQualityRange,
    handleEquip,
    handleSell,
    handleForge,
    handleReroll,
    handleUnequip,
    handleDebugAddItems,
  } = useGame();

  if (!isAuthenticated) {
    return (
      <LoginScreen
        profiles={profiles}
        onLogin={handleLogin}
        onCreate={handleCreateProfile}
        onDelete={handleDeleteProfile}
      />
    );
  }

  const currentProfile = profiles.find((profile: import('../shared/types/game').SaveProfile) => profile.id === activeProfileId);

  return (
    <GameScreen
      gameState={gameState}
      activeTab={activeTab}
      loading={loading}
      playerName={currentProfile?.name || 'Unknown Player'}
      autoSellQualities={autoSellQualities}
      forgeSelectedId={forgeSelectedId}
      battleSession={gameState.battle.activeSession}
      playerStats={gameState.playerStats}
      onExportSave={handleExportSave}
      onImportSave={handleImportSave}
      onLogout={handleLogoutAction}
      onReset={handleReset}
      mapProgress={mapProgress}
      onSelectMapChapter={(chapterId) => {
        setMapProgress((prev: import('../shared/types/game').MapProgressState) => ({ ...prev, selectedChapterId: chapterId }));
      }}
      focusMapNode={focusMapNode}
      onClearFocusMapNode={() => setFocusMapNode(null)}
      onSetTab={setActiveTab}
      onEnterMapNode={handleEnterMapNode}
      onBattleAttack={handleBattleAttack}
      onBattleRetreat={handleBattleRetreat}
      onQuickSellByQualityRange={quickSellByQualityRange}
      onEquip={handleEquip}
      onSell={handleSell}
      onForge={handleForge}
      onToggleAutoSellQuality={handleToggleAutoSellQuality}
      onReroll={handleReroll}
      onSelectForgeItem={setForgeSelectedId}
      onUnequip={handleUnequip}
      onDebugAddItems={handleDebugAddItems}
    />
  );
}


===================== [D:\download\LootingRPG\src\app\GameContext.tsx] =====================
import React, { createContext, useContext, useReducer, useState, useCallback } from 'react';
import { createFreshInitialState } from './state';
import type {GameState} from '../shared/types/game';
import { createInitialMapProgress } from '../domains/map/services/progress';
import { MAP_CHAPTERS } from '../config/map/ChapterData';
import { useProfileSave } from '../hooks/profile/useProfileSave';
import { useInventoryActions } from '../hooks/game/useInventoryActions';
import { ACTIVE_PROFILE_KEY } from '../config/runtime/storage';

// smaller hooks
import { useGameLogger } from '../hooks/game/useGameLogger';
import { useAutoSell } from '../hooks/game/useAutoSell';
import { useMapProgress } from '../hooks/game/useMapProgress';
import { useBattleSession } from '../hooks/game/useBattleSession';
import { useDebug } from '../hooks/game/useDebug';

// --- game state reducer --------------------------------------------------

type GameStateAction =
  | { type: 'RESET' }
  | { type: 'SET'; payload: GameState };

function gameReducer(state: GameState, action: GameStateAction): GameState {
  switch (action.type) {
    case 'RESET':
      return createFreshInitialState();
    case 'SET':
      return action.payload;
    default:
      return state;
  }
}
const GameContext = createContext<any>(undefined);

export const GameProvider: React.FC<React.PropsWithChildren<unknown>> = ({ children }) => {
  const [gameState, dispatchGameState] = useReducer(
    gameReducer,
    undefined,
    () => createFreshInitialState(),
  );
  const setGameState: React.Dispatch<React.SetStateAction<GameState>> = useCallback(
    (value) => {
      if (typeof value === 'function') {
        // cast because TS can't infer from overloaded Dispatch type
        const updater = value as (prev: GameState) => GameState;
        dispatchGameState({ type: 'SET', payload: updater(gameState) });
      } else {
        dispatchGameState({ type: 'SET', payload: value });
      }
    },
    [gameState],
  );

  const [loading, setLoading] = useState(false);
  const [forgeSelectedId, setForgeSelectedId] = useState<string | null>(null);

  const { logs, setLogs, addLog } = useGameLogger();
  const {
    autoSellQualities,
    toggleQuality: handleToggleAutoSellQuality,
    setAutoSellQualities,
  } = useAutoSell();
  const {
    mapProgress,
    setMapProgress,
    activeTab,
    setActiveTab,
    focusMapNode,
    setFocusMapNode,
  } = useMapProgress();

  const { handleBattleAttack, handleBattleRetreat, handleEnterMapNode } = useBattleSession({
    gameState,
    mapProgress,
    setGameState,
    setMapProgress,
    addLog,
    setActiveTab,
    setFocusMapNode,
  });

  const {
    profiles,
    activeProfileId,
    isAuthenticated,
    handleLogin,
    handleCreateProfile,
    handleDeleteProfile,
    handleExportSave,
    handleImportSave,
    handleLogout,
    loadProfile,
  } = useProfileSave({
    gameState,
    logs,
    autoSellQualities,
    mapProgress,
    setGameState,
    setLogs,
    setAutoSellQualities,
    setMapProgress,
    addLog,
  });

  const reportError = useCallback(
    (err: unknown, context: { action?: string } = {}) => {
      const message = err instanceof Error ? err.message : String(err);
      const parts = [`[Error] ${message}`, `profile=${activeProfileId}`];
      if (context.action) parts.push(`action=${context.action}`);
      addLog(parts.join(' '));
    },
    [activeProfileId, addLog],
  );

  const { quickSellByQualityRange, processAction } = useInventoryActions({
    gameState,
    loading,
    setGameState,
    setLoading,
    addLog,
    reportError,
  });

  const handleEquip = useCallback((id: string) => processAction({ type: 'equip', itemId: id }), [processAction]);
  const handleSell = useCallback((id: string) => processAction({ type: 'sell', itemId: id }), [processAction]);
  const handleForge = useCallback((id: string) => processAction({ type: 'enchant', itemId: id }), [processAction]);
  const handleReroll = useCallback(
    (id: string, lockTypes?: string[]) => processAction({ type: 'reroll', itemId: id, lockTypes }),
    [processAction],
  );
  const handleUnequip = useCallback((slot: string) => processAction({ type: 'unequip_slot', slot }), [processAction]);

  const handleLogoutAction = useCallback(() => {
    handleLogout();
    setLoading(false);
    localStorage.removeItem(ACTIVE_PROFILE_KEY);
  }, [handleLogout]);

  const handleReset = useCallback(() => {
    if (confirm('浣犵‘瀹氳閲嶇疆褰撳墠瀛樻。鍚楋紵姝ゆ搷浣滄棤娉曟挙閿€銆?)) {
      setGameState(createFreshInitialState());
      setLoading(false);
      setLogs(['[System] 瀛樻。宸查噸缃畬鎴愩€俿torage 宸叉竻闄ゃ€?]);
      setMapProgress(createInitialMapProgress(MAP_CHAPTERS));
    }
  }, [setGameState, setLoading, setLogs, setMapProgress]);

  const { handleDebugAddItems } = useDebug({ gameState, setGameState, addLog });
  const value = {
    profiles,
    activeProfileId,
    isAuthenticated,
    handleLogin,
    handleCreateProfile,
    handleDeleteProfile,
    handleExportSave,
    handleImportSave,
    handleLogoutAction,
    loadProfile,

    gameState,
    dispatchGameState,
    loading,
    setLoading,
    forgeSelectedId,
    setForgeSelectedId,

    logs,
    addLog,
    setLogs,

    autoSellQualities,
    handleToggleAutoSellQuality,
    setAutoSellQualities,

    mapProgress,
    setMapProgress,
    activeTab,
    setActiveTab,
    focusMapNode,
    setFocusMapNode,

    handleEnterMapNode,
    handleBattleAttack,
    handleBattleRetreat,

    quickSellByQualityRange,
    handleEquip,
    handleSell,
    handleForge,
    handleReroll,
    handleUnequip,

    handleDebugAddItems,

    handleReset,
  };

  return <GameContext.Provider value={value}>{children}</GameContext.Provider>;
};

export function useGame() {
  const ctx = useContext(GameContext);
  if (!ctx) {
    throw new Error('useGame must be used within a GameProvider');
  }
  return ctx;
}


===================== [D:\download\LootingRPG\src\components\auth\LoginScreen.tsx] =====================
import { LogIn, Plus, Trash2, User } from 'lucide-react';
import { useState } from 'react';
import { motion } from 'motion/react';
import { useTranslation } from 'react-i18next';
import type { SaveProfile } from '../../types/game';

interface LoginScreenProps {
  profiles: SaveProfile[];
  onLogin: (profileId: string) => void;
  onCreate: (name: string) => void;
  onDelete: (profileId: string) => void;
}

export function LoginScreen({ profiles, onLogin, onCreate, onDelete }: LoginScreenProps) {
  const { t } = useTranslation();
  const [name, setName] = useState('');
  return (
    <div className="min-h-screen flex items-center justify-center p-4 md:p-8 relative overflow-hidden">
      <div className="pointer-events-none absolute -top-32 -left-32 w-96 h-96 bg-red-900/30 blur-3xl rounded-full animate-pulse" />
      <div className="pointer-events-none absolute -bottom-32 -right-32 w-96 h-96 bg-rose-500/10 blur-3xl rounded-full animate-pulse" style={{ animationDelay: '1s' }} />
      <div className="pointer-events-none absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[600px] h-[600px] bg-gradient-radial from-red-900/10 via-transparent to-transparent rounded-full" />
      
      <div className="absolute inset-0 pointer-events-none overflow-hidden">
        <div className="absolute inset-0 bg-[linear-gradient(rgba(18,16,22,0)_50%,rgba(0,0,0,0.1)_50%),linear-gradient(90deg,rgba(255,0,0,0.02),rgba(0,255,0,0.01),rgba(0,0,255,0.02))] z-[1] bg-[length:100%_4px,6px_100%]" />
      </div>

      <motion.div 
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        className="w-full max-w-4xl grid grid-cols-1 lg:grid-cols-2 gap-6 relative z-10"
      >
        <section className="bg-gradient-to-br from-game-card/90 to-game-card/60 backdrop-blur-sm border border-game-border/50 rounded-2xl p-6 shadow-2xl shadow-red-900/10 relative overflow-hidden">
          <div className="absolute inset-0 bg-gradient-to-br from-red-900/10 to-transparent" />
          <div className="absolute -top-20 -right-20 w-40 h-40 bg-red-900/20 rounded-full blur-3xl" />
          
          <div className="relative z-10">
            <h2 className="text-xl font-display mb-1 text-transparent bg-clip-text bg-gradient-to-r from-red-400 to-red-600">{t('login.title')}</h2>
            <p className="text-sm text-gray-500 mb-6">{t('login.subtitle')}</p>

            <div className="space-y-3 max-h-[420px] overflow-y-auto pr-2">
              {profiles.length === 0 && (
                <motion.div 
                  initial={{ opacity: 0 }} animate={{ opacity: 1 }}
                  className="text-center py-8 border border-dashed border-game-border/50 rounded-xl"
                >
                  <User size={32} className="mx-auto text-gray-600 mb-2" />
                  <p className="text-sm text-gray-500">{t('login.noProfiles')}</p>
                </motion.div>
              )}
              {profiles.map((profile, index) => (
                <motion.div 
                  key={profile.id} initial={{ opacity: 0, x: -20 }}
                  animate={{ opacity: 1, x: 0 }} transition={{ delay: index * 0.1 }}
                  className="flex items-center justify-between bg-game-bg/50 border border-game-border/50 rounded-xl px-3 py-3 hover:border-red-800/50 hover:bg-game-card/50 transition-all duration-200 cursor-pointer group"
                >
                  <button onClick={() => onLogin(profile.id)} className="text-left flex-1">
                    <div className="flex items-center gap-2">
                      <div className="w-8 h-8 bg-gradient-to-br from-red-800/30 to-red-900/30 rounded-lg flex items-center justify-center">
                        <User size={14} className="text-red-400" />
                      </div>
                      <span className="font-semibold text-gray-200">{profile.name}</span>
                    </div>
                    <p className="text-xs text-gray-500 mt-1 ml-10">{t('login.lastSaved')} {new Date(profile.updatedAt).toLocaleString()}</p>
                  </button>
                  <div className="flex items-center gap-2 ml-2">
                    <motion.button 
                      whileHover={{ scale: 1.1 }}
                      whileTap={{ scale: 0.95 }}
                      onClick={() => onLogin(profile.id)} 
                      className="px-2.5 py-1.5 rounded-lg bg-red-900/30 text-red-400 hover:bg-red-800 hover:text-white text-xs font-bold transition-all cursor-pointer"
                    >
                      <LogIn size={12} />
                    </motion.button>
                    <motion.button 
                      whileHover={{ scale: 1.1 }}
                      whileTap={{ scale: 0.95 }}
                      onClick={() => onDelete(profile.id)} 
                      className="px-2.5 py-1.5 rounded-lg bg-red-500/10 text-red-400 hover:bg-red-500 hover:text-white text-xs font-bold transition-all cursor-pointer"
                    >
                      <Trash2 size={12} />
                    </motion.button>
                  </div>
                </motion.div>
              ))}
            </div>
          </div>
        </section>

        <motion.section 
          initial={{ opacity: 0, x: 20 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ delay: 0.2 }}
          className="bg-gradient-to-br from-game-card/90 to-game-card/60 backdrop-blur-sm border border-game-border/50 rounded-2xl p-6 shadow-2xl shadow-red-900/10 relative overflow-hidden"
        >
          <div className="absolute inset-0 bg-gradient-to-br from-red-900/10 to-rose-500/5" />
          <div className="absolute -bottom-20 -left-20 w-40 h-40 bg-rose-600/10 rounded-full blur-3xl" />
          
          <div className="relative z-10">
            <h2 className="text-xl font-display mb-1 text-transparent bg-clip-text bg-gradient-to-r from-rose-400 to-red-500">{t('login.createTitle')}</h2>
            <p className="text-sm text-gray-500 mb-6">{t('login.createSubtitle')}</p>

            <div className="space-y-3">
              <input
                value={name}
                onChange={(e) => setName(e.target.value)}
                placeholder={t('login.placeholder')}
                className="w-full bg-game-bg/50 border border-game-border/50 rounded-xl px-4 py-3 outline-none focus:border-red-700 focus:ring-1 focus:ring-red-700/50 text-sm transition-all placeholder:text-gray-600"
              />
              <motion.button
                whileHover={{ scale: 1.02, boxShadow: '0_0_30px rgba(124, 58, 237, 0.4)' }}
                whileTap={{ scale: 0.98 }}
                onClick={() => {
                  const trimmed = name.trim();
                  if (!trimmed) return;
                  onCreate(trimmed);
                  setName('');
                }}
                className="w-full py-3 rounded-xl bg-gradient-to-r from-red-800 to-red-900 text-white font-bold hover:brightness-110 hover:shadow-lg hover:shadow-red-900/30 transition-all flex items-center justify-center gap-2 cursor-pointer relative overflow-hidden group"
              >
                <div className="absolute inset-0 bg-gradient-to-r from-white/0 via-white/20 to-white/0 translate-x-[-100%] group-hover:translate-x-[100%] transition-transform duration-700" />
                <Plus size={16} className="relative z-10" /> 
                <span className="relative z-10">{t('login.createEnter')}</span>
              </motion.button>
            </div>
          </div>
        </motion.section>
      </motion.div>
    </div>
  );
}


===================== [D:\download\LootingRPG\src\components\game\map\mapConfig.tsx] =====================
import nodeShapes from '@data/config/map/nodeShapes.json';
import type { ChapterTheme } from '../../../config/map/mapNode';
import { MAP_CHAPTERS } from '../../../config/map/ChapterData';

type ThemeKey = keyof typeof nodeShapes;

const orderedThemes = Array.from(new Set(MAP_CHAPTERS.map((chapter) => chapter.theme))) as ThemeKey[];
const [forestTheme, dungeonTheme, volcanoTheme, undeadTheme] =
  orderedThemes.length >= 4
    ? orderedThemes
    : (Object.keys(nodeShapes) as ThemeKey[]);


export interface ChapterThemeStyle {
  islandGradient: string;
  terrainTop: string;
  glowColor: string;
  shadowColor: string;
  accentColor: string;
  particles: { color: string; size: string; count: number };
  background: string;
  nodeShape: string;
  nodeEffects: {
    normal: string;
    elite: string;
    boss: string;
  };
  pathColor: string;
}
export const chapterThemeStyles = {
  [forestTheme]: {
    islandGradient: 'from-emerald-950 via-red-900 to-black',
    terrainTop: 'from-emerald-900 via-red-800 to-stone-900',
    glowColor: 'rgba(180, 40, 40, 0.4)',
    shadowColor: 'rgba(120, 30, 30, 0.3)',
    accentColor: 'emerald',
    particles: { color: 'bg-red-600', size: 'w-1 h-1', count: 4 },
    background: `
      radial-gradient(ellipse at 20% 30%, rgba(30, 80, 30, 0.2) 0%, transparent 40%),
      radial-gradient(ellipse at 80% 70%, rgba(60, 20, 20, 0.25) 0%, transparent 45%),
      radial-gradient(ellipse at 50% 50%, rgba(20, 10, 10, 0.4) 0%, transparent 60%),
      linear-gradient(180deg, #050805 0%, #0a0808 50%, #050505 100%)
    `,
    nodeShape: 'clip-path-forest',
    nodeEffects: nodeShapes[forestTheme],
    pathColor: 'rgb(100, 50, 30)',
  },
  [dungeonTheme]: {
    islandGradient: 'from-stone-950 via-red-950 to-black',
    terrainTop: 'from-stone-800 via-red-900 to-black',
    glowColor: 'rgba(150, 40, 40, 0.4)',
    shadowColor: 'rgba(100, 30, 30, 0.3)',
    accentColor: 'slate',
    particles: { color: 'bg-red-500', size: 'w-1 h-1', count: 3 },
    background: `
      radial-gradient(ellipse at 30% 20%, rgba(40, 40, 45, 0.3) 0%, transparent 35%),
      radial-gradient(ellipse at 70% 80%, rgba(30, 20, 20, 0.35) 0%, transparent 45%),
      radial-gradient(ellipse at 50% 50%, rgba(15, 15, 20, 0.5) 0%, transparent 55%),
      linear-gradient(180deg, #080808 0%, #0c0a0a 50%, #060606 100%)
    `,
    nodeShape: 'clip-path-dungeon',
    nodeEffects: nodeShapes[dungeonTheme],
    pathColor: 'rgb(80, 70, 60)',
  },
  [volcanoTheme]: {
    islandGradient: 'from-stone-950 via-red-950 to-black',
    terrainTop: 'from-orange-900 via-red-900 to-stone-950',
    glowColor: 'rgba(200, 60, 20, 0.5)',
    shadowColor: 'rgba(180, 40, 20, 0.35)',
    accentColor: 'orange',
    particles: { color: 'bg-red-600', size: 'w-1.5 h-1.5', count: 5 },
    background: `
      radial-gradient(ellipse at 30% 10%, rgba(200, 60, 10, 0.25) 0%, transparent 40%),
      radial-gradient(ellipse at 70% 85%, rgba(120, 30, 10, 0.3) 0%, transparent 45%),
      radial-gradient(ellipse at 50% 40%, rgba(80, 20, 10, 0.35) 0%, transparent 50%),
      linear-gradient(180deg, #0a0505 0%, #120808 50%, #080404 100%)
    `,
    nodeShape: 'clip-path-volcano',
    nodeEffects: nodeShapes[volcanoTheme],
    pathColor: 'rgb(180, 60, 20)',
  },
  [undeadTheme]: {
    islandGradient: 'from-slate-950 via-red-950 to-black',
    terrainTop: 'from-red-900 via-red-900 to-stone-950',
    glowColor: 'rgba(160, 50, 100, 0.4)',
    shadowColor: 'rgba(120, 30, 60, 0.3)',
    accentColor: 'purple',
    particles: { color: 'bg-rose-700', size: 'w-1 h-2', count: 4 },
    background: `
      radial-gradient(ellipse at 25% 15%, rgba(80, 20, 80, 0.2) 0%, transparent 40%),
      radial-gradient(ellipse at 75% 85%, rgba(40, 10, 50, 0.25) 0%, transparent 45%),
      radial-gradient(ellipse at 50% 50%, rgba(30, 5, 40, 0.4) 0%, transparent 55%),
      linear-gradient(180deg, #050308 0%, #08050a 50%, #040205 100%)
    `,
    nodeShape: 'clip-path-undead',
    nodeEffects: nodeShapes[undeadTheme],
    pathColor: 'rgb(120, 40, 80)',
  },
} as Record<ChapterTheme, ChapterThemeStyle>;

export const getNodeState = (
  unlocked: boolean, cleared: boolean, playerLevel: number, nodeLevel: number,
): 'locked' | 'warning' | 'ready' | 'cleared' => {
  if (!unlocked) return 'locked';
  if (cleared) return 'cleared';
  if (playerLevel < nodeLevel) return 'warning';
  return 'ready';
};

export const stateOverlayStyles = {
  locked: { overlay: 'opacity-35', glowFilter: 'none', },
  warning: { overlay: '', glowFilter: 'drop-shadow(0 0 8px rgba(200, 100, 30, 0.5))'},
  ready: { overlay: '', glowFilter: 'drop-shadow(0 0 12px rgba(180, 40, 40, 0.7))'},
  cleared: { overlay: 'opacity-70', glowFilter: 'drop-shadow(0 0 6px rgba(180, 50, 50, 0.5))'},
};
export const clamp = (value: number, min: number, max: number) => Math.max(min, Math.min(max, value));
const ZIGZAG_START_X = 14;
const ZIGZAG_STEP_X = 22;
const ZIGZAG_Y_POINTS = [46, 54] as const;

export const getZigzagNodePosition = (nodeIndex: number) => ({
  x: ZIGZAG_START_X + nodeIndex * ZIGZAG_STEP_X,
  y: ZIGZAG_Y_POINTS[nodeIndex % ZIGZAG_Y_POINTS.length],
});

const getPanLimits = (nodeCount: number, viewport: DOMRect) => {
  const firstX = getZigzagNodePosition(0).x;
  const lastX = getZigzagNodePosition(nodeCount - 1).x;
  const sidePadding = 12;

  const minX = ((50 - (lastX + sidePadding)) / 100) * viewport.width;
  const maxX = ((50 - (firstX - sidePadding)) / 100) * viewport.width;

  return { minX, maxX };
};

export const clampMapOffset = ( nextOffset: { x: number; y: number }, viewport: DOMRect | null, nodeCount: number) => {
  if (!viewport) return { x: 0, y: 0 };
  const { minX, maxX } = getPanLimits(nodeCount, viewport);
  return { x: clamp(nextOffset.x, minX, maxX), y: 0,};
};


===================== [D:\download\LootingRPG\src\components\game\map\MapNode.tsx] =====================
import {getNodeAttempts,isNodeCleared,isNodeUnlocked} from '../../../domains/map/services/progress';
import { Lock, Sparkles, Star, Zap, Skull, Crown, Trophy, Ghost } from 'lucide-react';
import { chapterThemeStyles, getNodeState, stateOverlayStyles, getZigzagNodePosition } from './mapConfig';
import type { MapNodeDef, MapChapterDef } from '../../../config/map/ChapterData';
import type { MapEncounterType } from '../../../config/map/mapNode';
import type { MapProgressState } from '../../../types/game';
import { UI_STYLES } from '../../../config/ui/tokens';
import { chapterNodeStyles, themeColors, defaultEncounterStyles } from '../../../config/map/mapNode';
import { useTranslation } from 'react-i18next';
import { motion } from 'motion/react';

interface MapNodeProps {
  node: MapNodeDef;
  nodeIndex: number;
  selectedChapter: MapChapterDef;
  normalizedProgress: MapProgressState;
  playerLevel: number;
  loading: boolean;
  onEnterNode: (node: MapNodeDef, chapter: MapChapterDef) => void;
  onHoverStart?: () => void;
  onHoverEnd?: () => void;
}

const EncounterIcon = ({ type, size = 22 }: { type: MapEncounterType; size?: number }) => {
  const style = defaultEncounterStyles[type];
  switch (type) {
    case 'boss':  return  <Crown size={size} className={style.iconColor} />;
    case 'elite': return  <Trophy size={size} className={style.iconColor} />;
    default:      return  <Ghost size={size} className={style.iconColor} />;
  }
};
export default function MapNode({
   node, nodeIndex, selectedChapter,
   normalizedProgress, playerLevel, loading,
   onEnterNode, onHoverStart, onHoverEnd,
}: MapNodeProps) {
  const { t } = useTranslation();
  const unlocked = isNodeUnlocked(normalizedProgress, node.id);
  const cleared = isNodeCleared(normalizedProgress, node.id);
  const attempts = getNodeAttempts(normalizedProgress, node.id);
  const waves = node.waves && node.waves.length > 0 ? node.waves : [];
  const waveCount = waves.length;
  const state = getNodeState(unlocked, cleared, playerLevel, node.recommendedLevel);
  const disabled     = loading || state === 'locked';
  const themeStyle   = chapterThemeStyles[selectedChapter.theme];
  const overlayStyle = stateOverlayStyles[state];
  const floatDelay   = nodeIndex * 0.3;
  const chapterEncounterStyles = chapterNodeStyles[selectedChapter.theme];
  const encounterStyle = chapterEncounterStyles[node.encounterType];
  const starCount = node.encounterType === 'boss' ? 3 : node.encounterType === 'elite' ? 2 : 1;
  const nodePosition = getZigzagNodePosition(nodeIndex);
  const isBoss = node.encounterType === 'boss';
  const themeColorConfig = themeColors[selectedChapter.theme];

  return (
    <div
      key={node.id} className="absolute"
      style={{ left: `${nodePosition.x}%`, top: `${nodePosition.y}%`, transform: 'translate(-50%, -50%)' }}
    >
      <motion.button
        data-map-node="1"
        initial={{ opacity: 0, y: 20, scale: 0.8 }}
        animate={{ opacity: 1, y: 0, scale: 1 }}
        transition={{ delay: nodeIndex * 0.08, duration: 0.35, type: 'spring', stiffness: 280 }}
        whileHover={disabled ? {} : { y: -8, scale: 1.1 }}
        whileTap={disabled ? {} : { scale: 0.95 }}
        onHoverStart={() => onHoverStart?.()}
        onHoverEnd={() => onHoverEnd?.()}
        onClick={() => !disabled && onEnterNode(node, selectedChapter)}
        className={`relative cursor-pointer ${overlayStyle.overlay}`}
        style={{ filter: overlayStyle.glowFilter }}
      >
        <motion.div
          className="relative"
          animate={disabled ? {} : { y: [0, -5, 0] }}
          transition={{ duration: 2.5 + floatDelay, repeat: Infinity, ease: 'easeInOut', delay: floatDelay}}
        >
          <div className="absolute -bottom-2 left-1/2 -translate-x-1/2 w-full h-4">
            <motion.div
              className="absolute inset-0 rounded-[50%] blur-lg"
              style={{ backgroundColor: themeStyle.shadowColor }}
              animate={{ scale: [1, 1.2, 1], opacity: [0.4, 0.7, 0.4] }}
              transition={{ duration: 2, repeat: Infinity, delay: floatDelay }}
            />
          </div>

          <div className="relative flex flex-col items-center">
            {waveCount > 1 && (
              <div className={UI_STYLES.nodeWaveLabel}>
                {waveCount} {t('map.encounter.wave')}
              </div>)}
            <div className="absolute -top-6 left-1/2 -translate-x-1/2 flex gap-1">
              {Array.from({ length: starCount }).map((_, i) => (
                <motion.div
                  key={i} animate={disabled ? {} : { scale: [1, 1.2, 1], opacity: [0.8, 1, 0.8] }}
                  transition={{ duration: 1.5, repeat: Infinity, delay: i * 0.2 }}
                >
                  <Star size={10} className="text-yellow-400" fill="currentColor" strokeWidth={1.5} />
                </motion.div>
              ))}
            </div>

            {isBoss && !disabled && !cleared && (
              <motion.div
                className="absolute -inset-4 rounded-full"
                style={{ background: `radial-gradient(circle, ${encounterStyle.glowColor} 0%, transparent 70%)` }}
                animate={{ scale: [1, 1.3, 1], opacity: [0.3, 0.6, 0.3] }}
                transition={{ duration: 2, repeat: Infinity }}
              />
            )}
            <motion.div
              className={`
                relative ${encounterStyle.size} ${encounterStyle.shape}
                bg-gradient-to-br ${encounterStyle.bgGradient}
                ring-2 ${encounterStyle.ringColor} shadow-lg flex items-center justify-center overflow-hidden
              `}
              animate={isBoss && !disabled ? { boxShadow: [`0 0 20px ${themeColorConfig.primary}80`, `0 0 40px ${themeColorConfig.primaryLight}aa`, `0 0 20px ${themeColorConfig.primary}80`] } : {}}
              transition={{ duration: 1.5, repeat: Infinity }}
            >
              <div
                className="absolute inset-0"
                style={{ background: `linear-gradient(135deg, ${themeColorConfig.primaryLight}26 0%, transparent 40%, rgba(0,0,0,0.5) 100%)` }}
              />
              <div className="absolute inset-0" style={{ background: `radial-gradient(circle at 30% 30%, ${themeColorConfig.primaryLight}1a, transparent 50%)` }} />

              {node.encounterType === 'elite' && (
                <div className="absolute inset-0 flex items-center justify-center">
                  <div className="w-full h-full bg-gradient-to-br from-amber-600/15 to-transparent" />
                </div>
              )}
              <div className={`relative z-10 ${node.encounterType === 'elite' ? '-rotate-45' : ''}`}>
                <EncounterIcon type={node.encounterType} size={isBoss ? 26 : 22} />
              </div>
              {Array.from({ length: 4 }).map((_, i) => (
                <motion.div
                  key={i}
                  className={`absolute ${encounterStyle.particleColor} w-1 h-1 rounded-full`}
                  style={{
                    left: `${15 + i * 22}%`,
                    top: `${15 + (i % 3) * 25}%`,
                  }}
                  animate={{ opacity: [0.3, 1, 0.3], scale: [0.5, 1.2, 0.5] }}
                  transition={{ duration: 1.2 + i * 0.2, repeat: Infinity, delay: i * 0.15 }}
                />
              ))}
            </motion.div>

            <motion.div
              className="mt-2"
              animate={disabled ? {} : { y: [0, -1, 0] }}
              transition={{ duration: 1.5, repeat: Infinity, delay: floatDelay }}
            >
              <span className="text-[10px] font-semibold whitespace-nowrap" style={{ color: isBoss ? themeColorConfig.primaryLight : themeColorConfig.primary }}>
                {node.name}
              </span>
            </motion.div>

            <div className="mt-1 flex items-center gap-2">
              <span className="text-[9px] font-medium opacity-70">{t(`map.encounter.${node.encounterType}`)}</span>
              <span className="text-[9px] font-mono" style={{ color: themeColorConfig.primaryLight }}>{t('map.level', { level: node.recommendedLevel })}</span>
            </div>

            <div className="mt-0.5 flex items-center gap-2">
              <span className="text-[7px] text-amber-400/80 flex items-center gap-0.5">
                <span className="text-amber-500">+</span>
                {node.firstClearRewardGold}G
              </span>
              {state === 'cleared' && (
                <span className="text-[7px] text-cyan-400 flex items-center gap-0.5">
                  <Star size={8} fill="currentColor" />
                  {t('map.state.cleared')}
                </span>
              )}
              {state === 'warning' && (
                <span className="text-[7px] text-amber-400 flex items-center gap-0.5">
                  <Zap size={8} />
                  {t('map.state.warning')}
                </span>
              )}
              {state === 'ready' && (
                <span className="text-[7px] text-emerald-400 flex items-center gap-0.5">
                  <Sparkles size={8} />
                  {t('map.state.ready')}
                </span>
              )}
              {state === 'locked' && (
                <span className="text-[7px] text-slate-500 flex items-center gap-0.5">
                  <Lock size={8} />
                  {t('map.state.locked')}
                </span>
              )}
            </div>

            {attempts > 0 && (
              <div className="text-[6px] text-rose-400/70 flex items-center gap-0.5 mt-0.5">
                <Skull size={7} />
                {t('map.failures', { count: attempts })}
              </div>
            )}
          </div>
        </motion.div>
      </motion.button>
    </div>
  );
}


===================== [D:\download\LootingRPG\src\components\game\map\MapViewport.tsx] =====================
import MapNode from './MapNode';
import { motion } from 'motion/react';
import { useRef, useState, useEffect } from 'react';
import { useTranslation } from 'react-i18next';
import { Mountain} from 'lucide-react';
import type { MapChapterDef, MapNodeDef } from '../../../config/map/ChapterData';
import type { MapProgressState } from '../../../shared/types/game';
import { isNodeCleared, isNodeUnlocked,} from '../../../domains/map/services/progress';
import { clampMapOffset, getZigzagNodePosition, chapterThemeStyles,} from './mapConfig';
import { themeHeaderColors} from '../../../config/map/mapNode';

interface MapViewportProps {
  playerLevel: number;
  loading: boolean;
  normalizedProgress: MapProgressState;
  selectedChapter: MapChapterDef;
  selectedChapterProgress: { cleared: number; total: number; completed: boolean };
  onEnterNode: (node: MapNodeDef, chapter: MapChapterDef) => void;
  focusNodeId?: string | null;
  onClearFocus?: () => void;
}

export default function MapViewport({
  playerLevel,
  loading,
  normalizedProgress,
  selectedChapter,
  selectedChapterProgress,
  onEnterNode,
  focusNodeId,
  onClearFocus,
}: MapViewportProps) {
  const { t } = useTranslation();
  const [offset, setOffset] = useState({ x: 0, y: 0 });
  const [, setHoveredNode] = useState<string | null>(null);
  const mapViewportRef = useRef<HTMLDivElement | null>(null);
  const dragRef = useRef<{ dragging: boolean; x: number; y: number }>({ dragging: false, x: 0, y: 0 });
  const themeColors = themeHeaderColors[selectedChapter.theme];

  const onWheel = (event: React.WheelEvent) => {
    // logic lives in the effect listener; kept here for typing but not attached directly
    const deltaX = event.deltaY || event.deltaX;
    setOffset((prev) => {
      const viewport = mapViewportRef.current?.getBoundingClientRect() ?? null;
      const next = { x: prev.x - deltaX, y: 0 };
      return clampMapOffset(next, viewport, selectedChapter.nodes.length);
    });
  };

  // React attaches wheel as a passive listener by default which prevents us from
  // calling preventDefault.  Patch the element directly with a non-passive
  // handler so we can cancel scrolling when over the map.
  useEffect(() => {
    const el = mapViewportRef.current;
    if (!el) return;
    const handler = (e: WheelEvent) => {
      e.preventDefault();
      onWheel(e as unknown as React.WheelEvent);
    };
    el.addEventListener('wheel', handler, { passive: false });
    return () => {
      el.removeEventListener('wheel', handler);
    };
  }, [onWheel]);

  const onPointerDown = (event: React.PointerEvent<HTMLDivElement>) => {
    const target = event.target as HTMLElement;
    if (target.closest('[data-map-node="1"]')) return;
    event.currentTarget.setPointerCapture(event.pointerId);
    dragRef.current = { dragging: true, x: event.clientX, y: event.clientY };
  };

  const onPointerMove = (event: React.PointerEvent<HTMLDivElement>) => {
    if (!dragRef.current.dragging) return;
    const dx = event.clientX - dragRef.current.x;
    dragRef.current.x = event.clientX;
    dragRef.current.y = event.clientY;
    const viewport = mapViewportRef.current?.getBoundingClientRect() ?? null;
    setOffset((prev) => clampMapOffset({ x: prev.x + dx, y: 0 }, viewport, selectedChapter.nodes.length));
  };

  const onPointerUp = (event: React.PointerEvent<HTMLDivElement>) => {
    if (event.currentTarget.hasPointerCapture(event.pointerId)) {
      event.currentTarget.releasePointerCapture(event.pointerId);
    }
    dragRef.current.dragging = false;
  };

  const onPointerLeave = () => {
    dragRef.current.dragging = false;
  };

  // center viewport when requested
  useEffect(() => {
    if (!focusNodeId) return;
    const idx = selectedChapter.nodes.findIndex((n) => n.id === focusNodeId);
    if (idx >= 0 && mapViewportRef.current) {
      const viewport = mapViewportRef.current.getBoundingClientRect();
      const pos = getZigzagNodePosition(idx);
      // target coordinates in px
      const targetX = (pos.x / 100) * viewport.width;
      const centerX = viewport.width / 2;
      const desired = { x: centerX - targetX, y: 0 };
      setOffset(() => clampMapOffset(desired, viewport, selectedChapter.nodes.length));
    }
    onClearFocus?.();
  }, [focusNodeId, selectedChapter, onClearFocus]);

  return (
    <section 
      className="flex-1 border rounded-xl bg-gradient-to-br from-stone-950/60 to-stone-950/50 p-3 flex flex-col overflow-hidden relative"
      style={{ borderColor: themeColors.border.replace('/30', ''), background: `linear-gradient(180deg, rgba(30,30,30,0.3) 0%, rgba(50,20,20,0.1) 50%, rgba(20,20,20,0.3) 100%)` }}
    >
      <div 
        className="absolute inset-0 pointer-events-none"
        style={{ background: `radial-gradient(ellipse at top left, ${themeColors.glow}, transparent 50%), radial-gradient(ellipse at bottom right, rgba(100,20,20,0.08), transparent 50%)` }}
      />

      <header className="mb-3 pb-3 relative z-10 flex items-center justify-between" style={{ borderBottom: `1px solid ${themeColors.border.replace('/30', '')}` }}>
        <div className="flex items-center gap-3">
          <div 
            className="w-9 h-9 rounded-lg flex items-center justify-center border"
            style={{ 
              background: `linear-gradient(135deg, ${themeColors.primary}-900/40 0%, ${themeColors.primary}-950/60 100%)`,
              borderColor: `${themeColors.primary}-700/50`,
              boxShadow: `0 0 12px ${themeColors.primary}-900/30`
            }}
          >
            <Mountain size={18} className={`text-${themeColors.primary}-300`} />
          </div>
          <div>
            <h3 className="text-base font-display font-bold" style={{ color: themeColors.text === 'stone' ? '#e7e5e4' : `var(--color-${themeColors.primary}-200)` }}>
              {t(`map.${selectedChapter.id}`)}
            </h3>
          </div>
        </div>

        <div className="flex items-center gap-1.5 px-3 py-1.5 rounded-lg border" style={{ backgroundColor: `${themeColors.primary}-950/30`, borderColor: `${themeColors.primary}-800/30` }}>
          <span className="text-[11px]" style={{ color: themeColors.text === 'stone' ? '#a8a29e' : `var(--color-${themeColors.primary}-300)` }}>
            {selectedChapter.levelRange}
          </span>
          <span style={{ color: themeColors.text === 'stone' ? '#57534e' : `var(--color-${themeColors.primary}-700)` }}>路</span>
          <span className="text-[11px] font-medium" style={{ color: themeColors.text === 'stone' ? '#d6d3d1' : `var(--color-${themeColors.primary}-200)` }}>
            {t('map.level', { level: playerLevel })}
          </span>
        </div>

        <div className="flex items-center gap-3">
          <div className="flex flex-col items-end gap-1">
            <span className="text-[10px] font-medium" style={{ color: themeColors.text === 'stone' ? '#a8a29e' : `var(--color-${themeColors.primary}-300)` }}>
              {t('map.progress')} {selectedChapterProgress.cleared}/{selectedChapterProgress.total}
            </span>
            <div className="w-24 h-1.5 rounded-full overflow-hidden" style={{ backgroundColor: `${themeColors.primary}-950/50` }}>
              <motion.div 
                className="h-full rounded-full"
                style={{ backgroundColor: themeColors.primary === 'stone' ? '#a8a29e' : `var(--color-${themeColors.primary}-500)` }}
                initial={{ width: 0 }}
                animate={{ width: `${(selectedChapterProgress.cleared / selectedChapterProgress.total) * 100}%` }}
                transition={{ duration: 0.8, ease: 'easeOut' }}
              />
            </div>
          </div>
          <div 
            className="w-10 h-10 rounded-lg flex items-center justify-center border"
            style={{ 
              background: `linear-gradient(135deg, ${themeColors.primary}-900/30 0%, ${themeColors.primary}-950/50 100%)`,
              borderColor: `${themeColors.primary}-700/40`,
            }}
          >
            <span className="text-sm font-bold" style={{ color: themeColors.text === 'stone' ? '#d6d3d1' : `var(--color-${themeColors.primary}-200)` }}>
              {Math.round((selectedChapterProgress.cleared / selectedChapterProgress.total) * 100)}%
            </span>
          </div>
        </div>
      </header>

      <div
        ref={mapViewportRef}
        className="flex-1 min-h-0 rounded-xl border relative overflow-hidden cursor-grab active:cursor-grabbing"
        style={{
          background: chapterThemeStyles[selectedChapter.theme]?.background,
          borderColor: themeColors.border.replace('/30', ''),
        }}
        onPointerDown={onPointerDown}
        onPointerMove={onPointerMove}
        onPointerUp={onPointerUp}
        onPointerLeave={onPointerLeave}
      >
        <div
          className="absolute inset-0"
          style={{
            transform: `translate(${offset.x}px, ${offset.y}px)`,
            transformOrigin: '50% 50%',
          }}
        >
          <svg className="absolute inset-0 w-full h-full pointer-events-none overflow-visible">
            <defs>
              <linearGradient id="pathGradientCleared" x1="0%" y1="0%" x2="100%" y2="0%">
                <stop offset="0%" stopColor={chapterThemeStyles[selectedChapter.theme]?.pathColor} stopOpacity="0.9" />
                <stop offset="50%" stopColor="rgba(255, 80, 80, 0.85)" />
                <stop offset="100%" stopColor={chapterThemeStyles[selectedChapter.theme]?.pathColor} stopOpacity="0.9" />
              </linearGradient>
              <linearGradient id="pathGradientReady" x1="0%" y1="0%" x2="100%" y2="0%">
                <stop offset="0%" stopColor={chapterThemeStyles[selectedChapter.theme]?.pathColor} stopOpacity="0.7" />
                <stop offset="50%" stopColor="rgba(200, 60, 60, 0.6)" />
                <stop offset="100%" stopColor={chapterThemeStyles[selectedChapter.theme]?.pathColor} stopOpacity="0.7" />
              </linearGradient>
              <filter id="pathGlow">
                <feGaussianBlur stdDeviation="4" result="coloredBlur"/>
                <feMerge>
                  <feMergeNode in="coloredBlur"/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>
              <filter id="bloodGlow">
                <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
                <feFlood floodColor="#8b0000" floodOpacity="0.8"/>
                <feComposite in2="coloredBlur" operator="in"/>
                <feMerge>
                  <feMergeNode/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>
            </defs>
            {selectedChapter.nodes.slice(0, -1).map((node, index) => {
              const nextNode = selectedChapter.nodes[index + 1];
              const currentPos = getZigzagNodePosition(index);
              const nextPos = getZigzagNodePosition(index + 1);
              const currentCleared = isNodeCleared(normalizedProgress, node.id);
              const nextUnlocked = isNodeUnlocked(normalizedProgress, nextNode.id);
              const themePathColor = chapterThemeStyles[selectedChapter.theme]?.pathColor || 'rgb(100, 50, 50)';
              const pathColor = currentCleared ? 'url(#pathGradientCleared)' : nextUnlocked ? 'url(#pathGradientReady)' : themePathColor + '40';
              return (
                  <g key={`${node.id}-${nextNode.id}`}>
                    <motion.line
                      x1={`${currentPos.x}%`}
                      y1={`${currentPos.y}%`}
                      x2={`${nextPos.x}%`}
                      y2={`${nextPos.y}%`}
                      stroke={pathColor}
                      strokeWidth="3"
                      strokeDasharray={currentCleared ? "none" : "8 6"}
                      strokeLinecap="round"
                      filter={currentCleared || nextUnlocked ? "url(#pathGlow)" : undefined}
                      initial={{ pathLength: 0 }}
                      animate={{ pathLength: 1 }}
                      transition={{ duration: 0.8, delay: index * 0.15 }}
                    />
                    <motion.line
                      x1={`${currentPos.x}%`}
                      y1={`${currentPos.y}%`}
                      x2={`${nextPos.x}%`}
                      y2={`${nextPos.y}%`}
                      stroke={currentCleared ? "rgba(255,255,255,0.4)" : nextUnlocked ? "rgba(255,255,255,0.2)" : "rgba(255,255,255,0.05)"}
                      strokeWidth="1"
                      strokeDasharray={currentCleared ? "none" : "8 6"}
                      strokeLinecap="round"
                      initial={{ pathLength: 0 }}
                      animate={{ pathLength: 1 }}
                      transition={{ duration: 0.8, delay: index * 0.15 + 0.1 }}
                    />
                  </g>
              );
            })}
          </svg>

          {selectedChapter.nodes.map((node, nodeIndex) => (
            <MapNode
              key={node.id}
              node={node}
              nodeIndex={nodeIndex}
              selectedChapter={selectedChapter}
              normalizedProgress={normalizedProgress}
              playerLevel={playerLevel}
              loading={loading}
              onEnterNode={onEnterNode}
              onHoverStart={() => setHoveredNode(node.id)}
              onHoverEnd={() => setHoveredNode(null)}
            />
          ))}
        </div>
      </div>
    </section>
  );
}


===================== [D:\download\LootingRPG\src\components\game\tabs\ForgeTab.tsx] =====================
import { Sparkles } from 'lucide-react';
import { motion } from 'motion/react';
import { LOCK_COST, QUALITY_CONFIG, REROLL_BASE_COST } from '../../../config/game/equipment';
import { getSlotLabel, getStatLabel } from '../../../infra/i18n/labels';
import type { Equipment, GameState } from '../../../types/game';
import { useTranslation } from 'react-i18next';
import { useMemo, useState } from 'react';
import { calculateEnchantCost, previewEnchant } from '../../../domains/inventory/services/equipment';


interface ForgeTabProps {
  gameState: GameState;
  selectedId: string | null;
  loading: boolean;
  onSelect: (id: string) => void;
  onForge: (id: string) => void;
  onReroll: (id: string, lockTypes?: string[]) => void;
}

type ForgeCandidate = {
  item: Equipment;
  source: string;
};

export function ForgeTab({ gameState, selectedId, loading, onSelect, onForge, onReroll }: ForgeTabProps) {
  const { t } = useTranslation();

  const equipped = (Object.entries(gameState.currentEquipment) as [string, Equipment | null][])
    .filter(([, item]) => Boolean(item))
    .map(([slot, item]) => ({ item: { ...(item as Equipment), equipped: true }, source: t('label.equipped') + '/' + getSlotLabel(slot) }));

  const backpack = gameState.backpack.map((item) => ({ item: { ...item, equipped: false }, source: t('label.backpack') }));
  const deduped = new Map<string, ForgeCandidate>();
  [...equipped, ...backpack].forEach((entry) => {
    deduped.set(entry.item.id, entry);
  });
  const candidates: ForgeCandidate[] = [...deduped.values()];

  const selected = candidates.find((entry) => entry.item.id === selectedId)?.item ?? candidates[0]?.item;

  // UI state for Forge interactions
  const [lockedTypes, setLockedTypes] = useState<string[]>([]);
  const [previewTimes, setPreviewTimes] = useState<number>(1);
  const [previewResult, setPreviewResult] = useState<Equipment | null>(null);
  const [confirmOpen, setConfirmOpen] = useState(false);

  const toggleLock = (type: string) => {
    setLockedTypes((prev) => (prev.includes(type) ? prev.filter((p) => p !== type) : [...prev, type]));
  };

  const enchantCost = useMemo(() => (selected ? calculateEnchantCost(selected) * previewTimes : 0), [selected, previewTimes]);
  const rerollCost = useMemo(() => {
    if (!selected) return 0;
    return REROLL_BASE_COST * ((selected.enhancementLevel || 0) + 1) + lockedTypes.length * LOCK_COST;
  }, [selected, lockedTypes]);

  if (!selected) {
    return (
      <motion.div key="forge" initial={{ opacity: 0, x: 20 }} animate={{ opacity: 1, x: 0 }} exit={{ opacity: 0, x: -20 }} className="h-full flex flex-col items-center justify-center space-y-6">
        <div className="text-center space-y-2">
          <Sparkles className="mx-auto text-red-400" size={48} />
          <h2 className="text-xl font-display">{t('ui.forgeCenter')}</h2>
          <p className="text-sm text-gray-500">{t('ui.no_forge_items')}</p>
        </div>
      </motion.div>
    );
  }

  const qualityColor = QUALITY_CONFIG[selected.quality]?.color || 'text-gray-400';

  return (
    <motion.div
      key="forge"
      initial={{ opacity: 0, x: 20 }}
      animate={{ opacity: 1, x: 0 }}
      exit={{ opacity: 0, x: -20 }}
      className="h-full grid grid-cols-1 gap-4 overflow-hidden"
      style={{ gridTemplateColumns: selected ? '35% 65%' : undefined }}
    >
      <div className="h-full overflow-y-auto pr-2 space-y-2">
        {candidates.map(({ item, source }) => (
          <button
            key={item.id}
            onClick={() => onSelect(item.id)}
            className={`w-full p-3 rounded-lg border text-left transition-all duration-200 cursor-pointer ${selected.id === item.id ? 'border-red-700 bg-red-900/10 hover:border-red-600' : 'border-game-border/50 bg-game-bg/50 hover:border-red-800/50 hover:bg-game-card/50'}`}
          >
            <div className="flex items-center justify-between gap-2">
              <div className="min-w-0">
                <p className={`text-sm font-bold truncate flex items-center gap-1 ${QUALITY_CONFIG[item.quality]?.color || 'text-gray-200'}`}>
                  <span className="text-base leading-none">{item.icon || '馃О'}</span>
                  {item.name} {item.enhancementLevel > 0 ? `+${item.enhancementLevel}` : ''}
                </p>
                <p className="text-[10px] text-gray-500 mt-1">{getSlotLabel(item.slot)} 路 {source}</p>
              </div>
              {item.equipped && (
                <span className="text-[10px] px-2 py-0.5 rounded-full bg-red-900/20 text-red-400 border border-red-700/30 font-bold">
                  宸茶澶?                </span>
              )}
            </div>
          </button>
        ))}
      </div>

      <div className="bg-game-bg/80 border border-game-border/50 rounded-xl p-4 space-y-4 overflow-y-auto">
        <div>
          <h3 className={`text-base font-bold ${qualityColor} flex items-center gap-1`}>
            <span className="text-lg leading-none">{selected.icon || '馃О'}</span>
            {selected.name} {selected.enhancementLevel > 0 ? `+${selected.enhancementLevel}` : ''}
          </h3>
          <p className="text-xs text-gray-500">{selected.slot} 鈥?{selected.quality}</p>
        </div>

        <div className="space-y-1">
          {Object.entries(selected.attributes).map(([key, value]) => (
            <div key={key} className="flex justify-between text-sm">
              <span className="text-gray-400">{getStatLabel(key)}</span>
              <span className="font-mono text-gray-200">+{value}</span>
            </div>
          ))}
        </div>

        {selected.affixes && selected.affixes.length > 0 && (
          <div className="mt-2">
            <h4 className="text-xs text-gray-400 mb-1">{t('label.affixes') || 'Affixes'}</h4>
            <div className="flex flex-col gap-2">
              {selected.affixes.map((affix, idx) => {
                const labelMap: Record<string, string> = {
                  crit_chance: t('stat.crit'),
                  lifesteal: t('stat.lifesteal'),
                  damage_bonus: t('stat.damage'),
                  thorns: t('trait.thorns'),
                  hp_bonus: t('stat.hp'),
                };
                const isLocked = lockedTypes.includes(affix.type);
                return (
                  <div key={`${affix.type}-${idx}`} className="flex items-center justify-between gap-2">
                    <div className="flex items-center gap-3">
                      <span className="text-[12px] px-2 py-1 rounded border border-white/10 bg-game-card/20 text-gray-200">{labelMap[affix.type] || affix.type}</span>
                      <span className="font-mono text-gray-200">+{affix.value}</span>
                    </div>
                    <div className="flex items-center gap-2">
                      <button
                        aria-pressed={isLocked}
                        onClick={() => toggleLock(affix.type)}
                        className={`px-2 py-1 rounded ${isLocked ? 'bg-red-800 text-white' : 'bg-game-card/10 text-gray-200'} text-xs`}
                      >
                        {isLocked ? t('ui.forge.lock') || 'Lock' : t('ui.forge.unlock') || 'Lock'}
                      </button>
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        )}

        {selected.special && <p className="text-xs text-red-400 italic">鈽?{selected.special}</p>}

        <div className="grid grid-cols-1 gap-3 pt-2">
          <div className="flex items-center gap-2">
            <label className="text-sm text-gray-400">{t('ui.forge.preview_times') || 'Preview'}</label>
            <div className="flex gap-2 ml-2">
              {[1, 5, 10].map((n) => (
                <button key={n} onClick={() => setPreviewTimes(n)} className={`px-3 py-1 rounded text-sm ${previewTimes === n ? 'bg-red-700 text-white' : 'bg-game-card/10 text-gray-200'}`}>{n}</button>
              ))}
            </div>
            <div className="ml-auto text-sm text-gray-400">{t('ui.forge.cost') || 'Cost'}: <span className="font-mono">{enchantCost}</span></div>
          </div>

          <div className="flex gap-3 w-full">
            <button
              onClick={() => {
                if (!selected) return;
                const preview = previewEnchant(JSON.parse(JSON.stringify(selected)), previewTimes);
                setPreviewResult(preview);
              }}
              disabled={loading}
              className="w-1/3 min-w-0 py-2 rounded-lg border border-red-700/30 bg-red-900/10 text-red-400 hover:bg-red-700 hover:text-white text-sm font-bold text-center whitespace-nowrap"
            >
              {t('ui.forge.preview') || 'Preview'}
            </button>
            <button
              onClick={() => setConfirmOpen(true)}
              disabled={loading || gameState.playerStats.gold < enchantCost}
              className="w-1/3 min-w-0 py-2 rounded-lg border border-yellow-500/30 bg-yellow-500/10 text-yellow-400 hover:bg-yellow-500 hover:text-white text-sm font-bold text-center whitespace-nowrap"
            >
              {t('ui.forge.apply') || 'Apply'} ({enchantCost})
            </button>
            <button
              onClick={() => {
                if (!selected) return;
                onReroll(selected.id, lockedTypes);
              }}
              disabled={loading || gameState.playerStats.gold < rerollCost}
              className="w-1/3 min-w-0 py-2 rounded-lg border border-blue-500/30 bg-blue-500/10 text-blue-400 hover:bg-blue-500 hover:text-white text-sm font-bold text-center whitespace-nowrap"
            >
              {t('ui.forge.reroll') || 'Reroll'} ({rerollCost})
            </button>
          </div>
        </div>
      </div>
      
      {/* Confirm Modal */}
      {confirmOpen && selected && (
        <div className="fixed inset-0 z-[9999] flex items-center justify-center">
          <div className="absolute inset-0 bg-black/50" onClick={() => setConfirmOpen(false)} />
          <div className="relative bg-game-bg border border-game-border rounded-lg p-6" style={{ width: 'min(92%,560px)' }}>
            <h3 className="text-lg font-bold mb-2">{t('ui.forge.confirm_title') || 'Confirm Enchant'}</h3>
            <p className="text-sm text-gray-300 mb-4">{t('ui.forge.confirm_body') || 'This will consume resources and apply the enchant.'}</p>
            {previewResult && (
              <div className="mb-4">
                <h4 className="text-sm text-gray-400 mb-2">{t('ui.forge.preview') || 'Preview'}</h4>
                <div className="space-y-2">
                  {Object.entries(previewResult.attributes).map(([k, v]) => (
                    <div key={k} className="flex justify-between text-sm">
                      <span className="text-gray-400">{getStatLabel(k)}</span>
                      <span className="font-mono text-gray-200">+{v}</span>
                    </div>
                  ))}
                </div>
              </div>
            )}
            <div className="flex justify-end gap-2">
              <button onClick={() => setConfirmOpen(false)} className="px-4 py-2 rounded bg-game-card/10">{t('button.cancel') || 'Cancel'}</button>
              <button
                onClick={() => {
                  setConfirmOpen(false);
                  for (let i = 0; i < previewTimes; i++) {
                    onForge(selected.id);
                  }
                }}
                className="px-4 py-2 rounded bg-yellow-500 text-white"
              >
                {t('button.confirm') || 'Confirm'}
              </button>
            </div>
          </div>
        </div>
      )}
    </motion.div>
  );
}


===================== [D:\download\LootingRPG\src\components\game\tabs\InventoryTab.tsx] =====================
import { Package, Shield, Zap, Gem, Crown, Star, Hexagon } from 'lucide-react';
import { QUALITIES, QUALITY_CONFIG } from '../../../config/game/equipment';
import { getQualityLabel } from '../../../infra/i18n/labels';
import { useMemo, useState, useCallback } from 'react';
import type { Equipment } from '../../../types/game';
import { useTranslation } from 'react-i18next';
import { motion } from 'motion/react';
import type { ReactNode } from 'react';
import { ItemCard } from '../ItemCard';

const iconMap: Record<string, ReactNode> = {
  shield: <Shield size={14} className="text-gray-400" />,
  zap: <Zap size={14} className="text-emerald-400" />,
  gem: <Gem size={14} className="text-blue-400" />,
  hexagon: <Hexagon size={14} className="text-red-400" />,
  crown: <Crown size={14} className="text-yellow-400" />,
  star: <Star size={14} className="text-red-400" />,
};

interface InventoryTabProps {
  items: Equipment[];
  loading: boolean;
  onEquip: (id: string) => void;
  onSell: (id: string) => void;
  onForge: (id: string) => void;
  onQuickSellByQualityRange: (minQuality: string, maxQuality: string) => void;
  autoSellQualities: Record<string, boolean>;
  onToggleAutoSellQuality: (quality: string) => void;
}

type SortField = 'quality' | 'price' | 'name' | 'enchantment';
type SortOrder = 'asc' | 'desc';

export function InventoryTab({
  items,
  loading,
  onEquip,
  onSell,
  onForge,
  onQuickSellByQualityRange,
  autoSellQualities,
  onToggleAutoSellQuality,
}: InventoryTabProps) {
  const [sortField, setSortField] = useState<SortField>('quality');
  const [sortOrder, setSortOrder] = useState<SortOrder>('desc');
  const { t } = useTranslation();
  const [sellMinQuality, setSellMinQuality] = useState(QUALITIES[0]);
  const [sellMaxQuality, setSellMaxQuality] = useState(QUALITIES[2]);

  const qualityIndexMap = useMemo((): Record<string, number> => {
    const map: Record<string, number> = {};
    QUALITIES.forEach((quality, index) => {
      map[quality] = index;
    });
    return map;
  }, []);

  const sortedItems = useMemo(() => {
    const direction = sortOrder === 'asc' ? 1 : -1;
    return [...items].sort((a, b) => {
      if (sortField === 'quality') {
        return ((qualityIndexMap[a.quality] ?? 0) - (qualityIndexMap[b.quality] ?? 0)) * direction;
      }
      if (sortField === 'price') {
        const pa = QUALITY_CONFIG[a.quality]?.price || 0;
        const pb = QUALITY_CONFIG[b.quality]?.price || 0;
        return (pa - pb) * direction;
      }
      if (sortField === 'enchantment') {
        return (a.enhancementLevel - b.enhancementLevel) * direction;
      }
      return a.name.localeCompare(b.name, 'zh-Hans-CN') * direction;
    });
  }, [items, qualityIndexMap, sortField, sortOrder]);

  const handleEquip = useCallback((id: string) => onEquip(id), [onEquip]);
  const handleSell = useCallback((id: string) => onSell(id), [onSell]);
  const handleForge = useCallback((id: string) => onForge(id), [onForge]);

  return (
    <motion.div key="inventory" initial={{ opacity: 0, scale: 0.95 }} animate={{ opacity: 1, scale: 1 }} exit={{ opacity: 0, scale: 0.95 }} className="h-full flex flex-col gap-3">
      <section className="border border-game-border rounded-xl bg-game-bg/60 p-3">
        <p className="text-xs text-gray-400 mb-2">{t('ui.autoSellHint')}</p>
        <div className="grid grid-cols-3 md:grid-cols-6 gap-2">
          {QUALITIES.map((quality) => (
            <label key={quality} className="flex items-center gap-1.5 text-xs text-gray-300 cursor-pointer hover:bg-game-card/30 p-1.5 rounded-lg transition-colors">
              <input
                type="checkbox"
                checked={Boolean(autoSellQualities[quality])}
                onChange={() => onToggleAutoSellQuality(quality)}
                className="accent-red-700"
              />
              <span className="flex items-center gap-1">
                {iconMap[QUALITY_CONFIG[quality]?.iconName || 'shield']}
                {getQualityLabel(quality)}
              </span>
            </label>
          ))}
        </div>
      </section>

      <section className="border border-game-border rounded-xl bg-game-bg/60 p-3 space-y-3">
        <p className="text-xs text-gray-400">{t('ui.quickSellAndSort')}</p>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
          <div className="flex flex-wrap items-center gap-2">
            <span className="text-xs text-gray-400">{t('label.sellRange')}</span>
            <select
              value={sellMinQuality}
              onChange={(event) => setSellMinQuality(event.target.value)}
              className="text-xs bg-game-bg border border-game-border rounded px-2 py-1 text-gray-200"
            >
              {QUALITIES.map((quality) => (
                <option key={`min-${quality}`} value={quality}>{getQualityLabel(quality)}</option>
              ))}
            </select>
            <span className="text-xs text-gray-500">{t('label.to')}</span>
              <select
              value={sellMaxQuality}
              onChange={(event) => setSellMaxQuality(event.target.value)}
              className="text-xs bg-game-bg border border-game-border rounded px-2 py-1 text-gray-200"
            >
              {QUALITIES.map((quality) => (
                  <option key={`max-${quality}`} value={quality}>{getQualityLabel(quality)}</option>
              ))}
            </select>
            <button
              onClick={() => onQuickSellByQualityRange(sellMinQuality, sellMaxQuality)}
              disabled={loading || sortedItems.length === 0}
              className="text-xs px-3 py-1 rounded-lg border border-red-500/30 bg-red-500/10 hover:bg-red-500 text-red-300 hover:text-white disabled:opacity-40 disabled:cursor-not-allowed transition-colors"
            >
              {t('button.quickSell')}
            </button>
          </div>

          <div className="flex flex-wrap items-center gap-2">
            <span className="text-xs text-gray-400">{t('label.sort')}</span>
              <select
              value={sortField}
              onChange={(event) => setSortField(event.target.value as SortField)}
              className="text-xs bg-game-bg border border-game-border rounded px-2 py-1 text-gray-200"
            >
              <option value="quality">{t('label.quality')}</option>
              <option value="price">{t('label.price')}</option>
              <option value="enchantment">{t('label.enchantLevel')}</option>
              <option value="name">{t('label.name')}</option>
            </select>
            <select
              value={sortOrder}
              onChange={(event) => setSortOrder(event.target.value as SortOrder)}
              className="text-xs bg-game-bg border border-game-border rounded px-2 py-1 text-gray-200"
            >
              <option value="desc">{t('label.desc')}</option>
              <option value="asc">{t('label.asc')}</option>
            </select>
          </div>
        </div>
      </section>

      <div className="h-[420px] overflow-y-auto grid grid-cols-1 sm:grid-cols-2 gap-3 pr-2">
        {sortedItems.length === 0 ? (
          <div className="col-span-full flex flex-col items-center justify-center h-64 text-gray-600">
            <Package size={48} className="mb-2 opacity-20" />
            <p>{t('message.empty_inventory')}</p>
          </div>
        ) : (
          sortedItems.map((item) => (
            <div key={item.id}>
              <ItemCard
                item={item}
                readonly={item.equipped}
                onEquip={() => handleEquip(item.id)}
                onSell={() => handleSell(item.id)}
                onForge={() => handleForge(item.id)}
                loading={loading}
              />
            </div>
          ))
        )}
      </div>
    </motion.div>
  );
}


===================== [D:\download\LootingRPG\src\components\game\tabs\MapTab.tsx] =====================
import { normalizeMapProgress, getChapterProgress} from '../../../domains/map/services/progress';
import type { MapChapterDef, MapNodeDef } from '../../../config/map/ChapterData';
import { Star, ChevronDown, Mountain, Lock } from 'lucide-react';
import { MAP_CHAPTERS } from '../../../config/map/ChapterData';
import type { MapProgressState } from '../../../shared/types/game';
import { themeColors } from '../../../config/map/mapNode';
import { motion, AnimatePresence } from 'motion/react';
import { useTranslation } from 'react-i18next';
import MapViewport from '../map/MapViewport';
import { useMemo, useState } from 'react';
interface MapTabProps {
  playerLevel: number;
  loading: boolean;
  progress: MapProgressState;
  onSelectChapter: (chapterId: string) => void;
  onEnterNode: (node: MapNodeDef, chapter: MapChapterDef) => void;
  focusNodeId?: string | null;
  onClearFocus?: () => void;
}

export function MapTab({ playerLevel, loading, progress, onSelectChapter, onEnterNode, focusNodeId, onClearFocus }: MapTabProps) {
  const { t } = useTranslation();
  const [dropdownOpen, setDropdownOpen] = useState(false);
  const normalizedProgress = useMemo(() => normalizeMapProgress(progress, MAP_CHAPTERS), [progress]);

  const selectedChapter = useMemo(
    () =>
      MAP_CHAPTERS.find((c) => c.id === normalizedProgress.selectedChapterId) ?? MAP_CHAPTERS[0],
    [normalizedProgress.selectedChapterId]
  );

  const selectedChapterProgress = useMemo(
    () =>
      selectedChapter ? getChapterProgress(normalizedProgress, selectedChapter) : { cleared: 0, total: 0, completed: false },
    [normalizedProgress, selectedChapter]
  );

  const totalStars = useMemo(() => {
    let stars = 0;
    MAP_CHAPTERS.forEach(chapter => {
      const chapterProgress = getChapterProgress(normalizedProgress, chapter);
      if (chapterProgress.completed) stars += chapter.nodes.length;
    });
    return stars;
  }, [normalizedProgress]);

  const chapterThemeColors = themeColors[selectedChapter.theme];

  return (
    <motion.div
      key="map"
      initial={{ opacity: 0, y: 10, scale: 0.98 }}
      animate={{ opacity: 1, y: 0, scale: 1 }}
      exit={{ opacity: 0, y: -10, scale: 0.98 }}
      transition={{ duration: 0.3 }}
      className="h-full flex flex-col"
    >
      <div className="flex items-center justify-between gap-3">
        <div className="relative">
          <button
            onClick={() => setDropdownOpen(!dropdownOpen)}
            className="flex items-center gap-2 px-3 py-1.5 bg-stone-900/60 backdrop-blur-sm rounded-lg border transition-all cursor-pointer hover:bg-stone-800/60"
            style={{ borderColor: `${chapterThemeColors.primary}33` }}
          >
            <Mountain size={16} style={{ color: chapterThemeColors.primaryLight }} />
            <span className="text-sm font-medium" style={{ color: chapterThemeColors.primaryLight }}>{t(`map.${selectedChapter.id}`)}</span>
            <ChevronDown size={14} className={`text-stone-500 transition-transform ${dropdownOpen ? 'rotate-180' : ''}`} />
          </button>

          <AnimatePresence>
            {dropdownOpen && (
              <>
                <div className="fixed inset-0 z-40" onClick={() => setDropdownOpen(false)} />
                <motion.div
                  initial={{ opacity: 0, y: 4 }}
                  animate={{ opacity: 1, y: 0 }}
                  exit={{ opacity: 0, y: 4 }}
                  className="absolute top-full mt-1 left-0 z-50 bg-stone-900/95 backdrop-blur-xl rounded-lg border border-white/10 shadow-xl py-1 min-w-[220px]"
                >
                  {MAP_CHAPTERS.map((chapter) => {
                    const unlocked = normalizedProgress.unlockedChapters.includes(chapter.id);
                    const chapterProgress = getChapterProgress(normalizedProgress, chapter);
                    const chapterColors = themeColors[chapter.theme];
                    
                    return (
                      <button
                        key={chapter.id}
                        disabled={!unlocked}
                        onClick={() => { onSelectChapter(chapter.id); setDropdownOpen(false); }}
                        className={`w-full flex items-center gap-2 px-3 py-2 text-left transition-colors cursor-pointer ${selectedChapter.id === chapter.id ? 'bg-white/5' : 'hover:bg-white/5'}`}
                        style={{ opacity: unlocked ? 1 : 0.4 }}
                      >
                        <Mountain size={14} style={{ color: chapterColors.primaryLight }} />
                        <span className="flex-1 text-sm text-stone-200">{t(`map.${chapter.id}`)}</span>
                        {chapterProgress.completed && <Star size={12} className="text-amber-400" fill="currentColor" />}
                        {!unlocked && <Lock size={12} className="text-stone-500" />}
                      </button>
                    );
                  })}
                </motion.div>
              </>
            )}
          </AnimatePresence>
        </div>

        <div className="flex items-center gap-2 text-xs">
          <Star size={12} className="text-amber-400" fill="currentColor" />
          <span className="text-stone-400">{totalStars}</span>
          <span className="text-stone-600">|</span>
          <span className="text-stone-500">{selectedChapter.levelRange}</span>
          <span className="text-stone-600">|</span>
          <span style={{ color: chapterThemeColors.primaryLight }}>{selectedChapterProgress.cleared}/{selectedChapterProgress.total}</span>
          <span className="text-stone-600">|</span>
          <span className="px-1.5 py-0.5 rounded font-medium" style={{ 
            backgroundColor: `${chapterThemeColors.primary}22`, 
            color: chapterThemeColors.primaryLight 
          }}>
            {Math.round((selectedChapterProgress.cleared / selectedChapterProgress.total) * 100)}%
          </span>
        </div>
      </div>

      <MapViewport
        playerLevel={playerLevel}
        loading={loading}
        normalizedProgress={normalizedProgress}
        selectedChapter={selectedChapter}
        selectedChapterProgress={selectedChapterProgress}
        onEnterNode={onEnterNode}
        focusNodeId={focusNodeId}
        onClearFocus={onClearFocus}
      />
    </motion.div>
  );
}


===================== [D:\download\LootingRPG\src\components\game\tabs\MonsterCodexTab.tsx] =====================
import { useState } from 'react';
import { motion, AnimatePresence } from 'motion/react';
import { BookOpen, Crown, Skull, Heart, Swords, Shield, Flame, Zap, Info } from 'lucide-react';
import { useTranslation } from 'react-i18next';
import type { TFunction } from 'i18next';
import { BOSS_MONSTERS, NORMAL_MONSTERS } from '../../../domains/monster/services/monsterCatalog';
import { UI_DIMENSIONS } from '../../../config/ui/tokens';
import { traitScoreMap, counterGoalScoreMap, StrategyTag } from '../../../config/game/monsterSchema';
import type {MonsterTrait, ThreatType } from '../../../shared/types/game';
import type { Monster } from '../../../shared/types/game';
const traitColorMap: Record<MonsterTrait, string> = {
  thorns: 'border-rose-400/30 bg-rose-500/10 text-rose-200',
  lifesteal: 'border-emerald-400/30 bg-emerald-500/10 text-emerald-200',
  double_attack: 'border-orange-400/30 bg-orange-500/10 text-orange-200',
  shield_on_start: 'border-blue-400/30 bg-blue-500/10 text-blue-200',
  rage_on_low_hp: 'border-red-400/30 bg-red-500/10 text-red-200',
};

const strategyTagStyleMap: Record<StrategyTag, string> = {
  offense: 'border-rose-400/35    bg-rose-500/10    text-rose-200',
  defense: 'border-blue-400/35    bg-blue-500/10    text-blue-200',
  sustain: 'border-emerald-400/35 bg-emerald-500/10 text-emerald-200',
};
const threatStyleMap: Record<ThreatType, string> = {
  burst_punish: 'border-fuchsia-400/35 bg-fuchsia-500/10 text-fuchsia-200',
  sustain_pressure: 'border-rose-400/35 bg-rose-500/10 text-rose-200',
  tank_breaker: 'border-amber-400/35 bg-amber-500/10 text-amber-200',
  attrition: 'border-cyan-400/35 bg-cyan-500/10 text-cyan-200',
};

const inferThreatTypes = (monster: Monster): ThreatType[] => {
  if (monster.threatTypes?.length) return monster.threatTypes;

  const result: ThreatType[] = [];
  const traits = monster.traits ?? [];

  if (traits.includes('thorns') || traits.includes('shield_on_start')) {
    result.push('burst_punish');
  }
  if (traits.includes('double_attack') || traits.includes('rage_on_low_hp')) {
    result.push('sustain_pressure');
  }
  if (traits.includes('shield_on_start') || monster.counterGoal?.stat === 'attack') {
    result.push('tank_breaker');
  }
  if (traits.includes('lifesteal') || monster.counterGoal?.stat === 'hp' || monster.counterGoal?.stat === 'lifesteal') {
    result.push('attrition');
  }

  if (monster.monsterType === 'boss' && result.length === 0) {
    result.push('sustain_pressure');
  }

  if (result.length === 0) {
    result.push('tank_breaker');
  }

  return result.slice(0, 2);
};

const getStrategyTags = (monster: Monster): StrategyTag[] => {
  const score: Record<StrategyTag, number> = {
    offense: 0,
    defense: 0,
    sustain: 0,
  };
  if (monster.monsterType === 'boss') {
    score.defense += 1;
    score.sustain += 1;
  }
  (monster.traits ?? []).forEach((trait) => {
    const traitScores = traitScoreMap[trait];
    if (traitScores) {
      Object.entries(traitScores).forEach(([key, value]) => {
        score[key as StrategyTag] += value ?? 0;
      });
    }
  });

  if (monster.counterGoal?.stat) {
    const tag = counterGoalScoreMap[monster.counterGoal.stat];
    if (tag) {
      score[tag] += 2;
    }
  }

  return (Object.entries(score) as [StrategyTag, number][])
    .sort((a, b) => b[1] - a[1])
    .filter(([, value], index) => value > 0 || index === 0)
    .slice(0, 2)
    .map(([tag]) => tag);
};

type CodexTranslator = TFunction;

const getStrategyHints = (monster: Monster, t: CodexTranslator): string[] => {
  const hints: string[] = [];

  if (monster.monsterType === 'boss') {
    hints.push(String(t('codex.hints.bossIntro')));
  } else {
    hints.push(String(t('codex.hints.normalIntro')));
  }

  (monster.traits ?? []).forEach((trait) => {
    const translateUnknown = t as unknown as (k: string, opts?: Record<string, unknown>) => unknown;
    const traitHints: unknown = translateUnknown(`trait.hints.${trait}`, { returnObjects: true });

    if (Array.isArray(traitHints)) {
      traitHints.forEach((text) => {
        if (typeof text === 'string' && !hints.includes(text)) hints.push(text);
      });
    } else if (typeof traitHints === 'string' && !hints.includes(traitHints)) {
      hints.push(traitHints);
    }
  });

  if (monster.counterGoal) {
    hints.push(String(t('codex.hints.counterGoal')));
    if (monster.counterGoal.successText && !hints.includes(monster.counterGoal.successText)) {
      hints.push(monster.counterGoal.successText);
    }
    if (monster.counterGoal.failText && !hints.includes(monster.counterGoal.failText)) {
      hints.push(monster.counterGoal.failText);
    }
  }

  if (!monster.traits?.length && !monster.counterGoal) {
    hints.push(String(t('codex.hints.simple')));
  }

  return hints.slice(0, 4);
};

function TraitTags({ traits, t }: { traits?: MonsterTrait[]; t: (k: string) => string }) {
  if (!traits?.length) {
    return <span className="text-[10px] text-gray-500">{t('trait.none')}</span>;
  }

  return (
    <div className="flex flex-wrap gap-1.5">
      {traits.map((trait) => (
        <span
          key={trait}
          className={`text-[10px] px-2 py-0.5 rounded border ${traitColorMap[trait] || 'border-red-400/30 bg-red-900/10 text-red-200'}`}
        >
          {t(`trait.${trait}`)}
        </span>
      ))}
    </div>
  );
}

function MonsterListItem({
  monster,
  isSelected,
  isBoss,
  onClick,
}: {
  monster: Monster;
  isSelected: boolean;
  isBoss: boolean;
  onClick: () => void;
}) {
  return (
    <motion.button
      onClick={onClick}
      className={`w-full flex items-center gap-2 p-2 rounded-lg border transition-all duration-150 text-left ${
        isSelected
          ? isBoss
            ? 'border-rose-500/60 bg-rose-500/20'
            : 'border-red-700/60 bg-red-900/20'
          : isBoss
            ? 'border-rose-500/20 bg-rose-950/15 hover:border-rose-500/40 hover:bg-rose-500/10'
            : 'border-game-border/40 bg-game-bg/40 hover:border-red-800/40 hover:bg-red-900/10'
      }`}
    >
      <div
        style={{ width: `${UI_DIMENSIONS.codexIconSize}px`, height: `${UI_DIMENSIONS.codexIconSize}px` }}
        className={`rounded-md flex items-center justify-center text-lg flex-shrink-0 ${isBoss ? 'bg-rose-500/20' : 'bg-game-card/40'}`}
      >
        {monster.icons.map((ic: string, i: number) => (
          <span key={i}>{ic}</span>
        ))}
      </div>
      <div className="flex-1 min-w-0">
        <div className={`text-[11px] font-medium truncate ${isBoss ? 'text-rose-200' : 'text-gray-200'}`}>
          {monster.name}
        </div>
        <div className="text-[9px] text-gray-500 flex items-center gap-1.5">
          <span className="text-red-400/80">Lv.{monster.level}</span>
          <span className="text-red-400/70">{monster.maxHp}</span>
          <span className="text-orange-400/70">{monster.attack}</span>
          <span className="text-blue-400/70">{monster.defense}</span>
        </div>
      </div>
      {isBoss && <Crown size={11} className="text-yellow-400/60 flex-shrink-0" />}
    </motion.button>
  );
}

function MonsterDetailPanel({ monster, t }: { monster: Monster; t: CodexTranslator }) {
  const isBoss = monster.monsterType === 'boss';
  const strategyHints = getStrategyHints(monster, t);
  const strategyTags = getStrategyTags(monster);
  const threatTypes = inferThreatTypes(monster);

  return (
    <motion.div
      key={monster.id}
      initial={{ opacity: 0, x: 20 }}
      animate={{ opacity: 1, x: 0 }}
      exit={{ opacity: 0, x: -20 }}
      className="h-full flex flex-col"
    >
      <div className={`relative rounded-xl border p-3 flex-1 ${isBoss ? 'border-rose-500/30 bg-gradient-to-br from-rose-950/25 to-rose-900/10' : 'border-game-border/60 bg-game-bg/50'}`}>
        <div className="absolute -top-10 -right-10 w-24 h-24 bg-red-900/20 rounded-full blur-2xl" />
        
        <div className="relative z-10 h-full flex flex-col">
          <div className="flex items-center gap-2 mb-3">
            <motion.div
              whileHover={{ scale: 1.05 }}
              className={`w-12 h-12 rounded-lg flex items-center justify-center text-3xl ${isBoss ? 'bg-gradient-to-br from-rose-600/30 to-red-600/20 shadow-lg shadow-rose-500/15' : 'bg-game-card/60 shadow'}`}
            >
              {monster.icons.map((ic: string, i: number) => (<span key={i}>{ic}</span>))}
            </motion.div>
            <div className="flex-1 min-w-0">
              <h3 className={`text-sm font-display font-bold truncate ${isBoss ? 'text-rose-200 drop-shadow-[0_0_10px_rgba(244,63,94,0.4)]' : 'text-gray-100'}`}>
                {monster.name}
              </h3>
              <div className="text-[10px] text-red-400/80 font-mono mt-0.5">Lv.{monster.level}</div>
              {isBoss && (
                <div className="flex items-center gap-1 mt-0.5">
                    <Crown size={10} className="text-yellow-400" />
                    <span className="text-[9px] text-yellow-400/70">{t('codex.bossLevelLabel')}</span>
                  </div>
              )}
            </div>
          </div>

          <div className="grid grid-cols-3 gap-2 mb-3">
            <motion.div
              whileHover={{ scale: 1.03 }}
              className="bg-black/25 rounded-lg p-2 border border-white/5"
            >
              <div className="flex items-center gap-1 mb-1">
                <Heart size={10} className="text-red-400" />
                <span className="text-[8px] text-gray-400 uppercase">{t('codex.stat.hp')}</span>
              </div>
              <div className="text-lg font-bold text-red-300">{monster.maxHp}</div>
              <div className="w-full h-1 bg-red-500/20 rounded-full mt-1 overflow-hidden">
                <div className="h-full bg-gradient-to-r from-red-500 to-red-400 rounded-full" style={{ width: `${Math.min(100, (monster.maxHp / 500) * 100)}%` }} />
              </div>
            </motion.div>
            <motion.div
              whileHover={{ scale: 1.03 }}
              className="bg-black/25 rounded-lg p-2 border border-white/5"
            >
                <div className="flex items-center gap-1 mb-1">
                <Swords size={10} className="text-orange-400" />
                <span className="text-[8px] text-gray-400 uppercase">{t('codex.stat.attack')}</span>
              </div>
              <div className="text-lg font-bold text-orange-300">{monster.attack}</div>
              <div className="w-full h-1 bg-orange-500/20 rounded-full mt-1 overflow-hidden">
                <div className="h-full bg-gradient-to-r from-orange-500 to-orange-400 rounded-full" style={{ width: `${Math.min(100, (monster.attack / 50) * 100)}%` }} />
              </div>
            </motion.div>
            <motion.div
              whileHover={{ scale: 1.03 }}
              className="bg-black/25 rounded-lg p-2 border border-white/5"
            >
                <div className="flex items-center gap-1 mb-1">
                <Shield size={10} className="text-blue-400" />
                <span className="text-[8px] text-gray-400 uppercase">{t('codex.stat.defense')}</span>
              </div>
              <div className="text-lg font-bold text-blue-300">{monster.defense}</div>
                <div className="w-full h-1 bg-blue-500/20 rounded-full mt-1 overflow-hidden">
                <div className="h-full bg-gradient-to-r from-blue-500 to-blue-400 rounded-full" style={{ width: `${Math.min(100, (monster.defense / 30) * 100)}%` }} />
              </div>
            </motion.div>
          </div>

          <div className="mb-2">
            <div className="flex items-center gap-1 mb-1.5">
              <Zap size={10} className="text-red-400" />
              <span className="text-[9px] text-gray-400 uppercase">{t('codex.traits')}</span>
            </div>
            <TraitTags traits={monster.traits} t={t} />
          </div>

          <div className="mb-2">
            <div className="flex items-center gap-1 mb-1.5">
              <Info size={10} className="text-fuchsia-300" />
              <span className="text-[9px] text-gray-400 uppercase">{t('codex.threatTypes')}</span>
            </div>
            <div className="flex flex-wrap gap-1.5">
              {threatTypes.map((threat) => (
                <span
                  key={threat}
                  className={`text-[9px] px-1.5 py-0.5 rounded border ${threatStyleMap[threat]}`}
                >
                  {t(`codex.threat.${threat}`)}
                </span>
              ))}
            </div>
          </div>

          <div className="mb-2 rounded-lg border border-indigo-400/20 bg-indigo-500/5 p-2">
            <div className="flex items-center gap-1 mb-1">
              <BookOpen size={10} className="text-indigo-300" />
              <span className="text-[9px] text-indigo-200 uppercase">{t('codex.background')}</span>
            </div>
            <p className="text-[9px] text-indigo-100/80 leading-relaxed">
              {monster.background ?? t('codex.backgroundFallback')}
            </p>
          </div>

          {isBoss && monster.counterGoal && (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              className="mt-auto rounded-lg border border-amber-400/25 bg-amber-500/8 p-2"
            >
              <div className="flex items-center gap-1.5 mb-1">
                <Flame size={11} className="text-amber-400" />
                <span className="text-[10px] font-medium text-amber-200">{t('codex.counterGoal')}</span>
              </div>
              <div className="text-[9px] text-amber-100/70">
                {monster.counterGoal.title}
              </div>
              <div className="text-[8px] text-amber-400/50 mt-0.5">
                {t(`stat.${monster.counterGoal.stat}`, { defaultValue: monster.counterGoal.stat })} 鈮?{monster.counterGoal.threshold}
              </div>
            </motion.div>
          )}

          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            className="mt-2 rounded-lg border border-cyan-400/20 bg-cyan-500/5 p-2"
          >
            <div className="flex items-center gap-1.5 mb-1">
              <Info size={11} className="text-cyan-300" />
              <span className="text-[10px] font-medium text-cyan-200">{t('codex.tacticsTitle')}</span>
            </div>
            <div className="flex flex-wrap gap-1 mb-1.5">
                {strategyTags.map((tag) => (
                <span
                  key={tag}
                  className={`text-[9px] px-1.5 py-0.5 rounded border ${strategyTagStyleMap[tag]}`}
                >
                  {t(`codex.strategy.${tag}`, { defaultValue: tag })}
                </span>
              ))}
            </div>
            <ul className="space-y-1">
              {strategyHints.map((hint) => (
                <li key={hint} className="text-[9px] text-cyan-100/80 leading-relaxed">
                  路 {hint}
                </li>
              ))}
            </ul>
          </motion.div>
        </div>
      </div>
    </motion.div>
  );
}

export function MonsterCodexTab() {
  const { t } = useTranslation();
  const [selectedMonsterId, setSelectedMonsterId] = useState<string | null>(NORMAL_MONSTERS[0]?.id || null);
  const [activeTab, setActiveTab] = useState<'normal' | 'boss'>('normal');

  const allMonsters = [...NORMAL_MONSTERS, ...BOSS_MONSTERS];
  const selectedMonster = allMonsters.find(m => m.id === selectedMonsterId);

  const currentList = activeTab === 'normal' ? NORMAL_MONSTERS : BOSS_MONSTERS;

  return (
    <motion.div
      key="codex"
      initial={{ opacity: 0, y: 10, scale: 0.98 }}
      animate={{ opacity: 1, y: 0, scale: 1 }}
      exit={{ opacity: 0, y: -10, scale: 0.98 }}
      transition={{ duration: 0.3 }}
      className="h-full max-h-full flex flex-col gap-3 overflow-hidden"
    >
      <motion.section
        initial={{ opacity: 0, x: -20 }}
        animate={{ opacity: 1, x: 0 }}
        className="border border-game-border/50 rounded-xl bg-gradient-to-br from-game-card/80 to-game-card/40 p-3 relative overflow-hidden flex-shrink-0"
      >
        <div className="absolute inset-0 bg-gradient-to-r from-cyan-500/5 to-red-900/10" />
        <div className="absolute -top-10 -right-10 w-32 h-32 bg-cyan-500/10 rounded-full blur-3xl" />
        
        <div className="relative z-10">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <motion.div 
                whileHover={{ rotate: 15, scale: 1.1 }}
                className="p-1.5 rounded-lg bg-cyan-500/20"
              >
                <BookOpen size={14} className="text-cyan-300" />
              </motion.div>
              <span className="font-display text-sm text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-red-500">{t('codex.title')}</span>
            </div>
            
            <div className="flex gap-1 bg-game-bg/50 p-0.5 rounded-lg border border-game-border/30">
              <motion.button
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
                onClick={() => {
                  setActiveTab('normal');
                  const first = NORMAL_MONSTERS[0];
                  if (first) setSelectedMonsterId(first.id);
                }}
                className={`px-2.5 py-1 rounded-md text-[10px] font-medium transition-all ${activeTab === 'normal' ? 'bg-red-900/30 text-red-300 border border-red-700/30' : 'text-gray-400 hover:text-gray-200'}`}
              >
                <Skull size={10} className="inline mr-1" />
                {t('codex.tab.normal')} ({NORMAL_MONSTERS.length})
              </motion.button>
              <motion.button
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
                onClick={() => {
                  setActiveTab('boss');
                  const first = BOSS_MONSTERS[0];
                  if (first) setSelectedMonsterId(first.id);
                }}
                className={`px-2.5 py-1 rounded-md text-[10px] font-medium transition-all ${activeTab === 'boss' ? 'bg-rose-500/30 text-rose-300 border border-rose-500/30' : 'text-gray-400 hover:text-gray-200'}`}
              >
                <Crown size={10} className="inline mr-1" />
                {t('codex.tab.boss')} ({BOSS_MONSTERS.length})
              </motion.button>
            </div>
          </div>
        </div>
      </motion.section>

      <div className="flex-1 grid grid-cols-1 lg:grid-cols-2 gap-2 min-h-0 overflow-hidden items-stretch">
        <motion.section
          initial={{ opacity: 0, x: -20 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ delay: 0.1 }}
          className="border border-game-border/50 rounded-xl bg-game-bg/40 p-2 overflow-hidden flex flex-col h-full min-h-0"
        >
          <div className="flex items-center gap-2 mb-2 text-[10px] text-gray-400 uppercase tracking-wider flex-shrink-0">
            <Info size={12} />
            <span>{t('codex.listTitle')}</span>
          </div>
          
          <div className="flex-1 overflow-y-auto pr-1 space-y-1.5 scrollbar-thin min-h-0">
            {currentList.map((monster, index) => (
              <motion.div
                key={monster.id}
                initial={{ opacity: 0, x: -20 }}
                animate={{ opacity: 1, x: 0 }}
                transition={{ delay: index * 0.02 }}
              >
                <MonsterListItem
                  monster={monster}
                  isSelected={selectedMonsterId === monster.id}
                  isBoss={activeTab === 'boss'}
                  onClick={() => setSelectedMonsterId(monster.id)}
                />
              </motion.div>
            ))}
          </div>
        </motion.section>

        <motion.section
          initial={{ opacity: 0, x: 20 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ delay: 0.15 }}
          className="border border-game-border/50 rounded-xl bg-game-bg/30 p-2 overflow-hidden flex flex-col h-full min-h-0"
        >
          <div className="flex items-center gap-2 mb-2 text-[10px] text-gray-400 uppercase tracking-wider flex-shrink-0">
            <Heart size={12} className="text-red-400" />
            <span>{t('codex.detailTitle')}</span>
          </div>
          
          <div className="flex-1 overflow-y-auto overflow-x-hidden scrollbar-thin min-h-0">
            <AnimatePresence mode="wait">
              {selectedMonster ? (
                <MonsterDetailPanel monster={selectedMonster} t={t} />
              ) : (
                <div className="h-full flex items-center justify-center text-gray-500">
                  <div className="text-center">
                      <Info size={24} className="mx-auto mb-1 opacity-30" />
                      <p className="text-[10px]">{t('codex.selectMonster')}</p>
                    </div>
                </div>
              )}
            </AnimatePresence>
          </div>
        </motion.section>
      </div>
    </motion.div>
  );
}


===================== [D:\download\LootingRPG\src\components\game\AppHeader.tsx] =====================
import { Coins, Download, LogOut, RefreshCw, Sword, Upload, Settings2, ChevronDown, Palette } from 'lucide-react';
import { motion, AnimatePresence } from 'motion/react';
import { useState, useEffect } from 'react';
import { createPortal } from 'react-dom';
import type { PlayerStats } from '../../types/game';
import { useTheme } from '../../config/themes/ThemeContext';

interface AppHeaderProps {
  gold: number;
  playerName: string;
  playerStats: PlayerStats;
  onReset: () => void;
  onLogout: () => void;
  onExportSave: () => void;
  onImportSave: () => void;
}

export function AppHeader({
  gold,
  playerName,
  playerStats,
  onReset,
  onLogout,
  onExportSave,
  onImportSave,
}: AppHeaderProps) {
  const { theme, themes, setTheme } = useTheme();
  const [showMenu, setShowMenu] = useState(false);
  const expNeeded = playerStats.level * 100;
  const expPercent = Math.min(100, (playerStats.xp / expNeeded) * 100);

  return (
    <header className="flex items-center justify-between gap-4 h-16 px-5 border-b border-white/5 bg-gradient-to-b from-stone-900 via-stone-900/95 to-stone-950 backdrop-blur-md shadow-lg shadow-black/20">
      <div className="flex items-center gap-5">
        <div className="flex items-center gap-3">
          <div className="relative">
            <div className="w-10 h-10 bg-gradient-to-br from-amber-600 via-amber-700 to-amber-900 rounded-xl flex items-center justify-center shadow-lg shadow-amber-900/40 border border-amber-500/30">
              <Sword className="text-amber-100" size={22} strokeWidth={2.5} />
            </div>
            <div className="absolute -bottom-0.5 -right-0.5 w-3 h-3 bg-gradient-to-r from-emerald-400 to-emerald-600 rounded-full border-2 border-stone-900" />
          </div>
          <div className="flex flex-col">
            <span className="text-lg font-display font-bold tracking-wider text-transparent bg-clip-text bg-gradient-to-r from-amber-300 via-yellow-200 to-amber-400 drop-shadow-sm">
              LOOT GRINDER
            </span>
            <span className="text-[9px] font-medium tracking-[0.2em] text-stone-500 uppercase">Rare Earth Explorer</span>
          </div>
        </div>

        <div className="w-px h-8 bg-gradient-to-b from-transparent via-stone-700/50 to-transparent" />

        <div className="flex items-center gap-4">
          <div className="flex items-center gap-2.5 px-3.5 py-2 bg-stone-800/40 rounded-xl border border-white/5">
            <div className="w-7 h-7 rounded-lg bg-gradient-to-br from-red-800/30 to-red-900/30 flex items-center justify-center border border-red-700/20">
              <span className="text-xs font-bold text-indigo-300">{playerName.charAt(0).toUpperCase()}</span>
            </div>
            <span className="text-sm font-medium text-stone-200">{playerName}</span>
            <span className="px-1.5 py-0.5 text-xs font-bold bg-gradient-to-r from-amber-600 to-amber-700 text-amber-100 rounded-md shadow-inner">Lv.{playerStats.level}</span>
          </div>

          <div className="flex items-center gap-2 w-28">
            <div className="flex-1 h-2 rounded-full bg-stone-800 border border-stone-700/50 overflow-hidden">
              <motion.div
                className="h-full bg-gradient-to-r from-amber-700 via-amber-600 to-amber-500 relative"
                initial={{ width: 0 }}
                animate={{ width: `${expPercent}%` }}
                transition={{ duration: 0.5, ease: 'easeOut' }}
              >
                <div className="absolute inset-0 bg-gradient-to-b from-white/20 to-transparent rounded-full" />
              </motion.div>
            </div>
            <span className="text-[10px] text-stone-500 font-mono w-12 text-right">{playerStats.xp}/{expNeeded}</span>
          </div>

          <div className="flex items-center gap-3 text-xs">
            <div className="flex items-center gap-1.5 px-2 py-1 bg-rose-500/10 rounded-md border border-rose-500/20">
              <Sword size={12} className="text-rose-400" />
              <span className="text-rose-300 font-semibold">{playerStats.attack}</span>
              <span className="text-stone-600 font-normal">ATK</span>
            </div>
            <div className="flex items-center gap-1.5 px-2 py-1 bg-emerald-500/10 rounded-md border border-emerald-500/20">
              <div className="w-3 h-3 rounded-full bg-emerald-500/30 border border-emerald-400/50" />
              <span className="text-emerald-300 font-semibold">{playerStats.hp}</span>
              <span className="text-stone-600 font-normal">HP</span>
            </div>
            <div className="flex items-center gap-1.5 px-2 py-1 bg-sky-500/10 rounded-md border border-sky-500/20">
              <div className="w-3 h-1.5 rounded-sm bg-sky-400/50" />
              <span className="text-sky-300 font-semibold">{playerStats.defense}</span>
              <span className="text-stone-600 font-normal">DEF</span>
            </div>
          </div>
        </div>
      </div>

      <div className="flex items-center gap-3">
        <div className="flex items-center gap-2 px-4 py-2 bg-gradient-to-r from-amber-900/30 to-amber-800/20 rounded-xl border border-amber-700/30 shadow-lg shadow-amber-900/10">
          <Coins className="text-amber-400" size={16} strokeWidth={2} />
          <span className="font-mono font-bold text-amber-400 text-sm tracking-wide">{gold.toLocaleString()}</span>
        </div>

        <div className="relative">
          <motion.button
            whileHover={{ scale: 1.05, backgroundColor: 'rgba(51, 65, 85, 0.5)' }}
            whileTap={{ scale: 0.95 }}
            onClick={() => setShowMenu(!showMenu)}
            className="flex items-center gap-1 p-2.5 text-stone-400 hover:text-stone-200 rounded-lg transition-all cursor-pointer app-header-settings-anchor"
          >
            <Settings2 size={18} strokeWidth={2} />
            <ChevronDown size={12} className={`transition-transform ${showMenu ? 'rotate-180' : ''}`} />
          </motion.button>
          <MenuPortal
            show={showMenu}
            onClose={() => setShowMenu(false)}
            onExportSave={() => { onExportSave(); setShowMenu(false); }}
            onImportSave={() => { onImportSave(); setShowMenu(false); }}
            onLogout={() => { onLogout(); setShowMenu(false); }}
            onReset={() => { onReset(); setShowMenu(false); }}
            theme={theme}
            themes={themes}
            onThemeChange={(id) => { setTheme(id); setShowMenu(false); }}
          />
        </div>
      </div>
    </header>
  );
}

import type { Theme } from '../../config/themes/types';

interface MenuPortalProps {
  show: boolean;
  onClose: () => void;
  onExportSave: () => void;
  onImportSave: () => void;
  onLogout: () => void;
  onReset: () => void;
  theme: Theme;
  themes: Theme[];
  onThemeChange: (id: string) => void;
}

function MenuPortal({
  show,
  onClose,
  onExportSave,
  onImportSave,
  onLogout,
  onReset,
  theme,
  themes,
  onThemeChange,
}: MenuPortalProps) {
  const [pos, setPos] = useState<{ top: number; right: number } | null>(null);

  useEffect(() => {
    if (!show) return;
    const update = () => {
      try {
        const anchor = document.querySelector('.app-header-settings-anchor') as HTMLElement | null;
        if (!anchor) return;
        const r = anchor.getBoundingClientRect();
        setPos({ top: r.bottom, right: window.innerWidth - r.right });
      } catch (e) {
        setPos({ top: 56, right: 16 });
      }
    };
    update();
    window.addEventListener('resize', update);
    window.addEventListener('scroll', update, true);
    return () => {
      window.removeEventListener('resize', update);
      window.removeEventListener('scroll', update, true);
    };
  }, [show]);

  if (!show) return null;

  return createPortal(
    <AnimatePresence>
      <>
        <div className="fixed inset-0 z-40" onClick={onClose} />
        <motion.div
          initial={{ opacity: 0, y: 8, scale: 0.96 }}
          animate={{ opacity: 1, y: 0, scale: 1 }}
          exit={{ opacity: 0, y: 8, scale: 0.96 }}
          transition={{ duration: 0.15 }}
          style={pos ? { position: 'fixed', top: pos.top, right: pos.right } : { position: 'fixed', top: 64, right: 20 }}
          className="z-[9999] bg-stone-900/95 backdrop-blur-xl rounded-xl border border-white/10 shadow-2xl shadow-black/40 py-1.5 min-w-[160px]"
        >
          <button
            onClick={onExportSave}
            className="w-full flex items-center gap-3 px-4 py-2.5 text-sm text-stone-300 hover:text-emerald-400 hover:bg-emerald-500/10 transition-all cursor-pointer"
          >
            <Download size={15} />
            瀵煎嚭瀛樻。
          </button>
          <button
            onClick={onImportSave}
            className="w-full flex items-center gap-3 px-4 py-2.5 text-sm text-stone-300 hover:text-emerald-400 hover:bg-emerald-500/10 transition-all cursor-pointer"
          >
            <Upload size={15} />
            瀵煎叆瀛樻。
          </button>
          <div className="my-1.5 border-t border-white/5" />
          <div className="px-4 py-2">
            <div className="flex items-center gap-2 text-xs text-stone-500 mb-2">
              <Palette size={12} />
              <span>涓婚</span>
            </div>
            <div className="flex gap-1.5">
              {themes.map((t) => (
                <button
                  key={t.id}
                  onClick={() => onThemeChange(t.id)}
                  className={`flex-1 px-2 py-1.5 text-xs rounded-md border transition-all cursor-pointer ${
                    theme.id === t.id
                      ? 'bg-stone-700/80 border-stone-500 text-stone-100'
                      : 'bg-stone-800/50 border-stone-700/50 text-stone-400 hover:border-stone-600 hover:text-stone-300'
                  }`}
                  style={{
                    borderColor: theme.id === t.id ? t.colors.gameAccent : undefined,
                  }}
                >
                  {t.name}
                </button>
              ))}
            </div>
          </div>
          <div className="my-1.5 border-t border-white/5" />
          <button
            onClick={onLogout}
            className="w-full flex items-center gap-3 px-4 py-2.5 text-sm text-stone-300 hover:text-blue-400 hover:bg-blue-500/10 transition-all cursor-pointer"
          >
            <LogOut size={15} />
            鍒囨崲鐜╁
          </button>
          <button
            onClick={onReset}
            className="w-full flex items-center gap-3 px-4 py-2.5 text-sm text-stone-300 hover:text-rose-400 hover:bg-rose-500/10 transition-all cursor-pointer"
          >
            <RefreshCw size={15} />
            閲嶇疆瀛樻。
          </button>
        </motion.div>
      </>
    </AnimatePresence>,
    document.body,
  );
}


===================== [D:\download\LootingRPG\src\components\game\BattleUnitCardBase.tsx] =====================
import type { ReactNode } from 'react';

interface BattleUnitCardBaseProps {
  subtitle?: ReactNode;
  className?: string;
  children?: ReactNode;
}

export function BattleUnitCardBase({subtitle, className = '', children }: BattleUnitCardBaseProps) {
  return (
    <div className={`aspect-square rounded-2xl border border-game-border/60 bg-black/20 pt-3 px-3 pb-0 flex flex-col ${className}`}>
      <div className="mb-2 min-h-[36px]">
        {subtitle ? <div className="text-xs text-gray-400 mt-1">{subtitle}</div> : null}
      </div>
      <div className="flex-1">{children}</div>
    </div>
  );
}

export default BattleUnitCardBase;


===================== [D:\download\LootingRPG\src\components\game\BattleView.tsx] =====================
import { useTranslation } from 'react-i18next';
import type { BattleSession } from '../../shared/types/game';
import PlayerCard from './PlayerCard';
import EnemyCard from './EnemyCard';
import BattleUnitCardBase from './BattleUnitCardBase';

interface BattleViewProps {
  session: BattleSession;
  onAttack: () => void;
  onRetreat: () => void;
}


export function BattleView({ session, onAttack, onRetreat }: BattleViewProps) {
  const { t } = useTranslation();
  const fallbackWaveOrder = Array.from(new Set((session.enemies ?? []).map((enemy) => {
    const waveId = enemy.meta?.waveId;
    return typeof waveId === 'string' ? waveId : 'wave-1';
  })));
  const waveOrder = Array.isArray(session.waveOrder) && session.waveOrder.length > 0
    ? session.waveOrder
    : fallbackWaveOrder;
  const safeWaveIndex = Number.isFinite(session.currentWaveIndex)
    ? Math.max(0, Math.min(Math.max(0, waveOrder.length - 1), session.currentWaveIndex))
    : 0;
  const currentWaveId = waveOrder[safeWaveIndex];
  const currentWaveEnemies = (session.enemies ?? []).filter((enemy) => {
    if (!currentWaveId) return true;
    const waveId = enemy.meta?.waveId;
    return (typeof waveId === 'string' ? waveId : 'wave-1') === currentWaveId;
  });


  const leftSlotCount = 6;
  const rightEnemies = currentWaveEnemies.slice(0, 9);

  return (
    <div className="bg-gradient-to-br from-game-card/90 to-game-card/70 border border-game-border/40 rounded-2xl p-5 flex flex-col h-[68vh] max-h-[820px] min-h-[420px] gap-4">
      <div className="flex items-center justify-between border-b border-game-border/30 pb-3">
        <div>
          <div className="text-[11px] uppercase text-gray-400 tracking-[0.5em] flex items-center gap-2">
            <span>馃搷</span>
            <span>{session.chapterName}</span>
          </div>
          <div className="text-xl font-semibold text-white">{t('battle.title')}</div>
          <div className="text-[11px] uppercase text-gray-400 tracking-[0.5em]">{session.nodeName}</div>
        </div>
        <div className="text-right text-xs text-gray-400">
          <div>{t('battle.turn')}: {session.turn}</div>
          <div>{t('battle.enemyProgress')}: {Math.min(safeWaveIndex + 1, waveOrder.length)} / {waveOrder.length}</div>
          <div className="text-[11px] uppercase tracking-[0.4em] mt-1">Rewards</div>
          <div className="text-sm text-white">鈥?/div>
        </div>
      </div>

      {/* battlefield section with square grid background */}
      <div className="rounded-2xl border border-game-border/60 bg-black/20">
        <div className="relative overflow-auto" style={{ width:'768px', height:'288px' }}>
          {/* grid lines overlay covering grid area */}
          <div
            className="absolute inset-0 pointer-events-none"
            style={{
              backgroundSize: '96px 96px',
              backgroundImage:
                'linear-gradient(to right, rgba(255,255,255,0.12) 1px, transparent 1px),\
                 linear-gradient(to bottom, rgba(255,255,255,0.12) 1px, transparent 1px)',
            }}
          />

          {/* fixed 3脳8 battlefield grid with constant cell size */}
          <div
            className="grid"
            style={{
              width: `${96 * 8}px`,
              height: `${96 * 3}px`,
              gridTemplateRows: `repeat(3, ${96}px)`,
              gridTemplateColumns: `repeat(8, ${96}px)`,
              gap: '0px',
            }}
          >
          {(() => {
            const rows = 3;
            const cols = 8;
            const total = rows * cols;
            const leftIdx = [0,1,8,9,16,17];
            const rightIdx = [5,6,7,13,14,15,21,22,23];
            const cells: React.ReactNode[] = Array(total).fill(null);

            // fill left slots (placeholders with player in fourth position)
            const leftSlots: React.ReactNode[] = [];
            for (let i = 0; i < leftSlotCount; i++) {
              if (i === 3) {
                leftSlots.push(<PlayerCard key="player" session={session} />);
              } else {
                leftSlots.push(
                  <BattleUnitCardBase
                    key={`ally-slot-${i}`}
                    subtitle="棰勭暀"
                    className="w-full"
                  >
                    <div className="h-full flex items-center justify-center text-xs text-gray-500">
                      Empty
                    </div>
                  </BattleUnitCardBase>
                );
              }
            }
            leftIdx.forEach((idx, i) => {
              cells[idx] = leftSlots[i] || null;
            });

            // fill right slots (enemies + placeholders)
            rightIdx.forEach((idx, i) => {
              const enemy = rightEnemies[i];
              if (enemy) {
                cells[idx] = <EnemyCard key={enemy.id} enemy={enemy} />;
              } else {
                cells[idx] = (
                  <BattleUnitCardBase
                    key={`enemy-slot-${i}`}
                    subtitle="绌?
                    className="w-full"
                  >
                    <div className="h-full flex items-center justify-center text-xs text-gray-500">
                      Empty
                    </div>
                  </BattleUnitCardBase>
                );
              }
            });

            return cells.map((cell, idx) => (
              <div key={idx} className="w-full h-full">
                {cell}
              </div>
            ));
          })()}
        </div>
      </div>

      <div className="flex gap-4 flex-1 min-h-[230px]">
        <div className="w-[260px] rounded-2xl border border-game-border/60 bg-black/20 p-4 flex flex-col gap-3">
          <div className="text-[10px] uppercase text-gray-400 tracking-[0.4em]">Actions</div>
          <button
            type="button"
            onClick={onAttack}
            disabled={session.status !== 'fighting'}
            className="w-full px-3 py-2 rounded-lg bg-amber-600 hover:bg-amber-500 text-white text-sm disabled:opacity-50"
          >
            {t('battle.attack')}
          </button>
          <button
            type="button"
            onClick={onRetreat}
            disabled={session.status !== 'fighting'}
            className="w-full px-3 py-2 rounded-lg bg-gray-700 hover:bg-gray-600 text-white text-sm disabled:opacity-50"
          >
            {t('battle.retreat')}
          </button>
          <div className="text-[11px] text-gray-500">
            {Math.min(safeWaveIndex + 1, waveOrder.length)} / {waveOrder.length}
          </div>
        </div>
        <div className="flex-1 rounded-2xl border border-game-border/60 bg-black/20 p-4 flex flex-col">
          <div className="flex items-center justify-between text-[10px] uppercase text-gray-400 tracking-[0.4em]">
            <span>battle log</span>
            <span>{t('battle.turn')}: {session.turn}</span>
          </div>
          <div className="mt-3 flex-1 overflow-auto space-y-1 text-xs text-gray-200">
            {session.logs.slice(-30).map((line, index) => (
              <div key={`${line}-${index}`} className="border-b border-game-border/10 pb-1">
                {line}
              </div>
            ))}
          </div>
        </div>
      </div>
    </div>
    </div>
  );
}


===================== [D:\download\LootingRPG\src\components\game\DebugPanel.tsx] =====================
import React, { useEffect, useState } from 'react';
import { QUALITIES, SLOTS } from '../../config/game/equipment';
import type { Equipment } from '../../types/game';
import { createCustomEquipment } from '../../domains/inventory/services/equipment';
interface DebugPanelProps { onAddItems: (items: Equipment[]) => void;}
export function DebugPanel({ onAddItems }: DebugPanelProps) {
  const [open, setOpen] = useState(false);
  const [quality, setQuality] = useState(QUALITIES[0] || 'common');
  const [slot, setSlot] = useState(SLOTS[0] || 'weapon');
  const [count, setCount] = useState(1);
  const [level, setLevel] = useState(1);

  useEffect(() => {
    const handler = (e: KeyboardEvent) => {
      if (e.ctrlKey && e.key.toLowerCase() === 'd') {
        e.preventDefault();
        setOpen((v) => !v);
      }
    };
    window.addEventListener('keydown', handler);
    return () => window.removeEventListener('keydown', handler);
  }, []);
  const handleAdd = () => {
    const n = Math.floor(count);
    const items: Equipment[] = [];
    for (let i = 0; i < n; i++) {
      items.push(createCustomEquipment(quality, slot, Math.floor(level)));
    }
    onAddItems(items);
    setOpen(false);
  };

  return (
    <div className="fixed bottom-6 right-6 z-50">
      <button
        className="px-3 py-2 bg-red-800 text-white rounded-lg shadow-md"
        onClick={() => setOpen((v) => !v)}
      >
        Debug
      </button>

      {open && (
        <div className="mt-2 w-64 p-3 bg-game-bg border border-game-border rounded-lg shadow-xl">
          <div className="mb-2 text-sm font-bold">Debug - 娣诲姞瑁呭 (Ctrl+D)</div>

          <label className="block text-xs text-gray-400">鍝佽川</label>
          <select className="w-full mb-2 p-1 bg-transparent border rounded" value={quality} onChange={(e) => setQuality(e.target.value)}>
            {QUALITIES.map((q) => (
              <option key={q} value={q}>{q}</option>
            ))}
          </select>

          <label className="block text-xs text-gray-400">閮ㄤ綅</label>
          <select className="w-full mb-2 p-1 bg-transparent border rounded" value={slot} onChange={(e) => setSlot(e.target.value)}>
            {SLOTS.map((s) => (
              <option key={s} value={s}>{s}</option>
            ))}
          </select>

          <label className="block text-xs text-gray-400">鏁伴噺</label>
          <input className="w-full mb-2 p-1 bg-transparent border rounded" type="number" min={1} max={100} value={count} onChange={(e) => setCount(Number(e.target.value))} />

          <label className="block text-xs text-gray-400">绛夌骇</label>
          <input className="w-full mb-3 p-1 bg-transparent border rounded" type="number" min={1} max={999} value={level} onChange={(e) => setLevel(Number(e.target.value))} />

          <div className="flex gap-2">
            <button className="flex-1 py-1 bg-green-600 text-white rounded" onClick={handleAdd}>娣诲姞</button>
            <button className="flex-1 py-1 bg-gray-600 text-white rounded" onClick={() => setOpen(false)}>鍙栨秷</button>
          </div>
        </div>
      )}
    </div>
  );
}

export default DebugPanel;


===================== [D:\download\LootingRPG\src\components\game\EnemyCard.tsx] =====================
import BattleUnitCardBase from './BattleUnitCardBase';
import type { BattleUnitInstance } from '../../types/battle/BattleUnit';

const percent = (value: number, max: number) => {
  if (max <= 0) return 0;
  return Math.max(0, Math.min(100, (value / max) * 100));
};

interface EnemyCardProps {
  enemy: BattleUnitInstance;
}
export function EnemyCard({ enemy }: EnemyCardProps) {
  const icon = typeof enemy.meta?.icon === 'string' ? enemy.meta.icon : '馃懢';

  return (
    <BattleUnitCardBase className="w-full p-0">
      <div className="relative w-full h-full">
        <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-3xl">
          {icon}
        </div>
        <div className="absolute bottom-0 left-0 right-0 h-2 rounded bg-gray-800 overflow-hidden">
          <div
            className="h-full bg-rose-500"
            style={{ width: `${percent(enemy.currentHp, enemy.baseStats.hp)}%` }}
          />
        </div>
      </div>
    </BattleUnitCardBase>
  );
}

export default EnemyCard;


===================== [D:\download\LootingRPG\src\components\game\GamePanel.tsx] =====================
import { AnimatePresence, motion } from 'motion/react';
import { useTranslation } from 'react-i18next';
import { lazy, Suspense } from 'react';
import { Trophy } from 'lucide-react';
import type { ActiveTab, GameState, MapProgressState } from '../../types/game';
import { TabButton } from '../ui/TabButton';
import type { MapChapterDef, MapNodeDef } from '../../config/map/ChapterData';

const InventoryTab = lazy(() => import('./tabs/InventoryTab').then(m => ({ default: m.InventoryTab })));
const ForgeTab = lazy(() => import('./tabs/ForgeTab').then(m => ({ default: m.ForgeTab })));
const MonsterCodexTab = lazy(() => import('./tabs/MonsterCodexTab').then(m => ({ default: m.MonsterCodexTab })));
const MapTab = lazy(() => import('./tabs/MapTab').then(m => ({ default: m.MapTab })));

interface GamePanelProps {
  gameState: GameState;
  activeTab: ActiveTab;
  loading: boolean;
  focusMapNode: string | null;
  onClearFocusMapNode: () => void;
  onSetTab: (tab: ActiveTab) => void;
  onEnterMapNode: (node: MapNodeDef, chapter: MapChapterDef) => void;
  mapProgress: MapProgressState;
  onSelectMapChapter: (chapterId: string) => void;
  onEquip: (id: string) => void;
  onSell: (id: string) => void;
  onForge: (id: string) => void;
  onQuickSellByQualityRange: (minQuality: string, maxQuality: string) => void;
  autoSellQualities: Record<string, boolean>;
  onToggleAutoSellQuality: (quality: string) => void;
  onReroll: (id: string, lockTypes?: string[]) => void;
  forgeSelectedId: string | null;
  onSelectForgeItem: (id: string) => void;
}

export function GamePanel({
  gameState,
  activeTab,
  loading,
  focusMapNode,
  onClearFocusMapNode,
  onSetTab,
  onEnterMapNode,
  mapProgress,
  onSelectMapChapter,
  onEquip,
  onSell,
  onForge,
  onQuickSellByQualityRange,
  autoSellQualities,
  onToggleAutoSellQuality,
  onReroll,
  forgeSelectedId,
  onSelectForgeItem,
}: GamePanelProps) {
  const { t } = useTranslation();
  const inventoryItems = gameState.backpack
    .filter((item) => !item.equipped)
    .map((item) => ({ ...item, equipped: false }));
  return (
    <div className="lg:col-span-8 flex flex-col gap-6 h-full">
      <div className="bg-gradient-to-br from-game-card/90 to-game-card/70 border border-game-border/50 rounded-2xl flex flex-col overflow-hidden shadow-2xl shadow-red-900/10 h-[68vh] max-h-[820px] min-h-[420px] relative">
        <div className="absolute inset-0 bg-gradient-to-br from-red-900/10 via-transparent to-rose-500/3 pointer-events-none" />
        
        <div className="flex border-b border-game-border relative z-10">
          <TabButton active={activeTab === 'map'} onClick={() => onSetTab('map')} label={t('map.explore')} />
          <TabButton active={activeTab === 'inventory'} onClick={() => onSetTab('inventory')} label={t('tabs.inventory')} />
          <TabButton active={activeTab === 'forge'} onClick={() => onSetTab('forge')} label={t('tabs.forge')} />
          <TabButton active={activeTab === 'codex'} onClick={() => onSetTab('codex')} label={t('tabs.codex')} />
        </div>

        <div className="p-4 overflow-hidden relative z-10 h-full">
          <AnimatePresence mode="wait">
            {activeTab === 'inventory' && (
              <motion.div 
                key="inventory"
                initial={{ opacity: 0, y: 10, scale: 0.98 }}
                animate={{ opacity: 1, y: 0, scale: 1 }}
                exit={{ opacity: 0, y: -10, scale: 0.98 }}
                transition={{ duration: 0.3 }}
                className="h-full"
              >
                <Suspense fallback={<div className="h-full flex items-center justify-center text-gray-500">Loading...</div>}>
                  <InventoryTab
                    items={inventoryItems}
                    loading={loading}
                    onEquip={onEquip}
                    onSell={onSell}
                  onForge={onForge}
                  onQuickSellByQualityRange={onQuickSellByQualityRange}
                  autoSellQualities={autoSellQualities}
                  onToggleAutoSellQuality={onToggleAutoSellQuality}
                />
                </Suspense>
              </motion.div>
            )}

            {activeTab === 'map' && (
              <Suspense fallback={<div className="h-full flex items-center justify-center text-gray-500">Loading...</div>}>
                <motion.div
                  key="map"
                  initial={{ opacity: 0, y: 10, scale: 0.98 }}
                  animate={{ opacity: 1, y: 0, scale: 1 }}
                  exit={{ opacity: 0, y: -10, scale: 0.98 }}
                  transition={{ duration: 0.3 }}
                  className="h-full"
                >
                  <MapTab
                    playerLevel={gameState.playerStats.level}
                    loading={loading}
                    progress={mapProgress}
                    onSelectChapter={onSelectMapChapter}
                    onEnterNode={onEnterMapNode}
                    focusNodeId={focusMapNode}
                    onClearFocus={onClearFocusMapNode}
                  />
                </motion.div>
              </Suspense>
            )}

            {activeTab === 'forge' && (
              <Suspense fallback={<div className="h-full flex items-center justify-center text-gray-500">Loading...</div>}>
                <motion.div 
                  key="forge"
                  initial={{ opacity: 0, y: 10, scale: 0.98 }}
                  animate={{ opacity: 1, y: 0, scale: 1 }}
                  exit={{ opacity: 0, y: -10, scale: 0.98 }}
                  transition={{ duration: 0.3 }}
                  className="h-full"
                >
                  <ForgeTab
                    gameState={gameState}
                    selectedId={forgeSelectedId}
                    loading={loading}
                    onSelect={onSelectForgeItem}
                    onForge={onForge}
                    onReroll={onReroll}
                  />
                </motion.div>
              </Suspense>
            )}

            {activeTab === 'codex' && (
              <Suspense fallback={<div className="h-full flex items-center justify-center text-gray-500">Loading...</div>}>
                <motion.div 
                  key="codex"
                  initial={{ opacity: 0, y: 10, scale: 0.98 }}
                  animate={{ opacity: 1, y: 0, scale: 1 }}
                  exit={{ opacity: 0, y: -10, scale: 0.98 }}
                  transition={{ duration: 0.3 }}
                  className="h-full"
                >
                  <MonsterCodexTab />
                </motion.div>
              </Suspense>
            )}
          </AnimatePresence>
        </div>

        <div className="bg-game-bg/80 border-t border-game-border/50 h-16 px-3 flex items-center justify-between text-[10px] font-mono text-gray-500 relative z-10 shrink-0">
          <div className="flex gap-4">
            <motion.span 
              whileHover={{ scale: 1.05 }}
              className="flex items-center gap-1 cursor-default"
            >
              <Trophy size={10} className="text-yellow-500" /> 
              <span>{t('label.legendary_pity')}</span> 
              <div className="w-20 h-2 bg-gray-700 rounded overflow-hidden">
                <div
                  className="h-full bg-yellow-500"
                  style={{ width: `${(gameState.pityCounts.legendary / 50) * 100}%` }}
                />
              </div>
            </motion.span>
            <motion.span 
              whileHover={{ scale: 1.05 }}
              className="flex items-center gap-1 cursor-default"
            >
              <Trophy size={10} className="text-red-500" /> 
              <span>{t('label.mythic_pity')}</span> 
              <div className="w-20 h-2 bg-gray-700 rounded overflow-hidden">
                <div
                  className="h-full bg-red-500"
                  style={{ width: `${(gameState.pityCounts.mythic / 200) * 100}%` }}
                />
              </div>
            </motion.span>
          </div>
          <motion.div 
            whileHover={{ scale: 1.05 }}
            className="flex items-center gap-2"
          >
            <motion.div 
              animate={{ opacity: [0.5, 1, 0.5] }}
              transition={{ duration: 2, repeat: Infinity }}
              className="w-2 h-2 rounded-full bg-green-500" 
            />
            <span className="text-green-500/70">READY</span>
          </motion.div>
        </div>
      </div>
    </div>
  );
}


===================== [D:\download\LootingRPG\src\components\game\GameScreen.tsx] =====================
import type { ActiveTab, BattleSession, GameState } from '../../types/game';
import type { MapProgressState } from '../../types/game';
import type { MapChapterDef, MapNodeDef } from '../../config/map/ChapterData';
import { AppHeader } from './AppHeader';
import { GamePanel } from './GamePanel';
import { PlayerPanel } from './PlayerPanel';
import { BattleView } from './BattleView';
import DebugPanel from './DebugPanel';

interface GameScreenProps {
  gameState: GameState;
  activeTab: ActiveTab;
  loading: boolean;
  playerName: string;
  /** current player stats summary used by header */
  playerStats: import('../../types/game').PlayerStats;
  autoSellQualities: Record<string, boolean>;
  forgeSelectedId: string | null;
  battleSession: BattleSession | null;
  mapProgress: MapProgressState;
  onExportSave: () => void;
  onImportSave: () => void;
  onLogout: () => void;
  onReset: () => void;
  onSetTab: (tab: ActiveTab) => void;
  focusMapNode: string | null;
  onClearFocusMapNode: () => void;
  onEnterMapNode: (node: MapNodeDef, chapter: MapChapterDef) => void;
  onSelectMapChapter: (chapterId: string) => void;
  onBattleAttack: () => void;
  onBattleRetreat: () => void;
  onQuickSellByQualityRange: (minQuality: string, maxQuality: string) => void;
  onEquip: (id: string) => void;
  onSell: (id: string) => void;
  onForge: (id: string) => void;
  onToggleAutoSellQuality: (quality: string) => void;
  onReroll: (id: string, lockTypes?: string[]) => void;
  onSelectForgeItem: (id: string) => void;
  onUnequip: (slot: string) => void;
  onDebugAddItems?: (quality: string, slot: string, count: number, level?: number) => void;
}

export function GameScreen({
  gameState,
  activeTab,
  loading,
  playerName,
  autoSellQualities,
  forgeSelectedId,
  battleSession,
  mapProgress,
  onExportSave,
  onImportSave,
  onLogout,
  onReset,
  onSetTab,
  focusMapNode,
  onClearFocusMapNode,
  onEnterMapNode,
  onSelectMapChapter,
  onBattleAttack,
  onBattleRetreat,
  onQuickSellByQualityRange,
  onEquip,
  onSell,
  onForge,
  onToggleAutoSellQuality,
  onReroll,
  onSelectForgeItem,
  onUnequip,
  onDebugAddItems,
}: GameScreenProps) {
  return (
    <div className="min-h-screen relative overflow-hidden">
      <div className="pointer-events-none absolute -top-32 -left-32 w-96 h-96 bg-red-900/30 blur-3xl rounded-full" />
      <div className="pointer-events-none absolute -bottom-32 -right-32 w-96 h-96 bg-rose-500/15 blur-3xl rounded-full" />

      <div className="relative flex flex-col max-w-6xl mx-auto p-4 md:p-6 gap-6">

        <AppHeader
          gold={gameState.playerStats.gold}
          playerName={playerName}
          playerStats={gameState.playerStats}
          onExportSave={onExportSave}
          onImportSave={onImportSave}
          onLogout={onLogout}
          onReset={onReset}
        />

        <main className="grid grid-cols-1 lg:flex gap-6 items-start">
          <div className="lg:flex-none lg:w-[28%] lg:max-w-[380px] lg:min-w-[240px]">
            <PlayerPanel gameState={gameState} onUnequip={onUnequip} />
          </div>

          <div className="flex-1">
            {battleSession ? (
              <BattleView
                session={battleSession}
                onAttack={onBattleAttack}
                onRetreat={onBattleRetreat}
              />
            ) : (
              <GamePanel
                gameState={gameState}
                activeTab={activeTab}
                loading={loading}
                focusMapNode={focusMapNode}
                onClearFocusMapNode={onClearFocusMapNode}
                onSetTab={onSetTab}
                onEnterMapNode={onEnterMapNode}
                mapProgress={mapProgress}
                onSelectMapChapter={onSelectMapChapter}
                onQuickSellByQualityRange={onQuickSellByQualityRange}
                onEquip={onEquip}
                onSell={onSell}
                onForge={onForge}
                autoSellQualities={autoSellQualities}
                onToggleAutoSellQuality={onToggleAutoSellQuality}
                onReroll={onReroll}
                forgeSelectedId={forgeSelectedId}
                onSelectForgeItem={onSelectForgeItem}
              />
            )}
          </div>
        </main>
        <DebugPanel onAddItems={(items) => {
          // forward to parent via optional callback (preserve item level)
          if (onDebugAddItems) {
            items.forEach((it) => onDebugAddItems(it.quality, it.slot, 1, it.level));
          }
        }} />
      </div>
    </div>
  );
}


===================== [D:\download\LootingRPG\src\components\game\ItemCard.tsx] =====================
import { Coins, Trash2, Shield, Zap, Gem, Crown, Star, Hexagon } from 'lucide-react';
import type { ReactNode } from 'react';
import { QUALITY_CONFIG } from '../../config/game/equipment';
import { getQualityLabel, getStatLabel } from '../../infra/i18n/labels';
import type { Equipment } from '../../types/game';
import { useTranslation } from 'react-i18next';

const iconMap: Record<string, ReactNode> = {
  shield: <Shield size={18} className="text-gray-400" />,
  zap: <Zap size={18} className="text-emerald-400" />,
  gem: <Gem size={18} className="text-blue-400" />,
  hexagon: <Hexagon size={18} className="text-red-400" />,
  crown: <Crown size={18} className="text-yellow-400" />,
  star: <Star size={18} className="text-red-400" />,
};

interface ItemCardProps {
  item: Equipment;
  onEquip?: () => void;
  onSell?: () => void;
  onForge?: () => void;
  loading: boolean;
  readonly?: boolean;
  highlighted?: boolean;
  onClick?: () => void;
}

export function ItemCard({ item, onEquip, onSell, onForge, loading, readonly, highlighted, onClick }: ItemCardProps) {
  const qualityColor = QUALITY_CONFIG[item.quality]?.color || 'text-gray-400';
  const qualityIcon = iconMap[QUALITY_CONFIG[item.quality]?.iconName || 'shield'];
  const forgeCost = (item.enhancementLevel + 1) * 500;
  const { t, i18n } = useTranslation();
  const localeName = i18n.language.startsWith('zh') ? (item.localeNames?.zh || item.name) : (item.localeNames?.en || item.name);
  const affixLabelMap: Record<string, string> = {
    crit_chance: t('stat.crit'),
    lifesteal: t('stat.lifesteal'),
    damage_bonus: t('stat.damage'),
    thorns: t('trait.thorns'),
    hp_bonus: t('stat.hp'),
  };

  const borderClass = item.quality === 'mythic' 
    ? 'mythic-border shadow-lg shadow-red-900/30' 
    : item.quality === 'legendary' 
      ? 'legendary-border shadow-lg shadow-amber-900/20' 
      : highlighted 
        ? 'border-red-700 shadow-lg shadow-red-900/30' 
        : 'border-game-border/50 hover:border-red-800/50';

  const bgClass = item.quality === 'mythic' 
    ? 'mythic-card-bg' 
    : item.quality === 'legendary' 
      ? 'legendary-card-bg' 
      : 'bg-game-bg/80';

  return (
    <div
      onClick={onClick}
      className={`${bgClass} border rounded-xl p-4 space-y-3 transition-all duration-200 relative group hover:shadow-lg ${borderClass} ${onClick ? 'cursor-pointer hover:scale-[1.02]' : ''}`}
    >
      {item.quality === 'mythic' && (
        <div className="mythic-ornaments" aria-hidden>
          <div className="mythic-embers" />
          <span className="mythic-sparkle s1" />
          <span className="mythic-sparkle s2" />
          <span className="mythic-sparkle s3" />
          <span className="mythic-sparkle s4" />
          <span className="mythic-sparkle s5" />
          <div className="mythic-shard sh1" />
          <div className="mythic-shard sh2" />
          <div className="mythic-shard sh3" />
          <div className="mythic-ember-trail" />
        </div>
      )}
      {item.equipped && (
        <span className="absolute top-2 right-2 text-[10px] px-2 py-0.5 rounded-full bg-red-900/20 text-red-400 border border-red-700/30 font-bold">
          {t('label.equipped')}
        </span>
      )}
      <div className="flex justify-between items-start">
        <div className="flex items-center gap-2">
          <div className="p-2 rounded-lg bg-game-card/60 text-2xl leading-none">{item.icon || '馃О'}</div>
          <div>
            <h4 className={`font-bold text-sm ${qualityColor}`}>
              {localeName} {item.enhancementLevel > 0 ? `+${item.enhancementLevel}` : ''}
            </h4>
            <div className="flex items-center gap-2 mt-1">
              <span className="text-[10px] text-gray-500 uppercase font-mono">Lv.{item.level} 鈥?{item.slot}</span>
              <span className="text-[10px] px-1.5 py-0.5 rounded border border-white/15 bg-game-card/40 text-gray-300 font-mono inline-flex items-center gap-1">
                {qualityIcon}
                {getQualityLabel(item.quality)}
              </span>
            </div>
          </div>
        </div>
        <div className="flex items-center gap-1 text-[10px] text-yellow-400 font-mono">
          <Coins size={10} /> {QUALITY_CONFIG[item.quality].price}
        </div>
      </div>

      <div className="grid grid-cols-2 gap-x-4 gap-y-1 py-2 border-y border-game-border/50">
        {Object.entries(item.attributes).map(([k, v]) => (
          <div key={k} className="flex justify-between text-[10px]">
            <span className="text-gray-500">{getStatLabel(k)}</span>
            <span className="text-gray-300 font-mono">+{v}</span>
          </div>
        ))}
      </div>

      {item.affixes.length > 0 && (
        <div className="flex flex-wrap gap-1">
          {item.affixes.map((affix) => (
            <span
              key={`${affix.type}-${affix.value}`}
              className="text-[10px] px-2 py-0.5 rounded border border-cyan-500/30 bg-cyan-500/10 text-cyan-300"
            >
              {affixLabelMap[affix.type] || affix.type} +{affix.value}
            </span>
          ))}
        </div>
      )}

      {item.special && <p className="text-[10px] text-red-400 italic leading-tight">鈽?{item.special}</p>}

      {!readonly && (
        <div className="flex gap-2 pt-1">
          <button onClick={onEquip} disabled={loading} className="flex-1 py-1.5 bg-red-900/20 hover:bg-red-800 text-red-400 hover:text-white text-[10px] font-bold rounded-lg transition-all border border-red-700/20 cursor-pointer hover:scale-105">{t('button.equip')}</button>
          <button onClick={onForge} disabled={loading} className="flex-1 py-1.5 bg-yellow-500/10 hover:bg-yellow-500 text-yellow-400 hover:text-white text-[10px] font-bold rounded-lg transition-all border border-yellow-500/20 cursor-pointer hover:scale-105" title={`Cost ${forgeCost} gold`}>{t('button.enchant')}</button>
          <button onClick={onSell} disabled={loading} className="px-3 py-1.5 bg-red-500/10 hover:bg-red-500 text-red-400 hover:text-white text-[10px] font-bold rounded-lg transition-all border border-red-500/20 cursor-pointer hover:scale-105"><Trash2 size={12} /></button>
        </div>
      )}
    </div>
  );
}


===================== [D:\download\LootingRPG\src\components\game\PlayerCard.tsx] =====================
import BattleUnitCardBase from './BattleUnitCardBase';
import type { BattleSession } from '../../shared/types/game';

const percent = (value: number, max: number) => {
  if (max <= 0) return 0;
  return Math.max(0, Math.min(100, (value / max) * 100));
};

interface PlayerCardProps {
  session: BattleSession;
}

export function PlayerCard({ session }: PlayerCardProps) {
  const hpRatio = percent(session.player.currentHp, session.player.baseStats.hp);

  return (
    <BattleUnitCardBase
      className="w-full p-0"
    >
      <div className="relative w-full h-full">
        {/* icon explicitly centered with transform */}
        <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-4xl leading-none">
          馃
        </div>
        {/* health bar flush to bottom */}
        <div className="absolute bottom-0 left-0 right-0 h-2 rounded bg-gray-800 overflow-hidden">
          <div className="h-full bg-emerald-500" style={{ width: `${hpRatio}%` }} />
        </div>
      </div>
    </BattleUnitCardBase>
  );
}

export default PlayerCard;


===================== [D:\download\LootingRPG\src\components\game\PlayerPanel.tsx] =====================
import { ArrowUpCircle, Shield, Sword, User, Star, Gem, Package, Flame, Droplets, ShieldAlert, Sparkles, Gauge, Coins } from 'lucide-react';
import { getSlotLabel, getQualityLabel, getStatLabel } from '../../infra/i18n/labels';
import { getDerivedStats } from '../../domains/player/services/derivedStats';
import { QUALITY_CONFIG, SLOT_CONFIG, SLOTS } from '../../config/game/equipment';
import type { Equipment, GameState } from '../../types/game';
import { useTranslation } from 'react-i18next';
import { useState, useMemo } from 'react';
import type { ReactNode } from 'react';
import { motion } from 'motion/react';

const slotTypeIconMap: Record<string, ReactNode> = {
  sword:   <Sword   size={14} className="text-amber-400" />,
  user:    <User    size={14} className="text-gray-300"  />,
  package: <Package size={14} className="text-gray-300"  />,
  star:    <Star    size={14} className="text-red-400"   />,
  gem:     <Gem     size={14} className="text-blue-400"  />,
  shield:  <Shield  size={14} className="text-gray-400"  />,
};

interface PlayerPanelProps {
  gameState: GameState;
  onUnequip: (slot: string) => void;
}

export function PlayerPanel({ gameState, onUnequip }: PlayerPanelProps) {
  const { t, i18n } = useTranslation();
  const [selectedSlot, setSelectedSlot] = useState<string | null>(null);
  
  const derivedStats = useMemo(() => {
    const base = getDerivedStats(gameState);
    // add icons to each entry here so the util stays UI-agnostic
    return base.map((stat) => {
      let icon: ReactNode = null;
      switch (stat.key) {
        case 'dmg':
          icon = <Flame size={12} className="text-orange-300" />;
          break;
        case 'ls':
          icon = <Droplets size={12} className="text-red-300" />;
          break;
        case 'thorns':
          icon = <ShieldAlert size={12} className="text-emerald-300" />;
          break;
        case 'element':
          icon = <Sparkles size={12} className="text-cyan-300" />;
          break;
        case 'spd':
          icon = <Gauge size={12} className="text-red-400" />;
          break;
      }
      return { ...stat, icon };
    });
  }, [gameState]);

  const selectedItem = selectedSlot 
    ? gameState.currentEquipment[selectedSlot as keyof typeof gameState.currentEquipment] as Equipment | null
    : null;

  const selectedLocaleName = selectedItem
    ? (i18n.language.startsWith('zh')
      ? (selectedItem.localeNames?.zh || selectedItem.name)
      : (selectedItem.localeNames?.en || selectedItem.name))
    : '';

  const qualityColor = useMemo(() => {
    return selectedItem
      ? QUALITY_CONFIG[selectedItem.quality]?.color || 'text-gray-400'
      : 'text-gray-400';
  }, [selectedItem]);

  const handleSlotClick = (slot: string) => {
    const item = gameState.currentEquipment[slot as keyof typeof gameState.currentEquipment];
    if (item) {
      setSelectedSlot(selectedSlot === slot ? null : slot);
    }
  };

  const handleUnequipClick = () => {
    if (selectedSlot) {
      onUnequip(selectedSlot);
      setSelectedSlot(null);
    }
  };

  return (
    <div className="lg:col-span-4 space-y-3">
      <motion.section
        initial={{ opacity: 0, x: -20 }}
        animate={{ opacity: 1, x: 0 }}
        transition={{ delay: 0.08 }}
        className="bg-gradient-to-br from-game-card to-game-card/80 border border-game-border/50 rounded-xl p-3 shadow-xl shadow-red-900/20 relative overflow-hidden"
      >
        <div className="absolute inset-0 bg-gradient-to-br from-cyan-500/5 via-transparent to-fuchsia-500/5" />
        <h3 className="text-[10px] font-bold text-gray-500 uppercase tracking-widest mb-2 flex items-center gap-1.5 relative z-10">
          <Sparkles size={12} className="text-cyan-300" /> {t('player.affixBonuses')}
        </h3>

        <div className="grid grid-cols-5 gap-1.5 relative z-10">
          {derivedStats.map((stat) => {
            const active = stat.rawValue > 0;
            return (
              <motion.div
                key={stat.key}
                whileHover={{ scale: 1.02 }}
                className={`rounded-lg border px-2 py-1.5 transition-all ${active ? stat.accent : 'border-white/10 bg-white/[0.03] text-gray-500'}`}
              >
                <div className="flex flex-col items-center gap-1">
                  <span className="flex items-center gap-1">
                    {stat.icon}
                  </span>
                  <span className={`font-mono text-[10px] font-bold ${active ? 'text-white' : 'text-gray-500'}`}>
                    {stat.value}
                  </span>
                </div>
              </motion.div>
            );
          })}
        </div>
      </motion.section>

      <motion.section 
        initial={{ opacity: 0, x: -20 }}
        animate={{ opacity: 1, x: 0 }}
        transition={{ delay: 0.1 }}
        className="bg-gradient-to-br from-game-card to-game-card/80 border border-game-border/50 rounded-xl p-3 shadow-xl shadow-red-900/20 relative overflow-hidden"
      >
        <div className="absolute inset-0 bg-gradient-to-br from-red-900/10 to-transparent" />
        
        <h3 className="text-[10px] font-bold text-gray-500 uppercase tracking-widest mb-2 flex items-center gap-1.5 relative z-10">
          <Shield size={12} className="text-red-400" /> {t('player.currentEquipment')}
        </h3>
        
        <div className="grid grid-cols-3 gap-2 relative z-10">
          {SLOTS.map((slot) => {
            const item = (gameState.currentEquipment as Record<string, Equipment | null>)[slot] || null;
            const qualityClass = item ? {
              common: 'border-quality-common',
              uncommon: 'equip-slot-uncommon',
              rare: 'equip-slot-rare',
              epic: 'equip-slot-epic',
              legendary: 'equip-slot-legendary',
              mythic: 'equip-slot-mythic',
            }[item.quality] || 'border-game-border' : '';

            return (
            <div 
              key={slot}
              onClick={() => handleSlotClick(slot)}
              className={`relative aspect-square rounded-lg border border-dashed flex flex-col items-center justify-center transition-all duration-200 cursor-pointer ${
                selectedSlot === slot 
                  ? 'ring-2 ring-red-700 ring-offset-2 ring-offset-game-bg' 
                  : item 
                    ? `bg-game-bg/60 border-solid ${qualityClass}` 
                    : 'border-game-border/40 hover:border-red-800/40 hover:bg-game-card'
              }`}
            >
              {item ? (
                <div className="flex flex-col items-center">
                  <span className="text-3xl leading-none">{item.icon || '馃О'}</span>
                  {item.enhancementLevel > 0 && (
                    <span className="absolute top-1 right-1 text-[8px] font-mono text-red-400 bg-red-950/50 px-1 rounded">
                      +{item.enhancementLevel}
                    </span>
                  )}
                  {item.quality === 'legendary' && (
                    <div className="absolute inset-0 rounded-lg legendary-shine pointer-events-none" />
                  )}
                  {item.quality === 'mythic' && (
                    <div className="absolute inset-0 rounded-lg mythic-glow pointer-events-none" />
                  )}
                </div>
              ) : (
                <span className="text-[9px] text-gray-600 uppercase font-mono flex flex-col items-center gap-1">
                  {slotTypeIconMap[SLOT_CONFIG[slot]?.icon || 'package']}
                  {getSlotLabel(slot)}
                </span>
              )}
            </div>
          );        
        })}
        </div>
      </motion.section>

      {selectedItem && (
        <motion.section 
          initial={{ opacity: 0, y: 10 }}
          animate={{ opacity: 1, y: 0 }}
          className={`bg-game-bg/95 backdrop-blur-sm border rounded-xl p-4 shadow-2xl ${selectedItem.quality === 'mythic' ? 'mythic-border' : selectedItem.quality === 'legendary' ? 'legendary-border' : 'border-game-border'}`}
        >
          <div className="flex items-center gap-3 mb-3">
            <div className="p-2 rounded-lg bg-game-card/60 text-3xl leading-none">{selectedItem.icon || '馃О'}</div>
            <div>
              <h4 className={`font-bold text-sm ${qualityColor}`}>
                {selectedLocaleName} {selectedItem.enhancementLevel > 0 ? `+${selectedItem.enhancementLevel}` : ''}
              </h4>
              <div className="flex items-center gap-2 mt-1">
                <span className="text-[10px] text-gray-500 uppercase font-mono">Lv.{selectedItem.level} 鈥?{selectedItem.slot}</span>
              </div>
              <span className="text-[10px] px-1.5 py-0.5 rounded border border-white/15 bg-game-card/40 text-gray-300 font-mono mt-1 inline-block">
                {getQualityLabel(selectedItem.quality)}
              </span>
            </div>
            <div className="flex items-center gap-1 text-[10px] text-yellow-400 font-mono ml-auto">
              <Coins size={10} /> {QUALITY_CONFIG[selectedItem.quality].price}
            </div>
          </div>

          <div className="grid grid-cols-2 gap-x-4 gap-y-1 py-2 border-y border-game-border/50">
            {Object.entries(selectedItem.attributes).map(([k, v]) => (
              <div key={k} className="flex justify-between text-[10px]">
                <span className="text-gray-500">{getStatLabel(k)}</span>
                <span className="text-gray-300 font-mono">+{v}</span>
              </div>
            ))}
          </div>

          {selectedItem.affixes.length > 0 && (
            <div className="flex flex-wrap gap-1 mt-2">
              {(() => {
                const labelMap: Record<string, string> = {
                  crit_chance: t('stat.crit'),
                  lifesteal: t('stat.lifesteal'),
                  damage_bonus: t('stat.damage'),
                  thorns: t('trait.thorns'),
                  hp_bonus: t('stat.hp'),
                };
                return selectedItem.affixes.map((affix) => (
                  <span
                    key={`${affix.type}-${affix.value}`}
                    className="text-[9px] px-2 py-0.5 rounded border border-cyan-500/30 bg-cyan-500/10 text-cyan-300"
                  >
                    {labelMap[affix.type] || getStatLabel(affix.type)} +{affix.value}
                  </span>
                ));
              })()}
            </div>
          )}

          {selectedItem.special && (
            <p className="text-[10px] text-red-400 italic leading-tight mt-2">鈽?{selectedItem.special}</p>
          )}

          <div className="mt-3 pt-2 border-t border-game-border/50">
            <button 
              onClick={handleUnequipClick}
              className="w-full py-2 bg-red-900/30 hover:bg-red-800 text-red-300 hover:text-white text-xs font-bold rounded-lg transition-colors border border-red-700/30 cursor-pointer flex items-center justify-center gap-2"
            >
              <ArrowUpCircle size={14} />
              鍗镐笅瑁呭
            </button>
          </div>
        </motion.section>
      )}
    </div>
  );
}


===================== [D:\download\LootingRPG\src\components\ui\TabButton.tsx] =====================
import React from 'react';

interface TabButtonProps {
  active: boolean;
  onClick: () => void;
  label: string;
}

export const TabButton = React.memo(function TabButton({ active, onClick, label }: TabButtonProps) {
  return (
    <button
      onClick={onClick}
      className={`px-6 py-3 text-xs font-bold uppercase tracking-widest transition-all duration-200 border-b-2 cursor-pointer ${active ? 'text-red-400 border-red-500 bg-red-900/10' : 'text-gray-500 border-transparent hover:text-gray-300 hover:bg-gray-500/5'}`}
    >
      {label}
    </button>
  );
});


===================== [D:\download\LootingRPG\src\config\game\equipment.ts] =====================
// 鏈ā鍧楀悎骞朵簡鍘熸潵鐨勪袱涓厤缃枃浠讹細
// - `data/config/game/equipment.json`锛氬寘鍚澶囩浉鍏崇殑闈欐€侀厤缃暟鎹紝濡傚睘鎬ф睜銆佸搧璐ㄩ厤缃€佹Ы浣嶄俊鎭瓑銆?// - `data/config/game/equipments.csv`锛氬寘鍚澶囨ā鏉挎暟鎹紝鐢ㄤ簬浠?CSV 瀵煎叆鑷畾涔夎澶囥€侰SV 瑙ｆ瀽宸ュ叿涔熷湪姝ゆā鍧椾腑瀹炵幇骞跺鍑恒€?// 鎵€鏈夊鍑哄唴瀹瑰寘鎷熀纭€閰嶇疆甯搁噺銆侀厤鑹层€佷环鏍间俊鎭?// 浠ュ強涓轰簡璋冭瘯/鍔犺浇鑷畾涔夎澶囪€屼娇鐢ㄧ殑 CSV 瑙ｆ瀽宸ュ叿銆?
import equipment from '@data/config/game/equipment.json';
import csvRaw from '@data/config/game/equipments.csv?raw';

type QualityConfigItem = { stats: number; price: number; color: string; iconName: string };
type SlotItem = { id: string; name: string; icon: string };
type EnchantConfig = {
  enchantBaseCost?: number;
  rerollBaseCost?: number;
  lockCost?: number;
  enchantScaleByQuality?: number[];
  enchantCostMultiplierByQuality?: number[];
};
type EquipDataSchema = {
  statPool: string[];
  qualities: string[];
  slots: SlotItem[];
  qualityConfig: Record<string, QualityConfigItem>;
  affixCountByQuality: number[];
  baseMultiplierByQuality: number[];
  affixScaling: Record<string, number[]>;
  enchantConfig?: EnchantConfig;
};

// 浠?JSON 鏂囦欢涓姞杞借澶囬潤鎬侀厤缃暟鎹?const EquipData = equipment as unknown as EquipDataSchema;

// 鍙敤灞炴€ф睜锛堣瘝鏉＄被鍨嬶級
export const STAT_POOL: string[] = EquipData.statPool;
// 瑁呭鍝佽川鍒楄〃
export const QUALITIES: string[] = EquipData.qualities;
// 瑁呭妲戒綅 id 鏁扮粍
export const SLOTS: string[]     = EquipData.slots.map(s => s.id);
// 妲戒綅璇︾粏閰嶇疆锛屼究浜庨€氳繃 id 鏌ユ壘鍚嶇О鍜屽浘鏍?export const SLOT_CONFIG: Record<string, SlotItem> = EquipData.slots.reduce<Record<string, SlotItem>>((acc, s) => {
  acc[s.id] = s;
  return acc;
}, {});
// 鍝佽川閰嶇疆锛屽寘鍚熀纭€灞炴€у姞鎴愩€佷环鏍笺€侀鑹层€佸浘鏍囩瓑
export const QUALITY_CONFIG: Record<string, QualityConfigItem> = EquipData.qualityConfig as Record<string, QualityConfigItem>;
export const getQualityColor = (quality: string): string => {return QUALITY_CONFIG[quality]?.color};
// 姣忎釜鍝佽川鍙嫢鏈夌殑璇嶆潯鏁般€佸熀纭€鍊嶇巼
export const AFFIX_COUNT_BY_QUALITY: number[]     = EquipData.affixCountByQuality;
export const BASE_MULTIPLIER_BY_QUALITY: number[] = EquipData.baseMultiplierByQuality;
// 闄勯瓟鐩稿叧閰嶇疆
export const ENCHANT_CONFIG: EnchantConfig = EquipData.enchantConfig ?? {};
/// 浠锋牸鐩稿叧
export const ENCHANT_BASE_COST: number = ENCHANT_CONFIG?.enchantBaseCost ?? 500;
export const REROLL_BASE_COST: number  = ENCHANT_CONFIG?.rerollBaseCost ?? 300;
export const LOCK_COST: number         = ENCHANT_CONFIG?.lockCost ?? 200;
/// 姣旂巼
export const AFFIX_SCALING: Record<string, number[]> = EquipData.affixScaling;
export const ENCHANT_SCALE_BY_QUALITY: number[] = ENCHANT_CONFIG?.enchantScaleByQuality ?? [0.05, 0.06, 0.07, 0.08, 0.10, 0.12];
export const ENCHANT_COST_MULTIPLIER_BY_QUALITY: number[] = ENCHANT_CONFIG?.enchantCostMultiplierByQuality ?? [1,1,1.05,1.1,1.25,1.5];


// 浠ヤ笅涓哄師鏉ョ殑 `src/config/content/equipments.ts` 鍐呭锛?// 宸蹭笌鏈枃浠跺悎骞讹紝姝ゆ枃浠剁幇鍦ㄨ礋璐ｈ澶囬潤鎬侀厤缃互鍙?// 浠?CSV 瀵煎叆瑁呭妯℃澘鐨勫姛鑳姐€?// 鍘熸枃浠惰寮冪敤锛岀浉鍏冲紩鐢ㄥ凡杩佺Щ鍒版湰妯″潡銆?
/**
 * 瑁呭妯℃澘鎺ュ彛锛屾弿杩?CSV 涓瘡涓€琛岀殑缁撴瀯銆? * 鍖呭惈鍩虹妲戒綅銆佸搧璐ㄣ€佸浘鏍囥€佸悕绉般€佸睘鎬с€佽瘝鏉′互鍙? * 绛夌骇缂╂斁绛夌敓鎴愯澶囨墍闇€鐨勪俊鎭€? */
export interface EquipmentTemplate {
  id: string;
  slot: string;
  quality: string;
  icon: string;
  nameZh: string;
  nameEn: string;
  specialZh?: string;
  specialEn?: string;
  attributes: Record<string, number>;
  affixes: Array<{ type: string; value: number }>;
  levelOffset: number;
  scalePerLevel: number;
}

// 浠ヤ笅鏄?CSV 瑙ｆ瀽宸ュ叿鍑芥暟锛岀敤浜庡皢瀛楃涓茶浆鎹负 JSON 瀵硅薄鎴栬瘝鏉℃暟缁勩€?const parseJsonObject = (value: string): Record<string, number> => {
  if (!value.trim()) return {};
  const parsed = JSON.parse(value);
  if (!parsed || typeof parsed !== 'object' || Array.isArray(parsed)) return {};
  const result: Record<string, number> = {};
  Object.entries(parsed as Record<string, unknown>).forEach(([key, raw]) => {
    const numberValue = Number(raw);
    if (Number.isFinite(numberValue)) {
      result[key] = numberValue;
    }
  });
  return result;
};
const parseAffixes = (value: string): Array<{ type: string; value: number }> => {
  if (!value.trim()) return [];
  try {
    const parsed = JSON.parse(value);
    if (!Array.isArray(parsed)) return [];

    const isAffixEntry = (entry: unknown): entry is { type?: unknown; value?: unknown } => {
      return typeof entry === 'object' && entry !== null;
    };

    return parsed
      .map((entry) => {
        if (!isAffixEntry(entry)) {
          return { type: '', value: NaN };
        }
        return {
          type: String(entry.type ?? '').trim(),
          value: Number(entry.value ?? 0),
        };
      })
      .filter((entry) => entry.type.length > 0 && Number.isFinite(entry.value));
  } catch {
    return [];
  }
};

// CSV 琛岃В鏋愬櫒锛屾敮鎸佸甫鍙屽紩鍙风殑鍗曞厓鏍煎拰杞箟銆?const parseCsvLine = (line: string): string[] => {
  const cells: string[] = [];
  let current = '';
  let inQuotes = false;

  for (let index = 0; index < line.length; index++) {
    const ch = line[index];
    const next = line[index + 1];

    if (ch === '"') {
      if (inQuotes && next === '"') {
        current += '"';
        index += 1;
      } else {
        inQuotes = !inQuotes;
      }
      continue;
    }

    if (ch === ',' && !inQuotes) {
      cells.push(current.trim());
      current = '';
      continue;
    }

    current += ch;
  }

  cells.push(current.trim());
  return cells;
};

let cachedTemplates: EquipmentTemplate[] | null = null;

/**
 * 浠?embedded CSV 鏂囨湰涓鍙栬澶囨ā鏉垮苟缂撳瓨銆? * csvRaw 鐢?Vite 鐨?`?raw` 瀵煎叆鎻愪緵銆? */
export const getEquipmentTemplates = (): EquipmentTemplate[] => {
  if (cachedTemplates) {
    return cachedTemplates;
  }

  // 浣跨敤鏂囦欢椤堕儴瀵煎叆鐨勫師濮?CSV 鏂囨湰
  //锛圴ite 鐨?`?raw` 淇濊瘉涓哄瓧绗︿覆锛夈€?  //const csvRaw: string = require('./content/equipments.csv?raw');

  const lines = csvRaw
    .split(/\r?\n/)
    .map((line) => line.trim())
    .filter((line) => line.length > 0 && !line.startsWith('#'));

  if (lines.length <= 1) {
    cachedTemplates = [];
    return [];
  }

  const header = parseCsvLine(lines[0]);

  const templates = lines.slice(1).map((line: string, rowIndex: number) => {
    const values = parseCsvLine(line);
    const row: Record<string, string> = {};
    header.forEach((key, index) => {
      row[key] = values[index] ?? '';
    });

    const id = row.id?.trim() || `csv_item_${rowIndex + 1}`;
    return {
      id,
      slot:    row.slot?.trim()    || 'Error',
      quality: row.quality?.trim() || 'Error',
      icon:    row.icon?.trim()    || 'Error',
      nameZh:  row.name_zh?.trim() || row.name_en?.trim() || `瑁呭${id}`,
      nameEn:  row.name_en?.trim() || row.name_zh?.trim() || `瑁呭${id}`,
      specialZh: row.special_zh?.trim() || row.special_en?.trim() || `Error Special`,
      specialEn: row.special_en?.trim() || row.special_zh?.trim() || `Error Special`,
      attributes: parseJsonObject(row.attributes || ''),
      affixes:    parseAffixes(row.affixes || ''),
      levelOffset: Math.floor(Number(row.levelOffset) || 0),
      scalePerLevel:  Number(row.scalePerLevel) || 0,
    } satisfies EquipmentTemplate;
  });

  cachedTemplates = templates;
  return templates;
};


===================== [D:\download\LootingRPG\src\config\game\gameConfig.ts] =====================
import type { GameState, PlayerStats, Equipment } from '../../shared/types/game';
import { PLAYER_GROWTH } from './progression';
/**
 * 娓告垙鍏ㄥ眬閰嶇疆瀵硅薄
 * - INITIAL_STATE: 鍏ㄩ儴娓告垙鐘舵€佺殑鍒濆蹇収
 *   鐢ㄤ簬鏂板瓨妗ｅ垱寤恒€侀噸缃互鍙婂湪璁＄畻涓綔涓哄熀鍑嗗€笺€? *   鍏朵粬妯″潡渚嬪 "playerStats.ts" 浼氬紩鐢ㄦ瀵硅薄鑾峰彇鍩虹鏁板€笺€? */
const basePlayerStats: PlayerStats = {
  level: 1, xp: 0, attack: PLAYER_GROWTH.baseAttack,
  hp: PLAYER_GROWTH.baseHp,
  defense: PLAYER_GROWTH.baseDefense,
  critRate: `${PLAYER_GROWTH.baseCritRate}`, // 鐧惧垎鏁板瓧绗︿覆褰㈠紡
  damageBonus: 0, lifesteal: 0,
  thorns: 0, elemental: 0, attackSpeed: 0, gold: 0,
};

import { SLOTS } from './equipment';

export const INITIAL_STATE: GameState = {
  playerStats: basePlayerStats,
  droppedEquipment: null,
  backpack: [] as Equipment[],
  systemMessage: '',
  currentEquipment: Object.fromEntries(SLOTS.map((s) => [s, null])) as Record<string, Equipment | null>,
  pityCounts: {
    legendary: 0,
    mythic: 0,
  },
  battle: {
    activeSession: null,
    history: [],
  },
};

// 鍚庣画鍙互鍦ㄦ娣诲姞鍏朵粬涓庢父鎴忔牳蹇冩湁鍏崇殑闈欐€侀厤缃」锛屼緥濡傛帀钀界巼銆佺粡楠岃〃绛夈€


===================== [D:\download\LootingRPG\src\config\game\monsterSchema.ts] =====================
import monsterConfig from '@data/config/game/monsterConfig.json';
export type MonsterTrait          = typeof monsterConfig.traits[number];
export type ThreatType            = typeof monsterConfig.threatTypes[number];
export type MonsterType           = typeof monsterConfig.monsterTypes[number];
export type MonsterScalingProfile = keyof typeof monsterConfig.scalingProfileStats;
export type ScalingProfileStats = { [key in MonsterScalingProfile]: EntityStats };
export type StrategyTag           = typeof monsterConfig.strategy.tag[number];
export type CounterStatKey        = typeof monsterConfig.strategy.counterGoalScoreMap[keyof typeof monsterConfig.strategy.counterGoalScoreMap];
export const SCALING_PROFILES: ScalingProfileStats =
  (monsterConfig as any).scalingProfileStats as ScalingProfileStats;
export interface RawMonsterBaseStats { hp?: number; attack?: number; defense?: number}
// 鍩虹鐢熷懡/鏀诲嚮/闃插尽涓夊洿锛屽彲渚涚帺瀹跺拰鎬墿缁熶竴浣跨敤
export interface EntityStats { hp: number; attack: number; defense: number; }
export interface RawBossCounterGoal {
  title?: string; titleKey?: string;
  stat?: string; threshold?: number;
  successText?: string; successTextKey?: string;
  failText?: string; failTextKey?: string
}
export interface RawMonsterData {
  id?: string;
  icon?: string;
  monsterType?: MonsterType;
  baseStats?: RawMonsterBaseStats;
  scalingProfile?: string;
  skillSet?: string[];
  traits?: MonsterTrait[];
  uniqueTraits?: MonsterTrait[];
  threatTypes?: string[];
  background?: string;
  dropdict?: Record<string, number>;
}
export interface RawBossData extends RawMonsterData {
  bossIdentity?: {
    theme?: string;
    introLine?: string;
    introLineKey?: string;
    battleLogLine?: string;
    battleLogLineKey?: string;
    phasePrompts?: Record<string, string>;
  };
  counterGoal?: RawBossCounterGoal;
  counterGoalLabel?: string;
}
export type MonsterBaseStats = EntityStats;
export interface BossIdentity {
  theme: string;
  introLine: string;
  battleLogLine: string;
  phasePrompts?: Partial<Record<'entering' | 'fighting' | 'dying' | 'dropping', string>>;
}
export interface BossCounterGoal {
  title: string;
  stat: CounterStatKey;
  threshold: number;
  successText: string;
  failText: string;
}
//璇嶆潯璇勫垎鏄犲皠琛?export const traitScoreMap: Record<MonsterTrait, Partial<Record<StrategyTag, number>>> = monsterConfig.strategy.traitScoreMap;
//**瀵规姉鐩爣璁″垎琛?export const counterGoalScoreMap: Record<string, StrategyTag> = monsterConfig.strategy.counterGoalScoreMap;
export interface Monster {
  id:    string;     // 鍞竴鏍囪瘑绗?  name:  string;     // 鏄剧ず鍚嶇О
  icons: string[];   // 鍥炬爣鍒楄〃锛岃嚦灏戜竴涓?  level: number;     // 鎬墿绛夌骇锛屽奖鍝嶅睘鎬у拰鎺夎惤
  monsterType:    MonsterType;          /// 鎬墿绫诲瀷
  baseStats:      MonsterBaseStats;     /// 鍩虹灞炴€э紝鍖呭惈hp銆乤ttack鍜宒efense
  scalingProfile: MonsterScalingProfile;/// 灞炴€ф垚闀跨被鍨嬶紝褰卞搷灞炴€ч殢绛夌骇鐨勫闀挎柟寮?  skillSet?: string[];   /// 
  maxHp: number;  /// 
  attack: number; /// 
  defense: number;/// 
  traits?: MonsterTrait[];/// 
  threatTypes?: ThreatType[];
  /// 鎬墿鑳屾櫙鏁呬簨鏂囨湰锛屼粎鐢ㄤ簬UI鏄剧ず锛屼笉褰卞搷娓告垙閫昏緫
  background?: string;  
  bossIdentity?: BossIdentity;  ///> 浠匓oss鎬墿鎷ユ湁鐨勮韩浠戒俊鎭紝鍖呮嫭涓婚銆佷粙缁嶈鍜屾垬鏂楁棩蹇楄
  counterGoal?:  BossCounterGoal;
  ///> 鎬墿鐗瑰畾鐨勮鏁扮洰鏍囪揪鎴愮姸鎬侊紝浠呯敤浜嶶I鏄剧ず锛屽疄闄呴€昏緫浠嶄互鐜╁stats涓哄噯
  counterGoalLabel?: string;
  ///> 鎬墿鐗瑰畾鐨勮鏁扮洰鏍囪揪鎴愮姸鎬侊紝浠呯敤浜嶶I鏄剧ず锛屽疄闄呴€昏緫浠嶄互鐜╁stats涓哄噯
  counterGoalPassed?: boolean;
  ///> 鎬墿鐗瑰畾鐨勬帀钀藉瓧鍏革紝鏍煎紡涓?{ [equipmentTemplateId]: chance }锛岀敤浜庤鐩栭粯璁ゆ帀钀介€昏緫
  dropdict?: Record<string, number>;
}


===================== [D:\download\LootingRPG\src\config\game\progression.ts] =====================
export const PLAYER_GROWTH = {
  baseAttack: 50,
  attackPerLevel: 5,
  baseHp: 300,
  hpPerLevel: 20,
  baseDefense: 5,
  defensePerLevel: 2,
  baseCritRate: 5,
  xpPerLevel: 100,
};


===================== [D:\download\LootingRPG\src\config\map\ChapterData.ts] =====================
/**
 * @deprecated 杩佺Щ杩囨浮灞傦細璇蜂紭鍏堜粠 `src/domains/map/model/chapters.ts` 寮曠敤銆? */
export type {
  NodeWave,
  MapNodeDef,
  MapChapterDef,
} from '../../domains/map/model/chapters';

/**
 * @deprecated 杩佺Щ杩囨浮灞傦細璇蜂紭鍏堜粠 `src/domains/map/model/chapters.ts` 寮曠敤銆? */
export { MAP_CHAPTERS } from '../../domains/map/model/chapters';


===================== [D:\download\LootingRPG\src\config\map\mapNode.ts] =====================
import nodeUiConfig from '@data/config/map/mapNode.json';
export type ChapterTheme = typeof nodeUiConfig.chapterNodeStyles extends Record<infer K, unknown> ? K : never;
export interface NodeEncounterStyle {
  shape: string; size: string; iconColor: string; ringColor: string;
  glowColor: string; particleColor: string; bgGradient: string; borderStyle: string;
}
export type MapEncounterType = typeof nodeUiConfig.encounterTypes[number];
export interface ThemeColors { primary: string; primaryLight: string; primaryDark: string;}
export const themeColors: Record<ChapterTheme, ThemeColors> = nodeUiConfig.THEME_COLORS;
export const defaultEncounterStyles: Record<MapEncounterType, NodeEncounterStyle> = nodeUiConfig.defaultEncounterStyles;
export const chapterNodeStyles: Record<ChapterTheme, Record<MapEncounterType, NodeEncounterStyle>> = nodeUiConfig.chapterNodeStyles;
export const MAP_NODE_CONFIG = nodeUiConfig.MAP_NODE_CONFIG as {
  bossIconSize: number;
  normalIconSize: number;
  starCount: Record<MapEncounterType, number>;
  floatDelayBase: number;
  floatDelayIncrement: number;
  animationDuration: { float: number; hover: number; glow: number; particle: number };
  hoverScale: number;
  hoverY: number;
  tapScale: number;
};

export const HEADER_CONFIG = {
  titleSize: 'text-base',
  subtitleSize: 'text-[10px]',
  infoBadgePadding: 'px-2 py-1',
  progressBarHeight: 4,
};

export const themeHeaderColors: Record<ChapterTheme, { primary: string; secondary: string; glow: string; border: string; text: string }> = nodeUiConfig.THEME_HEADER_COLORS;


===================== [D:\download\LootingRPG\src\config\runtime\storage.ts] =====================
export const STORAGE_KEY = 'ai_rpg_save_local';
export const PROFILE_INDEX_KEY = 'ai_rpg_profiles';
export const ACTIVE_PROFILE_KEY = 'ai_rpg_active_profile';


===================== [D:\download\LootingRPG\src\config\themes\ThemeContext.tsx] =====================
import { createContext, useContext, useState, useEffect, useCallback, type ReactNode } from 'react';
import type { Theme, ThemeContextValue } from './types';
import DarkScareTheme from '@data/config/themes/DarkScare.json';
import ArcaneMysticTheme from '@data/config/themes/ArcaneMystic.json';

const themes: Theme[] = [DarkScareTheme, ArcaneMysticTheme];

const STORAGE_KEY = 'game-theme';

const ThemeContext = createContext<ThemeContextValue | null>(null);

function getStoredTheme(): string {
  try {
    return localStorage.getItem(STORAGE_KEY) || 'dark-scare';
  } catch {
    return 'dark-scare';
  }
}

export function ThemeProvider({ children }: { children: ReactNode }) {
  const [currentThemeId, setCurrentThemeId] = useState<string>(getStoredTheme);
  const [theme, setTheme] = useState<Theme>(() => {
    return themes.find(t => t.id === currentThemeId) || themes[0];
  });

  const setThemeById = useCallback((themeId: string) => {
    const found = themes.find(t => t.id === themeId);
    if (found) {
      setCurrentThemeId(themeId);
      setTheme(found);
        localStorage.setItem(STORAGE_KEY, themeId);
    }
  }, []);

  useEffect(() => {
    const root = document.documentElement;
    root.style.setProperty('--color-game-bg', theme.colors.gameBg);
    root.style.setProperty('--color-game-card', theme.colors.gameCard);
    root.style.setProperty('--color-game-border', theme.colors.gameBorder);
    root.style.setProperty('--color-game-accent', theme.colors.gameAccent);
    root.style.setProperty('--color-game-cta', theme.colors.gameCta);
    root.style.setProperty('--color-quality-common', theme.colors.quality.common);
    root.style.setProperty('--color-quality-uncommon', theme.colors.quality.uncommon);
    root.style.setProperty('--color-quality-rare', theme.colors.quality.rare);
    root.style.setProperty('--color-quality-epic', theme.colors.quality.epic);
    root.style.setProperty('--color-quality-legendary', theme.colors.quality.legendary);
    root.style.setProperty('--color-quality-mythic', theme.colors.quality.mythic);
  }, [theme]);

  return (
    <ThemeContext.Provider value={{ theme, setTheme: setThemeById, themes }}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme(): ThemeContextValue {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
}


===================== [D:\download\LootingRPG\src\config\themes\types.ts] =====================
export interface ThemeColors {
  gameBg: string;
  gameCard: string;
  gameBorder: string;
  gameAccent: string;
  gameCta: string;
  quality: {
    common: string;
    uncommon: string;
    rare: string;
    epic: string;
    legendary: string;
    mythic: string;
  };
}

export interface ThemeGradients {
  body: string;
}

export interface Theme {
  id: string;
  name: string;
  description: string;
  colors: ThemeColors;
  gradients: ThemeGradients;
}

export interface ThemeContextValue {
  theme: Theme;
  setTheme: (themeId: string) => void;
  themes: Theme[];
}


===================== [D:\download\LootingRPG\src\config\ui\tokens.ts] =====================
export const UI_DIMENSIONS = {
  monsterIconSize: 22,
  codexIconSize: 32,
  nodeIconSize: 14,
  waveBadgeWidth: 40,
  waveBadgeHeight: 16,
  progressBarWidth: 20,
  progressBarHeight: 2,
};

export const UI_STYLES = {
  nodeWaveLabel: 'text-[8px] px-1 rounded-bl bg-black/60',
};


===================== [D:\download\LootingRPG\src\domains\battle\engine\ActionResolver.ts] =====================
import type { BattleAction, BattleSession } from '../../../shared/types/game';
import type { BattleUnitInstance } from '../../../types/battle/BattleUnit';
import { resolveDamage } from './DamagePipeline';
import type { BattleEventBus } from './EventBus';
const isApplyDamageEvent = (
  event: BattleSession['events'][number],
): event is Extract<BattleSession['events'][number], { type: 'apply_damage' }> => event.type === 'apply_damage';

const getUnitById = (session: BattleSession, unitId: string): BattleUnitInstance | undefined => {
  if (session.player.id === unitId) {
    return session.player;
  }
  return session.enemies.find((enemy) => enemy.id === unitId);
};

export const resolveAction = (
  session: BattleSession,
  action: BattleAction,
  eventBus: BattleEventBus,
): BattleSession => {
  const source = getUnitById(session, action.sourceId);
  if (!source || source.currentHp <= 0) {
    return session;
  }

  if (action.type !== 'basic_attack') {
    return session;
  }

  for (const targetId of action.targetIds) {
    const target = getUnitById(session, targetId);
    if (!target || target.currentHp <= 0) {
      continue;
    }

    const eventCountBefore = eventBus.getEvents().length;
    resolveDamage(
      {
        source,
        target,
        baseDamage: 0,
        critMultiplier: 1,
        modifiers: [],
      },
      eventBus,
    );

    const latestEvents = eventBus.getEvents().slice(eventCountBefore);
    const dealt = latestEvents
      .filter(isApplyDamageEvent)
      .filter((event) => event.sourceId === source.id && event.targetId === target.id)
      .reduce((total, event) => total + event.amount, 0);
    session.logs.push(`[Battle] Turn ${session.turn}: ${source.name} dealt ${dealt} to ${target.name}.`);
  }

  return session;
};


===================== [D:\download\LootingRPG\src\domains\battle\engine\BattleEngine.ts] =====================
import type { BattleSession } from '../../../shared/types/game';
import { BattleEventBus } from './EventBus';
import { resolveTurn } from './TurnManager';

export class BattleEngine {
  static resolveTurn(session: BattleSession): BattleSession {
    const eventBus = new BattleEventBus();
    return resolveTurn(session, eventBus);
  }
}


===================== [D:\download\LootingRPG\src\domains\battle\engine\DamagePipeline.ts] =====================
import { clamp, computeCritMultiplier, computeDamage, computeEffectiveDefense, computeEffectiveLifesteal } from '../battleMaths';
import type { BattleUnitInstance } from '../../../types/battle/BattleUnit';
import type { BattleEventBus } from './EventBus';

export interface DamageModifier {
  type: string;
  apply: (ctx: DamageContext) => void;
}

export interface DamageContext {
  source: BattleUnitInstance;
  target: BattleUnitInstance;
  baseDamage: number;
  critMultiplier: number;
  modifiers: DamageModifier[];
}

export const resolveDamage = (ctx: DamageContext, eventBus: BattleEventBus): void => {
  const didCrit = Math.random() < (ctx.source.derivedStats.critRate ?? 0);
  ctx.critMultiplier = computeCritMultiplier(didCrit, 0.6);

  const effectiveDefense = computeEffectiveDefense(
    ctx.target.baseStats.defense,
    ctx.source.derivedStats.elementalBonus ?? 0,
  );

  ctx.baseDamage = computeDamage(
    ctx.source.baseStats.attack,
    effectiveDefense,
    ctx.critMultiplier,
  );

  for (const modifier of ctx.modifiers) {
    modifier.apply(ctx);
  }

  const appliedDamage = Math.max(1, Math.floor(ctx.baseDamage));

  eventBus.emit({
    type: 'apply_damage',
    sourceId: ctx.source.id,
    targetId: ctx.target.id,
    amount: appliedDamage,
  });

  const effectiveLifesteal = computeEffectiveLifesteal(ctx.source.derivedStats.lifestealRate ?? 0);
  if (effectiveLifesteal > 0) {
    const heal = Math.floor(appliedDamage * effectiveLifesteal);
    if (heal > 0) {
      eventBus.emit({
        type: 'apply_heal',
        sourceId: ctx.source.id,
        targetId: ctx.source.id,
        amount: heal,
      });
    }
  }

  const thornsRate = clamp(ctx.target.derivedStats.thornsRate ?? 0, 0, 0.4);
  if (thornsRate > 0) {
    const reflectDamage = Math.floor(appliedDamage * thornsRate);
    if (reflectDamage > 0) {
      eventBus.emit({
        type: 'apply_damage',
        sourceId: ctx.target.id,
        targetId: ctx.source.id,
        amount: reflectDamage,
      });
    }
  }
};


===================== [D:\download\LootingRPG\src\domains\battle\engine\EffectResolver.ts] =====================
import type {
  ApplyDamageEvent,
  ApplyHealEvent,
  BattleEvent,
  BattleSession,
  UnitDiedEvent,
} from '../../../shared/types/game';
import type { BattleUnitInstance } from '../../../types/battle/BattleUnit';

const findUnit = (session: BattleSession, unitId: string): BattleUnitInstance | undefined => {
  if (session.player.id === unitId) {
    return session.player;
  }
  return session.enemies.find((enemy) => enemy.id === unitId);
};

function handleApplyDamage(
  session: BattleSession,
  event: ApplyDamageEvent,
): UnitDiedEvent | undefined {
  const target = findUnit(session, event.targetId);
  if (!target) {
    return;
  }

  target.currentHp -= event.amount;

  if (target.currentHp <= 0) {
    target.currentHp = 0;
    return {
      type: 'unit_died',
      unitId: target.id,
    };
  }

  return;
}

function handleApplyHeal(session: BattleSession, event: ApplyHealEvent): void {
  const target = findUnit(session, event.targetId);
  if (!target) {
    return;
  }

  const maxHp = target.baseStats.hp;
  target.currentHp = Math.min(maxHp, target.currentHp + event.amount);
}

function handleUnitDied(session: BattleSession, event: UnitDiedEvent): void {
  const unit = findUnit(session, event.unitId);
  if (!unit) {
    return;
  }

  unit.currentHp = 0;
  session.logs.push(`[Battle] ${unit.name} defeated.`);
}

export function resolveEffects(
  session: BattleSession,
  events: BattleEvent[],
): BattleSession {
  const pendingEvents: BattleEvent[] = [...events];

  while (pendingEvents.length > 0) {
    const event = pendingEvents.shift();
    if (!event) {
      break;
    }

    session.events.push(event);

    switch (event.type) {
      case 'apply_damage': {
        const deathEvent = handleApplyDamage(session, event);
        if (deathEvent) {
          pendingEvents.push(deathEvent);
        }
        break;
      }
      case 'apply_heal':
        handleApplyHeal(session, event);
        break;
      case 'unit_died':
        handleUnitDied(session, event);
        break;
      default:
        break;
    }
  }

  return session;
}


===================== [D:\download\LootingRPG\src\domains\battle\engine\EventBus.ts] =====================
import type { BattleEvent } from '../../../shared/types/game';

export class BattleEventBus {
  private readonly events: BattleEvent[] = [];

  emit(event: BattleEvent): void {
    this.events.push(event);
  }

  getEvents(): BattleEvent[] {
    return [...this.events];
  }

  drainEvents(): BattleEvent[] {
    const snapshot = [...this.events];
    this.events.length = 0;
    return snapshot;
  }
}


===================== [D:\download\LootingRPG\src\domains\battle\engine\TurnManager.ts] =====================
import type { BattleAction, BattleSession } from '../../../shared/types/game';
import type { BattleUnitInstance } from '../../../types/battle/BattleUnit';
import type { BattleEventBus } from './EventBus';
import { resolveAction } from './ActionResolver';
import { resolveEffects } from './EffectResolver';

const cloneBattleUnit = (unit: BattleUnitInstance): BattleUnitInstance => ({
  ...unit,
  baseStats: { ...unit.baseStats },
  derivedStats: { ...unit.derivedStats },
  skills: [...unit.skills],
  passives: [...unit.passives],
  elements: [...unit.elements],
  tags: [...unit.tags],
  meta: unit.meta ? { ...unit.meta } : undefined,
});

const cloneSession = (session: BattleSession): BattleSession => ({
  ...session,
  player: cloneBattleUnit(session.player),
  enemies: session.enemies.map((enemy) => cloneBattleUnit(enemy)),
  logs: [...session.logs],
  events: [],
});

const getWaveId = (unit: BattleUnitInstance, fallback: string): string => {
  const value = unit.meta?.waveId;
  return typeof value === 'string' ? value : fallback;
};

const isAlive = (unit: BattleUnitInstance): boolean => unit.currentHp > 0;

const getCurrentWaveAliveEnemies = (session: BattleSession): BattleUnitInstance[] => {
  const currentWaveId = session.waveOrder[session.currentWaveIndex];
  if (!currentWaveId) {
    return [];
  }
  return session.enemies.filter((enemy, index) => getWaveId(enemy, `wave-${index + 1}`) === currentWaveId && isAlive(enemy));
};

const updateBattleOutcome = (session: BattleSession): void => {
  const playerAlive = isAlive(session.player);
  const enemyAlive = session.enemies.some(isAlive);

  if (!playerAlive) {
    session.status = 'defeat';
    session.phase = 'finished';
    return;
  }

  if (!enemyAlive) {
    session.status = 'victory';
    session.phase = 'finished';
    return;
  }

  session.status = 'fighting';
};

const advanceWaveIfNeeded = (session: BattleSession): void => {
  while (session.currentWaveIndex < session.waveOrder.length) {
    const aliveEnemies = getCurrentWaveAliveEnemies(session);
    if (aliveEnemies.length > 0) {
      break;
    }
    session.currentWaveIndex += 1;
  }
};

export const resolveTurn = (session: BattleSession, eventBus: BattleEventBus): BattleSession => {
  if (session.status !== 'fighting') {
    return session;
  }
  const nextSession = cloneSession(session);
  nextSession.turn += 1;
  nextSession.phase = 'resolving';

  advanceWaveIfNeeded(nextSession);
  let aliveEnemies = getCurrentWaveAliveEnemies(nextSession);

  if (aliveEnemies.length === 0) {
    updateBattleOutcome(nextSession);
    eventBus.emit({ type: 'turn_end' });
    nextSession.events = eventBus.drainEvents();
    return nextSession;
  }

  const playerAction: BattleAction = {
    id: `action_${nextSession.turn}_player`,
    type: 'basic_attack',
    sourceId: nextSession.player.id,
    targetIds: [aliveEnemies[0].id],
  };

  resolveAction(nextSession, playerAction, eventBus);
  const playerActionEvents = eventBus.drainEvents();
  resolveEffects(nextSession, playerActionEvents);
  updateBattleOutcome(nextSession);
  if (nextSession.status !== 'fighting') {
    eventBus.emit({ type: 'turn_end' });
    nextSession.events.push(...eventBus.drainEvents());
    return nextSession;
  }

  advanceWaveIfNeeded(nextSession);
  aliveEnemies = getCurrentWaveAliveEnemies(nextSession);
  if (aliveEnemies.length === 0) {
    updateBattleOutcome(nextSession);
    eventBus.emit({ type: 'turn_end' });
    nextSession.events = eventBus.drainEvents();
    return nextSession;
  }

  nextSession.phase = 'enemy_turn';
  for (const enemy of aliveEnemies) {
    const enemyAction: BattleAction = {
      id: `action_${nextSession.turn}_${enemy.id}`,
      type: 'basic_attack',
      sourceId: enemy.id,
      targetIds: [nextSession.player.id],
    };

    resolveAction(nextSession, enemyAction, eventBus);
  }

  const enemyActionEvents = eventBus.drainEvents();
  resolveEffects(nextSession, enemyActionEvents);

  advanceWaveIfNeeded(nextSession);
  updateBattleOutcome(nextSession);
  if (nextSession.status === 'fighting') {
    nextSession.phase = 'player_input';
  }

  eventBus.emit({ type: 'turn_end' });
  nextSession.events.push(...eventBus.drainEvents());
  return nextSession;
};


===================== [D:\download\LootingRPG\src\domains\battle\services\monsterScaling.ts] =====================
import type { EntityStats } from '../../../shared/types/game';
import type { Monster } from '../../../config/game/monsterSchema';
import { SCALING_PROFILES } from '../../../config/game/monsterSchema';

export const getMapMonsterBaselineByLevel = (recommendedLevel: number): EntityStats => {
  const level = Math.max(1, recommendedLevel);
  return {
    hp: Math.floor(120 + (level - 1) * 14),
    attack: Math.floor(16 + (level - 1) * 1.35),
    defense: Math.floor(7 + (level - 1) * 0.72),
  };
};
export const resolveMonsterTemplateStats = (
  monster: Pick<Monster, 'baseStats' | 'scalingProfile'>,
  mapBaseline: EntityStats,
): { maxHp: number } & EntityStats => {
  const profile = SCALING_PROFILES[monster.scalingProfile] ?? SCALING_PROFILES.normal;
  return {
    maxHp:   Math.floor(mapBaseline.hp      * monster.baseStats.hp      * profile.hp),
    hp :     Math.floor(mapBaseline.hp      * monster.baseStats.hp      * profile.hp),
    attack:  Math.floor(mapBaseline.attack  * monster.baseStats.attack  * profile.attack),
    defense: Math.floor(mapBaseline.defense * monster.baseStats.defense * profile.defense),
  };
};


===================== [D:\download\LootingRPG\src\domains\battle\services\monsterStats.ts] =====================
import type { CounterStatKey, Monster } from '../../../shared/types/game';
import type { FinalPlayerCombatStats } from '../../player/model/combat';
import { getCombatProfile } from '../../player/model/combat';
import i18n from '../../../i18n';
import { getMapNodeById } from '../../map/services/nodeLookup';
import { getMapMonsterBaselineByLevel, resolveMonsterTemplateStats } from './monsterScaling';

export interface FinalMonsterCombatStats {
  maxHp: number;
  attack: number;
  defense: number;
  damageReduction: number;
  shieldReduction: number;
  rageMultiplier: number;
  bossSkillInterval: number;
  statusProcMultiplier: number;
  objectiveLabel: string | null;
  objectivePassed: boolean;
}

const clamp = (value: number, min: number, max: number): number => Math.max(min, Math.min(max, value));

const defenseToReductionRate = (
  defenseValue: number,
  hardCapRate: number,
  growthRate: number,
): number => {
  const normalized = Math.max(0, defenseValue);
  const rate = 1 - Math.exp(-growthRate * normalized);
  return clamp(rate, 0, hardCapRate);
};

const readPlayerCounterStat = (player: FinalPlayerCombatStats, stat: CounterStatKey): number => {
  if (stat === 'attack') return player.attack;
  if (stat === 'defense') return player.defense;
  if (stat === 'hp') return player.maxHp;
  if (stat === 'elemental') return player.elementalBonus;
  if (stat === 'lifesteal') return player.lifestealRate * 100;
  if (stat === 'thorns') return player.thornsRate * 100;
  if (stat === 'attackSpeed') return player.speed;
  return 0;
};

export const getFinalMonsterStats = (
  monster: Monster,
  playerLevel: number,
  encounterCount: number,
  isBoss: boolean,
  finalPlayer: FinalPlayerCombatStats,
  mapNodeId?: string,
): FinalMonsterCombatStats => {
  const monsterLevel = Math.max(1, Number(monster.level) || 1);
  const monsterLevelFactor = 1 + (monsterLevel - 1) * 0.08;
  const levelFactor = 1 + Math.max(0, playerLevel - 1) * 0.08;
  const encounterFactor = 1 + Math.min(0.65, encounterCount * 0.003);
  const hpFactor = isBoss ? 1.55 : 1.28;
  const attackFactor = isBoss ? 1.36 : 1.22;
  const defenseFactor = isBoss ? 1.32 : 1.18;
  const combatProfile = getCombatProfile();

  const mapNode = mapNodeId ? getMapNodeById(mapNodeId) : undefined;
  const mapBaseline = getMapMonsterBaselineByLevel(mapNode?.recommendedLevel ?? playerLevel);
  const templateStats = resolveMonsterTemplateStats(monster, mapBaseline);

  let maxHp = Math.floor(templateStats.maxHp * levelFactor * encounterFactor * hpFactor * monsterLevelFactor);
  let attack = Math.floor(templateStats.attack * levelFactor * encounterFactor * attackFactor * combatProfile.monsterDamageMultiplier * monsterLevelFactor);
  let defense = Math.floor(templateStats.defense * levelFactor * encounterFactor * defenseFactor * (1 + (monsterLevel - 1) * 0.06));

  let objectivePassed = true;
  let objectiveLabel: string | null = null;

  if (monster.monsterType === 'boss' && monster.counterGoal) {
    const currentValue = readPlayerCounterStat(finalPlayer, monster.counterGoal.stat);
    objectivePassed = currentValue >= monster.counterGoal.threshold;
    objectiveLabel = objectivePassed
      ? i18n.t('codex.counterGoal.passed', { title: monster.counterGoal.title, detail: monster.counterGoal.successText })
      : i18n.t('codex.counterGoal.failed', { title: monster.counterGoal.title, detail: monster.counterGoal.failText });

    if (objectivePassed) {
      attack = Math.floor(attack * 0.95);
      defense = Math.floor(defense * 0.9);
    } else {
      maxHp = Math.floor(maxHp * 1.22);
      attack = Math.floor(attack * 1.18);
      defense = Math.floor(defense * 1.15);
    }
  }

  const damageReduction = defenseToReductionRate(defense, 0.62, 0.011);

  return {
    maxHp: Math.max(1, maxHp),
    attack: Math.max(1, attack),
    defense: Math.max(0, defense),
    damageReduction,
    shieldReduction: 0.6,
    rageMultiplier: 1.3,
    bossSkillInterval: combatProfile.bossSkillInterval,
    statusProcMultiplier: combatProfile.statusProcMultiplier,
    objectiveLabel,
    objectivePassed,
  };
};

export const calculateFinalMonsterStats = getFinalMonsterStats;

interface TurnSnapshotOptions {
  monsterIsShocked: boolean;
  shieldTurns: number;
  monsterRageActive: boolean;
}

export interface TurnCombatSnapshot {
  playerAttack: number;
  monsterAttack: number;
  playerDamageReduction: number;
  monsterDamageReduction: number;
  shieldMultiplier: number;
}

export const getTurnCombatSnapshot = (
  finalPlayer: FinalPlayerCombatStats,
  finalMonster: FinalMonsterCombatStats,
  options: TurnSnapshotOptions,
): TurnCombatSnapshot => {
  const monsterDamageReduction = finalMonster.damageReduction * (options.monsterIsShocked ? 0.8 : 1);
  const monsterAttack = finalMonster.attack * (options.monsterRageActive ? finalMonster.rageMultiplier : 1);

  return {
    playerAttack: finalPlayer.attack,
    monsterAttack,
    playerDamageReduction: finalPlayer.damageReduction,
    monsterDamageReduction: clamp(monsterDamageReduction, 0, 0.85),
    shieldMultiplier: options.shieldTurns > 0 ? finalMonster.shieldReduction : 1,
  };
};


===================== [D:\download\LootingRPG\src\domains\battle\services\session.ts] =====================
import type { BattleResult, BattleSession, GameState, MapProgressState} from '../../../shared/types/game';
import type { BattleUnitInstance, BattleUnitSchema } from '../../../types/battle/BattleUnit';
import type { MapChapterDef, MapNodeDef, NodeWave } from '../../map/model/chapters';
import { getFinalPlayerStats } from '../../player/model/combat';
import { getFinalMonsterStats } from './monsterStats';
import { getMonsterById } from '../../monster/config';
import { applyMapNodeResult } from '../../map/services/progress';
import { PLAYER_GROWTH } from '../../game/config/progression';
import { recalculatePlayerStats } from '../../player/services/recalculatePlayerStats';
import { generateEquipment } from '../../inventory/services/equipment';
import { createBattleUnit } from '../UnitFactory';
import { BattleEngine } from '../engine/BattleEngine';
import i18n from '../../../i18n';
interface BattleTransition {
  nextGameState: GameState;
  nextMapProgress: MapProgressState;
  logs: string[];
  focusNodeId?: string;
  error?: string;
}

const toBattleLog = (message: string) => `[Battle] ${message}`;

const getUnitMetaString = (unit: BattleUnitInstance, key: string): string | undefined => {
  const value = unit.meta?.[key];
  return typeof value === 'string' ? value : undefined;
};

const getUnitMetaBoolean = (unit: BattleUnitInstance, key: string): boolean => {
  return unit.meta?.[key] === true;
};

const getUnitMetaDropDict = (unit: BattleUnitInstance): Record<string, number> | undefined => {
  const value = unit.meta?.dropdict;
  if (!value || typeof value !== 'object' || Array.isArray(value)) {
    return undefined;
  }
  return value as Record<string, number>;
};

const getWaveId = (unit: BattleUnitInstance, fallback: string): string => {
  return getUnitMetaString(unit, 'waveId') ?? fallback;
};

const ensureNodeWaves = (node: MapNodeDef): NodeWave[] => {
  if (!node.waves || node.waves.length === 0) {
    throw new Error(`Node ${node.id} has no waves configured.`);
  }
  return node.waves;
};
const normalizeSessionWaves = (session: BattleSession): BattleSession => {
  const enemies = (session.enemies ?? []).map((enemy, index) => ({
    ...enemy,
    meta: {
      ...(enemy.meta ?? {}),
      waveId: getWaveId(enemy, `wave-${index + 1}`),
    },
  }));

  const inferredWaveOrder = Array.from(new Set(enemies.map((enemy, index) => getWaveId(enemy, `wave-${index + 1}`))));
  const existingWaveOrder = Array.isArray(session.waveOrder) ? session.waveOrder : [];
  const waveOrder = existingWaveOrder.length > 0
    ? existingWaveOrder.filter((waveId) => inferredWaveOrder.includes(waveId))
    : inferredWaveOrder;
  const safeWaveOrder = waveOrder.length > 0 ? waveOrder : inferredWaveOrder;
  const maxWaveIndex = Math.max(0, safeWaveOrder.length - 1);
  const currentWaveIndex = Number.isFinite(session.currentWaveIndex)
    ? Math.max(0, Math.min(maxWaveIndex, session.currentWaveIndex))
    : 0;

  return {
    ...session,
    enemies,
    waveOrder: safeWaveOrder,
    currentWaveIndex,
    phase: session.phase ?? 'player_input',
    events: Array.isArray(session.events) ? session.events : [],
  };
};
const buildEnemyUnit = (
  node: MapNodeDef,
  wave: NodeWave,
  waveId: string,
  monsterId: string,
  enemyIndex: number,
  playerLevel: number,
  playerFinal: ReturnType<typeof getFinalPlayerStats>,
): BattleUnitInstance => {
  const monster = getMonsterById(monsterId);
  if (!monster) {
    throw new Error(`Monster '${monsterId}' not found in content config.`);
  }

  const isBoss = node.encounterType === 'boss' || monster.monsterType === 'boss';
  const finalMonster = getFinalMonsterStats(monster, playerLevel, enemyIndex, isBoss, playerFinal, node.id);

  const monsterSchema: BattleUnitSchema = {
    id: `${waveId}-${monster.id}-${enemyIndex}`,
    name: monster.name,
    faction: 'monster',
    baseStats: {
      hp: finalMonster.maxHp,
      attack: finalMonster.attack,
      defense: finalMonster.defense,
    },
    skills: monster.skillSet ?? [],
    passives: [],
    elements: [],
    tags: [monster.monsterType],
    aiProfile: 'default',
    derivedStats: {
      damageReduction: finalMonster.damageReduction,
    },
    meta: {
      monsterId: monster.id,
      icon: monster.icons[0] ?? '馃懢',
      waveId,
      waveLabel: wave.label,
      isBoss,
      dropdict: monster.dropdict,
    },
  };

  return createBattleUnit(monsterSchema, playerLevel);
};
const resolveBattleResult = (
  gameState: GameState,
  mapProgress: MapProgressState,
  chapters: MapChapterDef[],
  session: BattleSession,
  won: boolean,
): BattleTransition => {
  const nodeChapter = chapters.find((chapter) => chapter.id === session.chapterId);
  const node = nodeChapter?.nodes.find((entry) => entry.id === session.nodeId);

  if (!nodeChapter || !node) {
    return {
      nextGameState: {
        ...gameState,
        battle: {
          ...gameState.battle,
          activeSession: null,
        },
      },
      nextMapProgress: mapProgress,
      logs: [toBattleLog('Battle ended but map node could not be resolved.')],
      error: 'Map node not found',
    };
  }

  const mapResult = applyMapNodeResult({
    progress: mapProgress,
    chapters,
    chapterId: nodeChapter.id,
    nodeId: node.id,
    won,
  });

  let nextState: GameState = {
    ...gameState,
    battle: {
      ...gameState.battle,
      activeSession: null,
    },
  };

  let xpGained = 0;
  let goldGained = 0;
  const logs: string[] = [];

  if (won) {
    xpGained = Math.max(15, node.recommendedLevel * 6 + session.enemies.length * 8);
    goldGained = node.firstClearRewardGold;

    const rewardEnemy = session.enemies.find((enemy) => getUnitMetaBoolean(enemy, 'isBoss')) ?? session.enemies[session.enemies.length - 1];
    const rewardDropDict = rewardEnemy ? getUnitMetaDropDict(rewardEnemy) : undefined;
    const drop = rewardEnemy
      ? generateEquipment(
          { monsterType: getUnitMetaBoolean(rewardEnemy, 'isBoss') ? 'boss' : 'normal', dropdict: rewardDropDict },
          gameState.pityCounts,
          gameState.playerStats.level,
        )
      : null;

    let nextXp = gameState.playerStats.xp + xpGained;
    let nextLevel = gameState.playerStats.level;
    while (nextXp >= nextLevel * PLAYER_GROWTH.xpPerLevel) {
      nextXp -= nextLevel * PLAYER_GROWTH.xpPerLevel;
      nextLevel += 1;
    }

    nextState = recalculatePlayerStats({
      ...nextState,
      playerStats: {
        ...nextState.playerStats,
        xp: nextXp,
        level: nextLevel,
        gold: nextState.playerStats.gold + goldGained,
      },
      pityCounts: drop?.newPity ?? nextState.pityCounts,
      droppedEquipment: drop?.item ?? null,
      backpack: drop?.item ? [...nextState.backpack, drop.item] : nextState.backpack,
    });

    logs.push(toBattleLog(`${session.nodeName} cleared.`));
    logs.push(toBattleLog(`Gained ${xpGained} XP and ${goldGained} gold.`));
    if (nextLevel > gameState.playerStats.level) {
      logs.push(toBattleLog(`Level up to Lv.${nextLevel}.`));
    }
    if (drop?.item) {
      logs.push(toBattleLog(`Loot acquired: ${drop.item.name}.`));
    }

    if (mapResult.unlockedNodeId) {
      logs.push(toBattleLog(`Unlocked node ${mapResult.unlockedNodeId}.`));
    }
    if (mapResult.unlockedChapterId) {
      logs.push(toBattleLog(`Unlocked chapter ${mapResult.unlockedChapterId}.`));
    }
  } else {
    logs.push(toBattleLog(`${session.nodeName} challenge failed.`));
  }

  const history: BattleResult = {
    sessionId: session.id,
    chapterId: session.chapterId,
    nodeId: session.nodeId,
    won,
    turns: session.turn,
    xpGained,
    goldGained,
    finishedAt: Date.now(),
  };

  nextState = {
    ...nextState,
    battle: {
      activeSession: null,
      history: [...nextState.battle.history.slice(-39), history],
    },
  };

  return {
    nextGameState: nextState,
    nextMapProgress: mapResult.nextProgress,
    logs,
    focusNodeId: won ? mapResult.unlockedNodeId : session.nodeId,
  };
};
export const startBattleSession = (
  gameState: GameState,
  chapter: MapChapterDef,
  node: MapNodeDef,
): { nextGameState: GameState; logs: string[]; error?: string } => {
  try {
    /// 1. 楠岃瘉鑺傜偣閰嶇疆
    // 纭繚鑺傜偣鏈夋尝娆￠厤缃紝骞朵笖姣忎釜娉㈡鑷冲皯鏈変竴涓€墿
    const nodeWaves = ensureNodeWaves(node);
    //  2. 璁＄畻鐜╁鏈€缁堝睘鎬?    const playerFinal = getFinalPlayerStats(gameState.playerStats, gameState.battle.history.length);
    //  3. 鍚堟硶娉㈡杩囨护锛氬彧淇濈暀閭ｄ簺閰嶇疆浜嗘€墿鐨勬尝娆★紝骞朵负姣忎釜鎬墿鐢熸垚涓€涓敮涓€鐨勬晫浜篒D锛堟牸寮忥細waveId-monsterId-index锛?    const validWaves = nodeWaves
      .map((wave, index) => ({ wave, waveId: wave.id || `wave-${index + 1}` }))
      .filter(({ wave }) => Array.isArray(wave.monsters) && wave.monsters.length > 0);
    //  4. 鏋勫缓鏁屾柟鍗曚綅锛氱粺涓€鍒涘缓涓?BattleUnitInstance
    const enemies: BattleUnitInstance[] = [];
    let enemyIndex = 0;
    //  5. 鎴樻枟浼氳瘽鏋勫缓锛氬皢鎵€鏈変俊鎭暣鍚堝埌涓€涓?BattleSession 瀵硅薄涓紝
    //     鍖呭惈鐜╁灞炴€с€佹晫浜哄垪琛ㄣ€佸綋鍓嶆尝娆＄姸鎬佺瓑
    for (const { wave, waveId } of validWaves) {
      for (const waveMonster of wave.monsters) {
        enemies.push(
          buildEnemyUnit(node, wave, waveId, waveMonster.monsterId, enemyIndex, gameState.playerStats.level, playerFinal),
        );
        enemyIndex += 1;
      }
    }

    if (enemies.length === 0) {
      throw new Error(`Node ${node.id} has no valid monsters in waves.`);
    }
    // 6. 閿欒澶勭悊锛氬鏋滃湪浠讳綍姝ラ涓彂鐢熼敊璇紙渚嬪閰嶇疆缂哄け銆佹暟鎹紓甯哥瓑锛夛紝
    // 鎹曡幏閿欒骞惰繑鍥炰竴涓寘鍚敊璇俊鎭殑缁撴灉瀵硅薄锛岀‘淇濊皟鐢ㄦ柟鑳藉姝ｇ‘澶勭悊寮傚父鎯呭喌銆?    const playerUnit = createBattleUnit(
      {
        id: 'player',
        name: 'Player',
        faction: 'player',
        baseStats: {
          hp: playerFinal.maxHp,
          attack: playerFinal.attack,
          defense: playerFinal.defense,
        },
        skills: [],
        passives: [],
        elements: [],
        tags: ['player'],
        derivedStats: {
          damageReduction: playerFinal.damageReduction,
          critRate: playerFinal.critRate,
          lifestealRate: playerFinal.lifestealRate,
          thornsRate: playerFinal.thornsRate,
          elementalBonus: playerFinal.elementalBonus,
        },
      },
      gameState.playerStats.level,
    );

    const session: BattleSession = {
      id: `battle_${Date.now()}`,
      chapterId: chapter.id,
        chapterName: i18n.t(`map.${chapter.id}`),
      nodeId: node.id,
      nodeName: node.name,
      encounterType: node.encounterType,
      turn: 0,
      player: playerUnit,
      enemies,
      waveOrder: validWaves.map((entry) => entry.waveId),
      currentWaveIndex: 0,
      phase: 'player_input',
      status: 'fighting',
      events: [],
      logs: [toBattleLog(`Entered ${i18n.t(`map.${chapter.id}`)} - ${node.name}.`)],
    };
    // 7. 杩斿洖缁撴灉瀵硅薄锛氬寘鍚洿鏂板悗鐨勬父鎴忕姸鎬併€佹棩蹇椾俊鎭互鍙婂彲鑳界殑閿欒淇℃伅
    return {
      nextGameState: {
        ...gameState,
        battle: {
          ...gameState.battle,
          activeSession: session,
        },
      },
      logs: [toBattleLog(`Challenge started: ${i18n.t(`map.${chapter.id}`)} / ${node.name}.`)],
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return {
      nextGameState: gameState,
      logs: [toBattleLog(`Cannot start battle: ${message}`)],
      error: message,
    };
  }
};

export const runBattlePlayerAttack = (
  gameState: GameState,
  mapProgress: MapProgressState,
  chapters: MapChapterDef[],
): BattleTransition => {
  const sessionRaw = gameState.battle.activeSession;
  if (!sessionRaw || sessionRaw.status !== 'fighting') {
    return {
      nextGameState: gameState,
      nextMapProgress: mapProgress,
      logs: [],
      error: 'No active battle session',
    };
  }

  const session = normalizeSessionWaves(sessionRaw);
  const nextSession = BattleEngine.resolveTurn(session);

  if (nextSession.status === 'victory') {
    return resolveBattleResult(
      {
        ...gameState,
        battle: { ...gameState.battle, activeSession: nextSession },
      },
      mapProgress,
      chapters,
      nextSession,
      true,
    );
  }

  if (nextSession.status === 'defeat') {
    return resolveBattleResult(
      {
        ...gameState,
        battle: { ...gameState.battle, activeSession: nextSession },
      },
      mapProgress,
      chapters,
      nextSession,
      false,
    );
  }

  return {
    nextGameState: {
      ...gameState,
      battle: { ...gameState.battle, activeSession: nextSession },
    },
    nextMapProgress: mapProgress,
    logs: nextSession.logs.slice(-3),
  };
};

export const runBattleRetreat = (
  gameState: GameState,
  mapProgress: MapProgressState,
  chapters: MapChapterDef[],
): BattleTransition => {
  const sessionRaw = gameState.battle.activeSession;
  if (!sessionRaw) {
    return {
      nextGameState: gameState,
      nextMapProgress: mapProgress,
      logs: [],
      error: 'No active battle session',
    };
  }

  const session = normalizeSessionWaves(sessionRaw);

  const nextSession: BattleSession = {
    ...session,
    status: 'defeat',
    phase: 'finished',
    logs: [...session.logs, toBattleLog('You retreated from battle.')],
  };

  return resolveBattleResult(
    {
      ...gameState,
      battle: {
        ...gameState.battle,
        activeSession: nextSession,
      },
    },
    mapProgress,
    chapters,
    nextSession,
    false,
  );
};


===================== [D:\download\LootingRPG\src\domains\battle\battleMaths.ts] =====================
// battleMath.ts

export const clamp = (v: number, min: number, max: number) =>
  Math.max(min, Math.min(max, v));

/**
 * 鏀婚槻姣斾激瀹虫ā鍨嬶紙闃茬垎鐐革級
 * damage = A虏 / (A + D)
 */
export const computeDamage = (
  attack: number,
  defense: number,
  critMultiplier: number,
  flatBonus: number = 0,
): number => {
  const effectiveAttack = attack * critMultiplier + flatBonus;
  const safeDefense = Math.max(1, defense);

  const damage =
    (effectiveAttack * effectiveAttack) /
    (effectiveAttack + safeDefense);

  return Math.max(1, Math.floor(damage));
};

/**
 * 鏆村嚮浼ゅ閫掑噺
 */
export const computeCritMultiplier = (
  didCrit: boolean,
  critDamage: number,
): number => {
  if (!didCrit) return 1;

  const effectiveCritDamage =
    critDamage / (1 + critDamage * 0.6);

  return 1 + effectiveCritDamage;
};

/**
 * 鍏冪礌绌块€忥紙涓嶆槸鍔犱激锛?
 */
export const computeEffectiveDefense = (
  defense: number,
  elementalPenetration: number,
): number => {
  const pen = clamp(elementalPenetration, 0, 0.6);
  return defense * (1 - pen);
};

/**
 * 鍚歌閫掑噺
 */
export const computeEffectiveLifesteal = (rate: number): number => {
  return rate / (1 + rate);
};


===================== [D:\download\LootingRPG\src\domains\battle\UnitFactory.ts] =====================
// UnitFactory.ts
// 璐熻矗鍒涘缓鎴樻枟鍗曚綅瀹炰緥鐨勫伐鍘傚嚱鏁?
// 閫氳繃浼犲叆鍗曚綅鐨勫熀纭€鏁版嵁鍜岀瓑绾э紝鐢熸垚涓€涓畬鏁寸殑鎴樻枟鍗曚綅瀵硅薄
// 鎴樻枟灞備笉瑕佸啀鐩存帴璇诲彇 monster JSON
// 蹇呴』閫氳繃 UnitFactory 鐢熸垚鎴樻枟鍗曚綅
import { BattleUnitSchema } from '@src/types/battle/BattleUnit'
import type { BattleUnitInstance } from '@src/types/battle/BattleUnit'
export function createBattleUnit(
  data: BattleUnitSchema,
  level: number
): BattleUnitInstance {
  return {
    id: data.id,
    name: data.name,
    faction: data.faction,
    level,
    baseStats: { ...data.baseStats },
    currentHp: data.baseStats.hp,
    derivedStats: {
      damageReduction: data.derivedStats?.damageReduction ?? 0,
      critRate: data.derivedStats?.critRate,
      lifestealRate: data.derivedStats?.lifestealRate,
      thornsRate: data.derivedStats?.thornsRate,
      elementalBonus: data.derivedStats?.elementalBonus,
    },
    skills: [...data.skills],
    passives: data.passives ?? [],
    elements: data.elements ?? [],
    tags: data.tags ?? [],
    meta: {
      ...(data.meta ?? {}),
      aiProfile: data.aiProfile ?? 'default',
    },
  }
}


===================== [D:\download\LootingRPG\src\domains\game\config\progression.ts] =====================
/**
 * @deprecated 杩佺Щ杩囨浮灞傦細褰撳墠浠嶇敱 `src/config/game/progression.ts` 浣滀负绋冲畾鏉ユ簮銆? */
export * from '../../../config/game/progression';


===================== [D:\download\LootingRPG\src\domains\inventory\services\actions.ts] =====================
import type { Equipment, GameState } from '../../../shared/types/game';
import { QUALITY_CONFIG, LOCK_COST, REROLL_BASE_COST } from '../../../config/game/equipment';
import { attemptEnhancement } from './enhancement';
import { rerollAffixes } from './equipment';
import i18n from '../../../i18n';

export type InventoryAction =
  | { type: 'equip'; itemId: string }
  | { type: 'sell'; itemId: string }
  | { type: 'enchant'; itemId: string }
  | { type: 'unequip_slot'; slot: string }
  | { type: 'reroll'; itemId: string; lockTypes?: string[] };

export interface InventoryActionResult {
  nextState: GameState;
  logs: string[];
}

const findItemById = (state: GameState, itemId: string): Equipment | undefined => {
  return (
    state.backpack.find((item) => item.id === itemId) ??
    (Object.values(state.currentEquipment) as Array<Equipment | null>).find((item) => item?.id === itemId) ??
    undefined
  );
};

export const applyInventoryAction = (state: GameState, action: InventoryAction): InventoryActionResult => {
  const nextState = structuredClone(state);
  const logs: string[] = [];

  const logSystemMessage = (message: string) => {
    nextState.systemMessage = message;
    logs.push(message);
  };

  if (action.type === 'equip') {
    const item = nextState.backpack.find((entry) => entry.id === action.itemId);
    if (!item) return { nextState, logs };

    const slotKey = item.slot;
    const oldItem = nextState.currentEquipment[slotKey];

    item.equipped = true;
    nextState.currentEquipment[slotKey] = item;
    nextState.backpack = nextState.backpack.filter((entry) => entry.id !== item.id && !entry.equipped);

    if (oldItem) {
      oldItem.equipped = false;
      nextState.backpack = [...nextState.backpack, oldItem];
    }

    logSystemMessage(i18n.t('message.equipped', { name: item.name }));
    return { nextState, logs };
  }

  if (action.type === 'unequip_slot') {
    const item = nextState.currentEquipment[action.slot];
    if (!item) return { nextState, logs };

    item.equipped = false;
    nextState.currentEquipment[action.slot] = null;
    nextState.backpack = [...nextState.backpack.filter((entry) => entry.id !== item.id), item];

    logSystemMessage(i18n.t('message.unequipped', { name: item.name }));
    return { nextState, logs };
  }

  if (action.type === 'sell') {
    const itemIndex = nextState.backpack.findIndex((entry) => entry.id === action.itemId);
    if (itemIndex < 0) return { nextState, logs };

    const item = nextState.backpack[itemIndex];
    const price = QUALITY_CONFIG[item.quality]?.price ?? 0;
    nextState.playerStats.gold += price;
    nextState.backpack.splice(itemIndex, 1);

    logSystemMessage(i18n.t('message.sold_item', { name: item.name, price }));
    return { nextState, logs };
  }

  if (action.type === 'enchant') {
    logs.push(...attemptEnhancement(nextState, action.itemId));
    return { nextState, logs };
  }

  if (action.type === 'reroll') {
    const item = findItemById(nextState, action.itemId);
    if (!item) return { nextState, logs };

    const lockTypes = action.lockTypes ?? [];
    const cost = REROLL_BASE_COST * ((item.enhancementLevel || 0) + 1) + lockTypes.length * LOCK_COST;

    if (nextState.playerStats.gold < cost) {
      logs.push(i18n.t('message.not_enough_gold_reroll'));
      return { nextState, logs };
    }

    nextState.playerStats.gold -= cost;
    const previous = item.affixes.length;
    rerollAffixes(item, { lockTypes });
    const rerolledCount = Math.max(0, previous - lockTypes.length);

    logSystemMessage(
      i18n.t('message.reroll_complete', {
        name: item.name,
        count: rerolledCount,
      }),
    );

    return { nextState, logs };
  }

  return { nextState, logs };
};


===================== [D:\download\LootingRPG\src\domains\inventory\services\autoSell.ts] =====================
import { QUALITIES } from '../../../config/game/equipment';

export const createAutoSellQualityMap = (): Record<string, boolean> => {
  return QUALITIES.reduce((acc, quality) => {
    acc[quality] = false;
    return acc;
  }, {} as Record<string, boolean>);
};


===================== [D:\download\LootingRPG\src\domains\inventory\services\enhancement.ts] =====================
import { calculateEnchantCost, applyEnchant } from './equipment';
import i18n from '../../../i18n';
import type { Equipment, GameState } from '../../../shared/types/game';

/**
 * 寮哄寲鍑芥暟: 灏濊瘯寮哄寲鎸囧畾鐨勮澶囷紝杩斿洖鏃ュ織淇℃伅
 */
export function attemptEnhancement(state: GameState, target: string): string[] {
  const logs: string[] = [];
  const logSystemMessage = (message: string) => {
    state.systemMessage = message;
    logs.push(message);
  };

  const item =
    state.backpack.find((i) => i.id === target) ||
    (Object.values(state.currentEquipment) as (Equipment | null)[]).find((i) => i?.id === target);

  if (item) {
    if ((item.enhancementLevel || 0) >= 20) {
      logs.push(i18n.t('message.enchant_maxed'));
      return logs;
    }

    const cost = calculateEnchantCost(item);
    if (state.playerStats.gold >= cost) {
      state.playerStats.gold -= cost;
      const lv = item.enhancementLevel || 0;
      const success = calculateEnhancementSuccess(lv);
      if (success) {
        applyEnchant(item);
        logSystemMessage(
          i18n.t('message.enchant_success', {
            name: item.name,
            level: item.enhancementLevel,
          }),
        );
      } else {
        logSystemMessage(i18n.t('message.enchant_fail'));
      }
    } else {
      logs.push(i18n.t('message.not_enough_gold_enchant'));
    }
  }

  return logs;
}

export function calculateEnhancementSuccess(lv: number): boolean {
  if (lv < 5) return true;
  if (lv < 10) return Math.random() < 0.6;
  if (lv < 15) return Math.random() < 0.3;
  if (lv < 20) return Math.random() < 0.1;
  return false;
}


===================== [D:\download\LootingRPG\src\domains\inventory\services\equipment.ts] =====================
import {
  QUALITIES,
  AFFIX_SCALING,
  AFFIX_COUNT_BY_QUALITY,
  ENCHANT_BASE_COST,
  ENCHANT_SCALE_BY_QUALITY,
  ENCHANT_COST_MULTIPLIER_BY_QUALITY,
} from '../../../config/game/equipment';
import { getEquipmentTemplates, type EquipmentTemplate } from '../../../config/game/equipment';
import type { Equipment, EquipmentAffix, EquipmentAffixValue } from '../../../shared/types/game';
import i18next from 'i18next';

const AFFIX_POOL: EquipmentAffix[] = ['crit_chance', 'lifesteal', 'damage_bonus', 'thorns', 'hp_bonus'];

const createAffix = (type: EquipmentAffix, qualityIndex: number): EquipmentAffixValue => {
  const idx = Math.min(Math.max(0, qualityIndex), QUALITIES.length - 1);
  const scaling = (AFFIX_SCALING as Record<string, number[]>)[type] ?? [];
  const value = scaling[idx] ?? 0;
  return { type, value };
};

const getLocaleKey = (): 'zh' | 'en' =>
  (i18next.language || 'zh').toLowerCase().startsWith('zh') ? 'zh' : 'en';

const inferMainStat = (attributes: Record<string, number>, slot: string): string => {
  const preferredBySlot = slot === 'weapon' ? 'attack' : slot === 'armor' || slot === 'helmet' ? 'hp' : 'defense';
  if (attributes[preferredBySlot] !== undefined) {
    return preferredBySlot;
  }

  const ranked = Object.entries(attributes).sort((a, b) => b[1] - a[1]);
  return ranked[0]?.[0] || preferredBySlot;
};

const pickRandom = <T,>(list: T[]): T => list[Math.floor(Math.random() * list.length)];

const buildFromTemplate = (template: EquipmentTemplate, playerLevel: number): Equipment => {
  const localeKey = getLocaleKey();
  const level = playerLevel + template.levelOffset;
  const scale = level * template.scalePerLevel;

  const attributes = Object.fromEntries(
    Object.entries(template.attributes).map(([key, value]) => [key, Math.round(value * scale)]),
  );

  const affixes = template.affixes.map((entry) => ({
    type: entry.type as EquipmentAffix,
    value: Math.round(entry.value * scale),
  }));

  const name = localeKey === 'zh' ? template.nameZh : template.nameEn;
  const special = localeKey === 'zh' ? template.specialZh : template.specialEn;

  return {
    id: `${template.id}_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 7)}`,
    icon: template.icon,
    level,
    name,
    quality: template.quality,
    slot: template.slot,
    attributes,
    affixes,
    enhancementLevel: 0,
    mainStat: inferMainStat(attributes, template.slot),
    equipped: false,
    special,
    localeNames: {
      zh: template.nameZh,
      en: template.nameEn,
    },
  };
};

const normalizePity = (pity: { legendary: number; mythic: number }): { legendary: number; mythic: number } => ({
  legendary: Number(pity.legendary ?? 0),
  mythic: Number(pity.mythic ?? 0),
});

const pickTemplateOrThrow = (templates: EquipmentTemplate[]): EquipmentTemplate => {
  const selected = selectTemplate(templates);
  if (selected) return selected;

  if (templates.length === 0) {
    throw new Error('UniqueEquipments.csv has no valid rows.');
  }
  return pickRandom(templates);
};

const selectTemplate = (templates: EquipmentTemplate[]): EquipmentTemplate | null => {
  const eligible = templates;
  if (eligible.length === 0) return null;
  return pickRandom(eligible);
};

const pickFromDropDict = (
  templates: EquipmentTemplate[],
  dropdict?: Record<string, number>,
): EquipmentTemplate | null => {
  if (!dropdict) return null;

  const templateById = new Map(templates.map((template) => [template.id, template]));
  const candidates = Object.entries(dropdict)
    .map(([id, chance]) => ({ id, chance: Number(chance), template: templateById.get(id) }))
    .filter((entry) => entry.template && Number.isFinite(entry.chance) && entry.chance > 0) as Array<{
    id: string;
    chance: number;
    template: EquipmentTemplate;
  }>;

  if (candidates.length === 0) return null;

  const total = candidates.reduce((sum, entry) => sum + entry.chance, 0);
  let roll = Math.random() * total;

  for (const entry of candidates) {
    roll -= entry.chance;
    if (roll <= 0) return entry.template;
  }

  return candidates[candidates.length - 1].template;
};

export const calculateEnchantCost = (item: Equipment): number => {
  const qIdx = Math.max(0, QUALITIES.indexOf(item.quality));
  const base = ENCHANT_BASE_COST;
  const mult = ENCHANT_COST_MULTIPLIER_BY_QUALITY[qIdx] ?? 1;
  return Math.max(0, Math.floor(base * (item.enhancementLevel + 1) * mult));
};

export const previewEnchant = (item: Equipment, times = 1): Equipment => {
  const copy: Equipment = structuredClone(item);
  const qIdx = Math.max(0, QUALITIES.indexOf(copy.quality));
  const scale = ENCHANT_SCALE_BY_QUALITY[qIdx] ?? 0.05;
  for (let i = 0; i < times; i++) {
    copy.enhancementLevel = (copy.enhancementLevel || 0) + 1;
    Object.entries(copy.attributes).forEach(([k, v]) => {
      copy.attributes[k] = Math.max(0, Math.round((v as number) * (1 + scale)));
    });
    if (Array.isArray(copy.affixes)) {
      copy.affixes = copy.affixes.map((a) => ({
        type: a.type,
        value: Math.max(0, Math.round(a.value * (1 + scale))),
      }));
    }
  }
  return copy;
};

export const applyEnchant = (item: Equipment): Equipment => {
  const qIdx = Math.max(0, QUALITIES.indexOf(item.quality));
  const scale = ENCHANT_SCALE_BY_QUALITY[qIdx] ?? 0.05;
  item.enhancementLevel = (item.enhancementLevel || 0) + 1;
  Object.entries(item.attributes).forEach(([k, v]) => {
    item.attributes[k] = Math.max(0, Math.round((v as number) * (1 + scale)));
  });
  if (Array.isArray(item.affixes)) {
    item.affixes = item.affixes.map((a) => ({
      type: a.type,
      value: Math.max(0, Math.round(a.value * (1 + scale))),
    }));
  }
  return item;
};

export const rerollAffixes = (item: Equipment, options?: { lockTypes?: string[] }): Equipment => {
  const qIdx = Math.max(0, QUALITIES.indexOf(item.quality));
  const lockTypes = options?.lockTypes ?? [];
  const existing = Array.isArray(item.affixes) ? item.affixes.slice() : [];
  const kept = existing.filter((a) => lockTypes.includes(a.type));
  const needed = Math.max(0, (AFFIX_COUNT_BY_QUALITY[qIdx] ?? 0) - kept.length);
  const pool = AFFIX_POOL.filter((p) => !lockTypes.includes(p));
  const newAffixes: EquipmentAffixValue[] = [];
  for (let i = 0; i < needed && pool.length > 0; i++) {
    const idx = Math.floor(Math.random() * pool.length);
    const type = pool.splice(idx, 1)[0];
    newAffixes.push(createAffix(type as EquipmentAffix, qIdx));
  }
  item.affixes = [...kept, ...newAffixes];
  return item;
};

export const generateEquipment = (
  monster: { monsterType?: 'normal' | 'elite' | 'boss'; dropdict?: Record<string, number> },
  pity: { legendary: number; mythic: number },
  playerLevel: number,
): { item: Equipment; newPity: { legendary: number; mythic: number } } => {
  const newPity = normalizePity(pity);
  newPity.legendary += 1;
  newPity.mythic += 1;

  const templates = getEquipmentTemplates();
  const selected = pickFromDropDict(templates, monster.dropdict) ?? pickTemplateOrThrow(templates);

  return {
    item: buildFromTemplate(selected, playerLevel),
    newPity,
  };
};

export const createCustomEquipment = (quality: string, slot: string, playerLevel = 1): Equipment => {
  const templates = getEquipmentTemplates().filter((template) => {
    if (template.slot !== slot) return false;
    if (template.quality !== quality) return false;
    return true;
  });

  const allTemplates = getEquipmentTemplates();
  const selected = templates.length > 0 ? pickRandom(templates) : pickTemplateOrThrow(allTemplates);

  return buildFromTemplate(selected, playerLevel);
};


===================== [D:\download\LootingRPG\src\domains\inventory\services\equipmentTotals.ts] =====================
import type { Equipment, EquipmentAffixValue } from '../../../shared/types/game';

export interface EquipmentTotals {
  attributes: Record<string, number>;
  affixes: Record<string, number>;
}

export function getEquipmentTotals(equips: Record<string, Equipment | null>): EquipmentTotals {
  const attributes: Record<string, number> = {};
  const affixes: Record<string, number> = {};

  Object.values(equips).forEach((item) => {
    if (!item) return;
    Object.entries(item.attributes).forEach(([key, value]) => {
      const num = typeof value === 'number' ? value : Number(value) || 0;
      attributes[key] = (attributes[key] || 0) + num;
    });

    item.affixes.forEach((a: EquipmentAffixValue) => {
      affixes[a.type] = (affixes[a.type] || 0) + a.value;
    });
  });

  return { attributes, affixes };
}


===================== [D:\download\LootingRPG\src\domains\inventory\services\quickSell.ts] =====================
import { QUALITIES, QUALITY_CONFIG } from '../../../config/game/equipment';
import type { Equipment, GameState } from '../../../shared/types/game';
import { t } from 'i18next';

const getQualityLabel = (qualityKey: string): string => t(`quality.${qualityKey}`);

export const quickSellByQualityRange = (
  state: GameState,
  minQuality: string,
  maxQuality: string,
): { nextState: GameState; message: string } => {
  const minIndex = QUALITIES.indexOf(minQuality);
  const maxIndex = QUALITIES.indexOf(maxQuality);

  if (minIndex < 0 || maxIndex < 0) {
    return {
      nextState: state,
      message: t('message.invalid_quality_range'),
    };
  }

  const lower = Math.min(minIndex, maxIndex);
  const upper = Math.max(minIndex, maxIndex);

  const nextState = structuredClone(state);
  const keep: Equipment[] = [];
  let soldCount = 0;
  let earnedGold = 0;

  nextState.backpack.forEach((item) => {
    const qualityIndex = QUALITIES.indexOf(item.quality);
    const inRange = qualityIndex >= lower && qualityIndex <= upper;

    if (inRange) {
      soldCount += 1;
      earnedGold += QUALITY_CONFIG[item.quality].price;
    } else {
      keep.push(item);
    }
  });

  if (soldCount === 0) {
    const message = t('message.no_items_in_range', {
      min: getQualityLabel(QUALITIES[lower]),
      max: getQualityLabel(QUALITIES[upper]),
    });
    nextState.systemMessage = message;
    return { nextState, message };
  }

  nextState.backpack = keep;
  nextState.playerStats.gold += earnedGold;
  const message = t('message.quick_sell_result', {
    min: getQualityLabel(QUALITIES[lower]),
    max: getQualityLabel(QUALITIES[upper]),
    count: soldCount,
    gold: earnedGold,
  });
  nextState.systemMessage = message;
  return { nextState, message };
};


===================== [D:\download\LootingRPG\src\domains\map\model\chapters.ts] =====================
import chapterData from '@data/config/map/ChapterData.json';
import { MapEncounterType, ChapterTheme } from '../../../config/map/mapNode';

interface RawNodeWave {
  id: string;
  label?: string;
  monsters: { monsterId: string }[];
}

interface RawMapNode {
  id: string;
  name: string;
  recommendedLevel: number;
  encounterType: string;
  firstClearRewardGold: number;
  waves?: RawNodeWave[];
}

interface RawMapChapter {
  id: string;
  name: string;
  levelRange: string;
  theme: string;
  nodes: RawMapNode[];
}

export interface NodeWave {
  id: string;
  label?: string;
  monsters: { monsterId: string }[];
}

export interface MapNodeDef {
  id: string;
  name: string;
  recommendedLevel: number;
  encounterType: MapEncounterType;
  firstClearRewardGold: number;
  waves?: NodeWave[];
}

export interface MapChapterDef {
  id: string;
  name: string;
  levelRange: string;
  theme: ChapterTheme;
  nodes: MapNodeDef[];
}

const rawChapters = chapterData.MAP_CHAPTERS as RawMapChapter[];

export const MAP_CHAPTERS: MapChapterDef[] = rawChapters.map((chapter) => ({
  ...chapter,
  theme: chapter.theme as ChapterTheme,
  nodes: chapter.nodes.map((node) => ({
    ...node,
    encounterType: node.encounterType as MapEncounterType,
  })),
}));


===================== [D:\download\LootingRPG\src\domains\map\services\nodeLookup.ts] =====================
import type { MapNodeDef } from '../model/chapters';
import { MAP_CHAPTERS } from '../model/chapters';

export const getMapNodeById = (nodeId: string): MapNodeDef | undefined => {
  for (const chapter of MAP_CHAPTERS) {
    const found = chapter.nodes.find((node) => node.id === nodeId);
    if (found) return found;
  }
  return undefined;
};


===================== [D:\download\LootingRPG\src\domains\map\services\progress.ts] =====================
import type { MapChapterDef } from '../model/chapters';
import type { MapProgressState } from '../../../shared/types/game';

export const createInitialMapProgress = (chapters: MapChapterDef[]): MapProgressState => {
  const firstChapter = chapters[0];
  const firstNode = firstChapter?.nodes[0];

  return {
    selectedChapterId: firstChapter?.id ?? 'chapter-1',
    unlockedChapters: firstChapter ? [firstChapter.id] : [],
    unlockedNodes: firstNode ? [firstNode.id] : [],
    clearedNodes: [],
    failedAttempts: {},
  };
};

export const normalizeMapProgress = (
  progress: MapProgressState | undefined,
  chapters: MapChapterDef[],
): MapProgressState => {
  const base = createInitialMapProgress(chapters);
  if (!progress) return base;

  const chapterIds = new Set(chapters.map((chapter) => chapter.id));
  const nodeIds = new Set(chapters.flatMap((chapter) => chapter.nodes.map((node) => node.id)));

  const unlockedChapters = Array.from(new Set(progress.unlockedChapters ?? [])).filter((id) => chapterIds.has(id));
  if (base.unlockedChapters.length > 0 && unlockedChapters.length === 0) {
    unlockedChapters.push(base.unlockedChapters[0]);
  }

  const unlockedNodes = Array.from(new Set(progress.unlockedNodes ?? [])).filter((id) => nodeIds.has(id));
  base.unlockedNodes.forEach((id) => {
    if (!unlockedNodes.includes(id)) unlockedNodes.push(id);
  });

  const clearedNodes = Array.from(new Set(progress.clearedNodes ?? [])).filter((id) => nodeIds.has(id));

  const failedAttempts: Record<string, number> = {};
  Object.entries(progress.failedAttempts ?? {}).forEach(([nodeId, attempts]) => {
    if (!nodeIds.has(nodeId)) return;
    failedAttempts[nodeId] = Math.max(0, Number(attempts) || 0);
  });

  const selectedChapterId = chapterIds.has(progress.selectedChapterId)
    ? progress.selectedChapterId
    : (unlockedChapters[0] ?? base.selectedChapterId);

  return {
    selectedChapterId,
    unlockedChapters,
    unlockedNodes,
    clearedNodes,
    failedAttempts,
  };
};

export const isChapterUnlocked = (progress: MapProgressState, chapterId: string) =>
  progress.unlockedChapters.includes(chapterId);

export const getNextNode = (chapter: MapChapterDef, nodeId: string) => {
  const idx = chapter.nodes.findIndex((n) => n.id === nodeId);
  if (idx < 0 || idx + 1 >= chapter.nodes.length) return undefined;
  return chapter.nodes[idx + 1];
};

export const getNextChapter = (chapters: MapChapterDef[], chapterId: string) => {
  const idx = chapters.findIndex((c) => c.id === chapterId);
  if (idx < 0 || idx + 1 >= chapters.length) return undefined;
  return chapters[idx + 1];
};

export const isNodeUnlocked = (progress: MapProgressState, nodeId: string) =>
  progress.unlockedNodes.includes(nodeId);

export const isNodeCleared = (progress: MapProgressState, nodeId: string) =>
  progress.clearedNodes.includes(nodeId);

export const getNodeAttempts = (progress: MapProgressState, nodeId: string) =>
  progress.failedAttempts[nodeId] ?? 0;

export const getChapterProgress = (
  progress: MapProgressState,
  chapter: MapChapterDef,
): { cleared: number; total: number; completed: boolean } => {
  const total = chapter.nodes.length;
  const cleared = chapter.nodes.reduce((acc, node) => acc + (isNodeCleared(progress, node.id) ? 1 : 0), 0);
  return {
    cleared,
    total,
    completed: total > 0 && cleared === total,
  };
};

interface ApplyNodeResultInput {
  progress: MapProgressState;
  chapters: MapChapterDef[];
  chapterId: string;
  nodeId: string;
  won: boolean;
}

export interface ApplyNodeResultOutput {
  nextProgress: MapProgressState;
  firstClear: boolean;
  unlockedNodeId?: string;
  unlockedChapterId?: string;
  chapterCompleted: boolean;
}

export const applyMapNodeResult = ({ progress, chapters, chapterId, nodeId, won }: ApplyNodeResultInput): ApplyNodeResultOutput => {
  const nextProgress = normalizeMapProgress(progress, chapters);

  if (!won) {
    nextProgress.failedAttempts[nodeId] = (nextProgress.failedAttempts[nodeId] ?? 0) + 1;
    return {
      nextProgress,
      firstClear: false,
      chapterCompleted: false,
    };
  }

  const firstClear = !nextProgress.clearedNodes.includes(nodeId);
  if (firstClear) {
    nextProgress.clearedNodes.push(nodeId);
  }

  if (!nextProgress.unlockedNodes.includes(nodeId)) {
    nextProgress.unlockedNodes.push(nodeId);
  }

  if (nextProgress.failedAttempts[nodeId]) {
    delete nextProgress.failedAttempts[nodeId];
  }

  const chapter = chapters.find((c) => c.id === chapterId);
  let unlockedNodeId: string | undefined;
  let unlockedChapterId: string | undefined;

  if (chapter) {
    const nextNode = getNextNode(chapter, nodeId);
    if (nextNode && !nextProgress.unlockedNodes.includes(nextNode.id)) {
      nextProgress.unlockedNodes.push(nextNode.id);
      unlockedNodeId = nextNode.id;
    }

    const chapterCompleted = chapter.nodes.every((node) => nextProgress.clearedNodes.includes(node.id));
    if (chapterCompleted) {
      const nextChapter = getNextChapter(chapters, chapterId);
      if (nextChapter && !nextProgress.unlockedChapters.includes(nextChapter.id)) {
        nextProgress.unlockedChapters.push(nextChapter.id);
        unlockedChapterId = nextChapter.id;
        const first = nextNode ? undefined : nextChapter.nodes[0];
        if (first && !nextProgress.unlockedNodes.includes(first.id)) {
          nextProgress.unlockedNodes.push(first.id);
          if (!unlockedNodeId) {
            unlockedNodeId = first.id;
          }
        }
      }
    }

    return {
      nextProgress,
      firstClear,
      unlockedNodeId,
      unlockedChapterId,
      chapterCompleted,
    };
  }

  return {
    nextProgress,
    firstClear,
    unlockedNodeId,
    unlockedChapterId,
    chapterCompleted: false,
  };
};


===================== [D:\download\LootingRPG\src\domains\monster\services\monsterCatalog.ts] =====================
import type { Monster } from '../../../shared/types/game';
import { BOSS_MONSTERS_DATA, NORMAL_MONSTERS_DATA } from '../config';
import i18n from '../../../i18n';

export const attachMonsterLore = (monster: Monster): Monster => {
  const backgroundKey = monster.background;
  const background = backgroundKey ? i18n.t(backgroundKey) : i18n.t('codex.backgroundFallback');
  const rawBoss = monster.monsterType === 'boss' ? monster.bossIdentity : undefined;
  const rawBossRecord = rawBoss as unknown as Record<string, unknown> | undefined;
  const introLineKey = typeof rawBossRecord?.introLineKey === 'string' ? rawBossRecord.introLineKey : undefined;
  const battleLogLineKey = typeof rawBossRecord?.battleLogLineKey === 'string' ? rawBossRecord.battleLogLineKey : undefined;
  const bossIdentity = rawBoss
    ? {
        ...rawBoss,
        introLine: i18n.t(introLineKey || rawBoss.introLine || ''),
        battleLogLine: i18n.t(battleLogLineKey || rawBoss.battleLogLine || ''),
        phasePrompts: {
          entering: rawBoss.phasePrompts?.entering ? i18n.t(rawBoss.phasePrompts.entering) : '',
          fighting: rawBoss.phasePrompts?.fighting ? i18n.t(rawBoss.phasePrompts.fighting) : '',
          dying: rawBoss.phasePrompts?.dying ? i18n.t(rawBoss.phasePrompts.dying) : '',
          dropping: rawBoss.phasePrompts?.dropping ? i18n.t(rawBoss.phasePrompts.dropping) : '',
        },
      }
    : undefined;

  return { ...monster, background, bossIdentity };
};

export const NORMAL_MONSTERS: Monster[] = NORMAL_MONSTERS_DATA.map((monster) => attachMonsterLore(monster));
export const BOSS_MONSTERS: Monster[] = BOSS_MONSTERS_DATA.map((monster) => attachMonsterLore(monster));


===================== [D:\download\LootingRPG\src\domains\monster\config.ts] =====================
import type { Monster, MonsterScalingProfile, MonsterTrait } from '../../shared/types/game';
import { type RawMonsterData, type RawBossData } from '../../config/game/monsterSchema';
import { getMapMonsterBaselineByLevel, resolveMonsterTemplateStats } from '../battle/services/monsterScaling';
import monsterConfig from '@data/config/game/monsters.json';
import { t } from 'i18next';

const { normal: rawNormal, boss: rawBoss } = monsterConfig;
const isBossData = (m: RawMonsterData | RawBossData): m is RawBossData => {
  return 'counterGoal' in m || 'bossIdentity' in m;
};

const localizeAdditionalFields = (
  monster: RawMonsterData | RawBossData,
): RawMonsterData | RawBossData => {
  const result = { ...monster } as typeof monster;
  if (isBossData(monster) && monster.counterGoal) {
    (result as RawBossData).counterGoal = {
      ...monster.counterGoal,
      title: monster.counterGoal.titleKey ? t(monster.counterGoal.titleKey) : monster.counterGoal.title,
      successText: monster.counterGoal.successTextKey
        ? t(monster.counterGoal.successTextKey)
        : t(monster.counterGoal.successText || ''),
      failText: monster.counterGoal.failTextKey
        ? t(monster.counterGoal.failTextKey)
        : t(monster.counterGoal.failText || ''),
    } as RawBossData['counterGoal'];
  }

  if (isBossData(monster) && monster.bossIdentity) {
    (result as RawBossData).bossIdentity = {
      ...monster.bossIdentity,
      introLine: monster.bossIdentity.introLineKey
        ? t(monster.bossIdentity.introLineKey)
        : monster.bossIdentity.introLine,
      battleLogLine: monster.bossIdentity.battleLogLineKey
        ? t(monster.bossIdentity.battleLogLineKey)
        : monster.bossIdentity.battleLogLine,
    } as RawBossData['bossIdentity'];
  }

  return result;
};

const TRAIT_TO_SKILL: Record<string, string> = {
  lifesteal: 'lifeSteal',
  double_attack: 'doubleStrike',
  thorns: 'thornAura',
  shield_on_start: 'shieldStart',
  rage_on_low_hp: 'rageMode',
};

const normalizeSkillSet = (
  monster: RawMonsterData | RawBossData,
): string[] => {
  if (Array.isArray(monster.skillSet)) return monster.skillSet;
  const traits: MonsterTrait[] = Array.isArray(monster.traits) ? monster.traits : [];
  const skills = traits.map((trait) => TRAIT_TO_SKILL[trait]).filter(Boolean);
  return Array.from(new Set(skills));
};

const toMonster = (monster: RawMonsterData | RawBossData): Monster => {
  const icons = [monster.icon as string];
  const monsterType = monster.monsterType;
  const baseStats = {
    hp:      Number(monster.baseStats?.hp),
    attack:  Number(monster.baseStats?.attack),
    defense: Number(monster.baseStats?.defense),
  };
  const scalingProfile = monster.scalingProfile as MonsterScalingProfile;
  const previewStats = resolveMonsterTemplateStats(
    { baseStats, scalingProfile },
    getMapMonsterBaselineByLevel(1),
  );
  return {
    ...(localizeAdditionalFields(monster) as Monster),
    icons,
    level: 1,
    monsterType,
    baseStats,
    scalingProfile,
    skillSet: normalizeSkillSet(monster),
    maxHp:   previewStats.maxHp,
    attack:  previewStats.attack,
    defense: previewStats.defense,
    name: t(`monster.${monster.id}`, { defaultValue: monster.id ?? 'unknown_monster' }),
    dropdict: Object.fromEntries( Object.entries(monster.dropdict ?? {})
      .map(([id, chance]) => [id, chance]))
  } as Monster;
};

export const NORMAL_MONSTERS_DATA: Monster[] = rawNormal.map(toMonster);
export const BOSS_MONSTERS_DATA:   Monster[] = rawBoss.map(toMonster);
const ALL_MONSTERS_DATA: Monster[] = [...NORMAL_MONSTERS_DATA, ...BOSS_MONSTERS_DATA];

export const getMonsterById = (id: string): Monster | undefined => {
  return ALL_MONSTERS_DATA.find((monster) => monster.id === id);
};


===================== [D:\download\LootingRPG\src\domains\player\model\combat.ts] =====================
import type { PlayerStats } from '../../../shared/types/game';

export interface CombatProfile {
  playerDamageMultiplier: number;
  monsterDamageMultiplier: number;
  statusProcMultiplier: number;
  turnBonus: number;
  bossSkillInterval: number;
}

export interface FinalPlayerCombatStats {
  maxHp: number;
  attack: number;
  defense: number;
  damageReduction: number;
  critRate: number;
  elementalBonus: number;
  lifestealRate: number;
  thornsRate: number;
  speed: number;
}

const clamp = (value: number, min: number, max: number): number => Math.max(min, Math.min(max, value));

const toNumber = (value: unknown): number => {
  if (typeof value === 'number') return value;
  if (typeof value === 'string') {
    const parsed = Number(value.replace('%', '').trim());
    return Number.isFinite(parsed) ? parsed : 0;
  }
  return 0;
};

const toSoftCappedPercent = (
  rawPercent: number,
  softCapPercent: number,
  hardCapPercent: number,
  growthRate: number,
): number => {
  const normalized = clamp(rawPercent, 0, 100);
  if (normalized <= softCapPercent) return normalized;

  const overflow = normalized - softCapPercent;
  const scaled = 1 - Math.exp(-growthRate * overflow);
  const softened = softCapPercent + (hardCapPercent - softCapPercent) * scaled;
  return clamp(softened, 0, hardCapPercent);
};

const defenseToReductionRate = (
  defenseValue: number,
  hardCapRate: number,
  growthRate: number,
): number => {
  const normalized = clamp(defenseValue, 0, 100);
  const rate = 1 - Math.exp(-growthRate * normalized);
  return clamp(rate, 0, hardCapRate);
};

const DEFAULT_COMBAT_PROFILE: CombatProfile = {
  playerDamageMultiplier: 1,
  monsterDamageMultiplier: 1,
  statusProcMultiplier: 1,
  turnBonus: 0,
  bossSkillInterval: 3,
};

export const getCombatProfile = (): CombatProfile => DEFAULT_COMBAT_PROFILE;

export const getFinalPlayerStats = (
  source: PlayerStats,
  encounterCount: number,
): FinalPlayerCombatStats => {
  const combatProfile = DEFAULT_COMBAT_PROFILE;
  const rawCritPercent = toNumber(source.critRate);
  const rawLifestealPercent = toNumber(source.lifesteal);
  const rawThornsPercent = toNumber(source.thorns);
  const rawDefense = Math.floor(source.defense);
  const levelFactor = 1 + (source.level - 1) * 0.08;
  const encounterFactor = 1 + Math.min(0.65, encounterCount * 0.003);

  const critPercent = toSoftCappedPercent(rawCritPercent, 50, 75, 0.08);
  const lifestealPercent = toSoftCappedPercent(rawLifestealPercent, 30, 45, 0.12);
  const thornsPercent = toSoftCappedPercent(rawThornsPercent, 20, 35, 0.1);
  const damageReduction = defenseToReductionRate(rawDefense, 0.68, 0.01);

  return {
    maxHp: Math.floor(source.hp * levelFactor * encounterFactor),
    attack: Math.floor(source.attack * levelFactor * encounterFactor * combatProfile.playerDamageMultiplier),
    defense: Math.floor(rawDefense * levelFactor * encounterFactor),
    damageReduction,
    critRate: clamp(critPercent / 100, 0, 0.8),
    elementalBonus: toNumber(source.elemental),
    lifestealRate: clamp(lifestealPercent / 100, 0, 0.45),
    thornsRate: clamp(thornsPercent / 100, 0, 0.35),
    speed: toNumber(source.attackSpeed),
  };
};

export const calculateFinalPlayerStats = (
  source: PlayerStats,
  encounterCount: number,
) => getFinalPlayerStats(source, encounterCount);


===================== [D:\download\LootingRPG\src\domains\player\services\derivedStats.ts] =====================
import type { GameState } from '../../../shared/types/game';

export interface DerivedStatItem {
  key: string;
  label: string;
  value: string;
  rawValue: number;
  icon: React.ReactNode;
  accent: string;
}

export function getDerivedStats(gameState: GameState): Omit<DerivedStatItem, 'icon'>[] {
  const ps = gameState.playerStats;
  type DerivedSourceKey = 'damageBonus' | 'lifesteal' | 'thorns' | 'elemental' | 'attackSpeed';

  const statSpecs: Array<{
    en: DerivedSourceKey;
    key: string;
    accent: string;
    fmt: (v: number) => string;
  }> = [
    { en: 'damageBonus', key: 'dmg', accent: 'border-orange-400/35 bg-orange-500/10 text-orange-200', fmt: (v) => `${v}%` },
    { en: 'lifesteal', key: 'ls', accent: 'border-red-400/35 bg-red-500/10 text-red-200', fmt: (v) => `${v}%` },
    { en: 'thorns', key: 'thorns', accent: 'border-emerald-400/35 bg-emerald-500/10 text-emerald-200', fmt: (v) => `${v}%` },
    { en: 'elemental', key: 'element', accent: 'border-cyan-400/35 bg-cyan-500/10 text-cyan-200', fmt: (v) => `+${v}` },
    { en: 'attackSpeed', key: 'spd', accent: 'border-red-400/35 bg-red-500/10 text-red-200', fmt: (v) => `+${v}` },
  ];

  return statSpecs.map(({ en, key, accent, fmt }) => {
    const raw = ps[en];
    return { key, label: en, value: fmt(raw), rawValue: raw, accent };
  });
}


===================== [D:\download\LootingRPG\src\domains\player\services\recalculatePlayerStats.ts] =====================
import { INITIAL_STATE } from '../../../config/game/gameConfig';
import { PLAYER_GROWTH } from '../../../config/game/progression';
import type { GameState } from '../../../shared/types/game';
import { getEquipmentTotals } from '../../inventory/services/equipmentTotals';

export const recalculatePlayerStats = (state: GameState): GameState => {
  const next = structuredClone(state);
  const level = next.playerStats.level;
  const baseAttack = INITIAL_STATE.playerStats.attack + (level - 1) * PLAYER_GROWTH.attackPerLevel;
  const baseHp = INITIAL_STATE.playerStats.hp + (level - 1) * PLAYER_GROWTH.hpPerLevel;
  const baseDefense = INITIAL_STATE.playerStats.defense + (level - 1) * PLAYER_GROWTH.defensePerLevel;
  const baseCritRate = Number(PLAYER_GROWTH.baseCritRate);

  let attackBonus = 0;
  let hpBonus = 0;
  let defenseBonus = 0;
  let critBonus = 0;
  let damageBonusPercent = 0;
  let lifestealPercent = 0;
  let thornsPercent = 0;
  let elementalBonus = 0;
  let attackSpeedBonus = 0;

  const { attributes, affixes } = getEquipmentTotals(next.currentEquipment);
  attackBonus += attributes.attack || 0;
  hpBonus += attributes.hp || 0;
  defenseBonus += attributes.defense || 0;
  critBonus += attributes.crit || 0;
  elementalBonus += attributes.elemental || 0;
  attackSpeedBonus += attributes.attackSpeed || 0;
  lifestealPercent += attributes.lifesteal || 0;

  critBonus += affixes.crit_chance || 0;
  lifestealPercent += affixes.lifesteal || 0;
  damageBonusPercent += affixes.damage_bonus || 0;
  thornsPercent += affixes.thorns || 0;
  hpBonus += affixes.hp_bonus || 0;

  const crit = Math.max(0, Math.round((baseCritRate + critBonus) * 10) / 10);
  const attackBeforeMultiplier = baseAttack + attackBonus;
  const finalAttack = Math.floor(attackBeforeMultiplier * (1 + Math.max(0, damageBonusPercent) / 100));

  next.playerStats.attack = finalAttack;
  next.playerStats.hp = Math.floor(baseHp + hpBonus);
  next.playerStats.defense = Math.max(0, Math.floor(baseDefense + defenseBonus));
  next.playerStats.critRate = `${crit}`;
  next.playerStats.damageBonus = Math.max(0, Math.round(damageBonusPercent));
  next.playerStats.lifesteal = Math.max(0, Math.round(lifestealPercent));
  next.playerStats.thorns = Math.max(0, Math.round(thornsPercent));
  next.playerStats.elemental = Math.max(0, Math.round(elementalBonus));
  next.playerStats.attackSpeed = Math.max(0, Math.round(attackSpeedBonus));

  return next;
};


===================== [D:\download\LootingRPG\src\hooks\game\useAutoSell.ts] =====================
import { useState, useCallback } from 'react';
import { createAutoSellQualityMap } from '../../domains/inventory/services/autoSell';

/**
 * 鑷姩鍞崠鍝佽川鏄犲皠绠＄悊
 */
export function useAutoSell() {
  const [autoSellQualities, setAutoSellQualities] = useState<Record<string, boolean>>(createAutoSellQualityMap());

  const toggleQuality = useCallback((quality: string) => {
    setAutoSellQualities((prev) => ({ ...prev, [quality]: !prev[quality] }));
  }, []);

  return {
    autoSellQualities,
    toggleQuality,
    setAutoSellQualities,
  } as const;
}


===================== [D:\download\LootingRPG\src\hooks\game\useBattleSession.ts] =====================
import { useCallback } from 'react';
import { runBattlePlayerAttack, runBattleRetreat, startBattleSession } from '../../domains/battle/services/session';
import { MAP_CHAPTERS } from '../../config/map/ChapterData';
import type { GameState, MapProgressState } from '../../shared/types/game';
import type { ActiveTab } from '../../shared/types/game';

interface UseBattleSessionParams {
  gameState: GameState;
  mapProgress: MapProgressState;
  setGameState: React.Dispatch<React.SetStateAction<GameState>>;
  setMapProgress: React.Dispatch<React.SetStateAction<MapProgressState>>;
  addLog: (msg: string) => void;
  setActiveTab: React.Dispatch<React.SetStateAction<ActiveTab>>;
  setFocusMapNode: React.Dispatch<React.SetStateAction<string | null>>;
}

/**
 * 鎻愪緵鎴樻枟鐩稿叧鐨勫揩鎹峰鐞嗗嚱鏁帮紝灏?domain 鏈嶅姟杩斿洖鐨勭粨鏋滃簲鐢ㄥ洖 React 鐘舵€佸苟璁板綍鏃ュ織
 */
export function useBattleSession({
  gameState,
  mapProgress,
  setGameState,
  setMapProgress,
  addLog,
  setActiveTab,
  setFocusMapNode,
}: UseBattleSessionParams) {
  const handleBattleAttack = useCallback(() => {
    const result = runBattlePlayerAttack(gameState, mapProgress, MAP_CHAPTERS);
    setGameState(result.nextGameState);
    setMapProgress(result.nextMapProgress);
    if (result.focusNodeId) {
      setFocusMapNode(result.focusNodeId);
      setActiveTab('map');
    }
    result.logs.forEach(addLog);
  }, [gameState, mapProgress, addLog, setGameState, setMapProgress, setFocusMapNode, setActiveTab]);

  const handleBattleRetreat = useCallback(() => {
    const result = runBattleRetreat(gameState, mapProgress, MAP_CHAPTERS);
    setGameState(result.nextGameState);
    setMapProgress(result.nextMapProgress);
    setActiveTab('map');
    if (result.focusNodeId) {
      setFocusMapNode(result.focusNodeId);
    }
    result.logs.forEach(addLog);
  }, [gameState, mapProgress, addLog, setGameState, setMapProgress, setFocusMapNode, setActiveTab]);

  const handleEnterMapNode = useCallback(
    (
      node: Parameters<typeof startBattleSession>[2],
      chapter: Parameters<typeof startBattleSession>[1],
    ) => {
      const battle = startBattleSession(gameState, chapter, node);
      setGameState(battle.nextGameState);
      battle.logs.forEach(addLog);
    },
    [gameState, addLog, setGameState],
  );

  return {
    handleBattleAttack,
    handleBattleRetreat,
    handleEnterMapNode,
  } as const;
}


===================== [D:\download\LootingRPG\src\hooks\game\useDebug.ts] =====================
import { useCallback } from 'react';
import { createCustomEquipment } from '../../domains/inventory/services/equipment';
import type { Equipment, GameState } from '../../shared/types/game';

interface UseDebugParams {
  gameState: GameState;
  setGameState: React.Dispatch<React.SetStateAction<GameState>>;
  addLog: (msg: string) => void;
}

/**
 * 鎻愪緵璋冭瘯宸ュ叿锛堢洰鍓嶄粎鏄坊鍔犺嚜瀹氫箟瑁呭锛?
 */
export function useDebug({ gameState, setGameState, addLog }: UseDebugParams) {
  const handleDebugAddItems = useCallback(
    (quality: string, slot: string, count: number, level?: number) => {
      const items: Equipment[] = [];
      const lv = Math.floor(level ?? gameState.playerStats.level);

      for (let i = 0; i < count; i += 1) {
        items.push(createCustomEquipment(quality, slot, lv));
      }

      setGameState((prev) => ({ ...prev, backpack: [...prev.backpack, ...items] }));
      addLog(`[Debug] Added ${count} ${quality} ${slot} items (Lv.${lv}) to backpack`);
    },
    [gameState.playerStats.level, setGameState, addLog],
  );

  return { handleDebugAddItems } as const;
}


===================== [D:\download\LootingRPG\src\hooks\game\useGameLogger.ts] =====================
import { useState, useCallback } from 'react';

/**
 * 绠€鍗曠殑鏃ュ織绠＄悊 hook锛岃礋璐ｇ淮鎶ゆ秷鎭垪琛ㄥ拰娣诲姞鏂版棩蹇椼€?
 * 鐢卞悇涓笟鍔?hook/缁勪欢璋冪敤锛岀敤浜庡湪鐣岄潰涓婃樉绀鸿繍琛屾椂淇℃伅銆?
 */
export function useGameLogger(initialLogs: string[] = ['[System] Game started.']) {
  const [logs, setLogs] = useState<string[]>(initialLogs);

  const addLog = useCallback((msg: string) => {
    if (!msg) return;
    const time = new Date().toLocaleTimeString();
    setLogs((prev) => [...prev.slice(-99), `[${time}] ${msg}`]);
  }, []);

  return {
    logs,
    setLogs,
    addLog,
  } as const;
}


===================== [D:\download\LootingRPG\src\hooks\game\useInventoryActions.ts] =====================
import { useCallback } from 'react';
import type { GameState } from '../../shared/types/game';
import { quickSellByQualityRange as quickSellBackpackByRange } from '../../domains/inventory/services/quickSell';
import { applyInventoryAction, type InventoryAction } from '../../domains/inventory/services/actions';
import { recalculatePlayerStats } from '../../domains/player/services/recalculatePlayerStats';

interface UseInventoryActionsParams {
  gameState: GameState;
  loading: boolean;
  setGameState: React.Dispatch<React.SetStateAction<GameState>>;
  setLoading: (loading: boolean) => void;
  addLog: (msg: string) => void;
  reportError: (err: unknown, context?: { action?: string }) => void;
}

export const useInventoryActions = ({
  setGameState,
  setLoading,
  addLog,
  reportError,
}: UseInventoryActionsParams) => {
  const quickSellByQualityRange = useCallback((minQuality: string, maxQuality: string) => {
    setGameState((prev) => {
      const result = quickSellBackpackByRange(prev, minQuality, maxQuality);
      addLog(result.message);
      return recalculatePlayerStats(result.nextState);
    });
  }, [setGameState, addLog]);

  const processAction = useCallback((action: InventoryAction) => {
    setLoading(true);

    setTimeout(() => {
      try {
        setGameState((prev) => {
          try {
            const result = applyInventoryAction(prev, action);
            result.logs.forEach(addLog);
            return recalculatePlayerStats(result.nextState);
          } catch (error) {
            reportError(error, { action: action.type });
            return prev;
          }
        });
      } finally {
        setLoading(false);
      }
    });
  }, [setLoading, setGameState, addLog, reportError]);

  return {
    quickSellByQualityRange,
    processAction,
  };
};


===================== [D:\download\LootingRPG\src\hooks\game\useMapProgress.ts] =====================
import { useState } from 'react';
import type { ActiveTab, MapProgressState } from '../../shared/types/game';
import { createInitialMapProgress } from '../../domains/map/services/progress';
import { MAP_CHAPTERS } from '../../config/map/ChapterData';

/**
 * 绠＄悊鍦板浘鐩稿叧鐨?UI 鐘舵€侊細杩涘害銆侀€変腑鏍囩鍙婄劍鐐硅妭鐐?
 */
export function useMapProgress() {
  const [mapProgress, setMapProgress] = useState<MapProgressState>(() =>
    createInitialMapProgress(MAP_CHAPTERS),
  );
  const [activeTab, setActiveTab] = useState<ActiveTab>('map');
  const [focusMapNode, setFocusMapNode] = useState<string | null>(null);

  return {
    mapProgress,
    setMapProgress,
    activeTab,
    setActiveTab,
    focusMapNode,
    setFocusMapNode,
  } as const;
}


===================== [D:\download\LootingRPG\src\hooks\profile\useProfileSave.ts] =====================
import type { GameState, MapProgressState, SavePayload, SaveProfile } from '../../shared/types/game';
import { createInitialMapProgress, normalizeMapProgress } from '../../domains/map/services/progress';
import { ACTIVE_PROFILE_KEY, PROFILE_INDEX_KEY, STORAGE_KEY } from '../../config/runtime/storage';
import { createFreshInitialState, normalizeGameState } from '../../app/state';
import { createAutoSellQualityMap } from '../../domains/inventory/services/autoSell';
import { recalculatePlayerStats } from '../../domains/player/services/recalculatePlayerStats';
import { MAP_CHAPTERS } from '../../config/map/ChapterData';
import { useState, useEffect } from 'react';
/// 涓汉瀛樻。绠＄悊閫昏緫锛屽寘鍚垱寤?鍔犺浇/淇濆瓨/鍒犻櫎瀛樻。锛屼互鍙婂鍏ュ鍑哄姛鑳?interface UseProfileSaveParams {
  gameState: GameState; logs: string[]; autoSellQualities: Record<string, boolean>; mapProgress: MapProgressState;
  setGameState: React.Dispatch<React.SetStateAction<GameState>>;
  setLogs:      React.Dispatch<React.SetStateAction<string[]>>;
  setAutoSellQualities: React.Dispatch<React.SetStateAction<Record<string, boolean>>>;
  setMapProgress:  React.Dispatch<React.SetStateAction<MapProgressState>>;
  addLog: (msg: string) => void;
}
/// 瀛樻。閿悕鐢熸垚鍑芥暟锛屽熀浜?profileId 鐢熸垚瀵瑰簲鐨?localStorage 閿悕
const getProfileSaveKey = (profileId: string) => `${STORAGE_KEY}_${profileId}`;
/// 涓汉瀛樻。绠＄悊 Hook锛屾彁渚涘瓨妗ｅ垪琛ㄣ€佸綋鍓嶆椿璺冨瓨妗?ID銆佽璇佺姸鎬侊紝浠ュ強鐧诲綍/鍒涘缓/鍒犻櫎/瀵煎叆/瀵煎嚭瀛樻。鐨勫鐞嗗嚱鏁?export function useProfileSave({
  gameState, logs, autoSellQualities, mapProgress,
  setGameState, setLogs, setAutoSellQualities, setMapProgress, addLog,
}: UseProfileSaveParams) {
  const [profiles, setProfiles] = useState<SaveProfile[]>([]);
  const [activeProfileId, setActiveProfileId] = useState<string | null>(null);
  const [isAuthenticated, setIsAuthenticated] = useState(false);

  const handleLogout = () => {
    setIsAuthenticated(false);
    setActiveProfileId(null);
  };
  /// 鍒濆鍔犺浇锛氫粠 localStorage 璇诲彇瀛樻。鍒楄〃鍜屾渶鍚庢椿璺冪殑瀛樻。 ID锛屽皾璇曞姞杞藉搴斿瓨妗?  useEffect(() => {
    const profileText = localStorage.getItem(PROFILE_INDEX_KEY);
    const lastProfileId = localStorage.getItem(ACTIVE_PROFILE_KEY);
    if (profileText) {
      try {
        const parsed = JSON.parse(profileText) as SaveProfile[];
        const nextProfiles = Array.isArray(parsed) ? parsed : [];
        setProfiles(nextProfiles);

        if (lastProfileId && nextProfiles.some((profile) => profile.id === lastProfileId)) {
          setActiveProfileId(lastProfileId);
          setIsAuthenticated(true);
          loadProfile(lastProfileId);
        }
      } catch {
        setProfiles([]);
      }
    }
  }, []);

  useEffect(() => {
    if (!isAuthenticated || !activeProfileId) return;

    const profileKey = getProfileSaveKey(activeProfileId);
    const profileExists = Boolean(localStorage.getItem(profileKey));
    if (!profileExists) {
      const freshGameState = createFreshInitialState();
      const freshLogs = ['[System] Local save cache cleared. Rebuilt with latest initial state.'];
      const freshMapProgress = createInitialMapProgress(MAP_CHAPTERS);
      const freshAutoSell = createAutoSellQualityMap();

      setGameState(freshGameState);
      setLogs(freshLogs);
      setMapProgress(freshMapProgress);
      setAutoSellQualities(freshAutoSell);

      localStorage.setItem(
        profileKey,
        JSON.stringify({
          gameState: freshGameState,
          logs: freshLogs,
          autoSellQualities: freshAutoSell,
          mapProgress: freshMapProgress,
        } satisfies SavePayload),
      );

      setProfiles((prev) => {
        const next = prev.map((profile) =>
          profile.id === activeProfileId ? { ...profile, updatedAt: Date.now() } : profile,
        );
        localStorage.setItem(PROFILE_INDEX_KEY, JSON.stringify(next));
        return next;
      });

      addLog('Local cache was empty. Rebuilt save with latest initial state.');
      return;
    }

    const payload: SavePayload = { gameState, logs, autoSellQualities, mapProgress };
    localStorage.setItem(getProfileSaveKey(activeProfileId), JSON.stringify(payload));

    setProfiles((prev) => {
      const next = prev.map((profile) =>
        profile.id === activeProfileId ? { ...profile, updatedAt: Date.now() } : profile,
      );
      localStorage.setItem(PROFILE_INDEX_KEY, JSON.stringify(next));
      return next;
    });
  }, [activeProfileId, autoSellQualities, gameState, isAuthenticated, logs, mapProgress]);

  const convertAutoSell = (orig: Record<string, boolean> = {}) => {
    const base = createAutoSellQualityMap();
    Object.entries(orig).forEach(([k, v]) => {
      if (k in base) {
        base[k] = v;
      }
    });
    return base;
  };

  const loadProfile = (profileId: string) => {
    const payloadText = localStorage.getItem(getProfileSaveKey(profileId));
    if (!payloadText) {
      setGameState(createFreshInitialState());
      setLogs(['[System] New player save created.']);
      setAutoSellQualities(createAutoSellQualityMap());
      setMapProgress(createInitialMapProgress(MAP_CHAPTERS));
      return;
    }

    try {
      const payload = JSON.parse(payloadText) as SavePayload;
      setGameState(recalculatePlayerStats(normalizeGameState(payload.gameState)));
      setLogs(payload.logs?.length ? payload.logs : ['[System] Save loaded.']);
      setAutoSellQualities(convertAutoSell(payload.autoSellQualities));
      setMapProgress(normalizeMapProgress(payload.mapProgress, MAP_CHAPTERS));
    } catch {
      setGameState(createFreshInitialState());
      setLogs(['[System] Save data corrupted. Reset to a fresh save.']);
      setAutoSellQualities(createAutoSellQualityMap());
      setMapProgress(createInitialMapProgress(MAP_CHAPTERS));
    }
  };


  const handleLogin = (profileId: string) => {
    setActiveProfileId(profileId);
    setIsAuthenticated(true);
    loadProfile(profileId);
    localStorage.setItem(ACTIVE_PROFILE_KEY, profileId);
  };

  const handleCreateProfile = (name: string) => {
    const id = `profile_${Date.now()}`;
    const profile: SaveProfile = {
      id,
      name,
      updatedAt: Date.now(),
    };

    setProfiles((prev) => {
      const next = [profile, ...prev];
      localStorage.setItem(PROFILE_INDEX_KEY, JSON.stringify(next));
      return next;
    });

    localStorage.setItem(
      getProfileSaveKey(id),
      JSON.stringify({
        gameState: createFreshInitialState(),
        logs: ['[System] New player save created.'],
        mapProgress: createInitialMapProgress(MAP_CHAPTERS),
      } satisfies SavePayload),
    );
    handleLogin(id);
  };

  const handleDeleteProfile = (profileId: string) => {
    setProfiles((prev) => {
      const next = prev.filter((profile) => profile.id !== profileId);
      localStorage.setItem(PROFILE_INDEX_KEY, JSON.stringify(next));
      return next;
    });

    localStorage.removeItem(getProfileSaveKey(profileId));

    if (activeProfileId === profileId) {
      setIsAuthenticated(false);
      setActiveProfileId(null);
      setGameState(createFreshInitialState());
      setLogs(['[System] Please sign in to a player save.']);
      setAutoSellQualities(createAutoSellQualityMap());
      setMapProgress(createInitialMapProgress(MAP_CHAPTERS));
    }
  };

  const handleExportSave = () => {
    if (!activeProfileId) return;
    const payload: SavePayload = {
      gameState,
      logs,
      autoSellQualities,
      mapProgress,
    };

    const data = JSON.stringify(payload, null, 2);
    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `LootingRPG_Save.json`;
    link.click();
    URL.revokeObjectURL(url);
    addLog('Save exported as JSON file.');
  };

  const handleImportSave = () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'application/json';
    input.onchange = async (event) => {
      const file = (event.target as HTMLInputElement).files?.[0];
      if (!file) return;

      try {
        const text = await file.text();
        const parsed = JSON.parse(text) as SavePayload;

        const isRecord = (value: unknown): value is Record<string, unknown> => {
          return typeof value === 'object' && value !== null;
        };

        if (!isRecord(parsed) || !('gameState' in parsed)) {
          throw new Error('Invalid save payload');
        }

        const payload = parsed;
        loadProfile('');
        setGameState(recalculatePlayerStats(normalizeGameState(payload.gameState)));
        setLogs(payload.logs?.length ? payload.logs : ['[System] Save imported successfully.']);
        setAutoSellQualities(payload.autoSellQualities ?? createAutoSellQualityMap());
        setMapProgress(normalizeMapProgress(payload.mapProgress, MAP_CHAPTERS));
        addLog('Save imported from JSON file.');
      } catch {
        addLog('Import failed: invalid JSON payload.');
      }
    };
    input.click();
  };

  return {
    profiles,
    activeProfileId,
    isAuthenticated,
    handleLogin, handleCreateProfile, handleDeleteProfile, handleExportSave, handleImportSave, loadProfile, handleLogout,
  };
}


===================== [D:\download\LootingRPG\src\infra\i18n\labels.ts] =====================
import { t } from 'i18next';

export const getQualityLabel = (qualityKey: string): string => t(`quality.${qualityKey}`);
export const getSlotLabel = (slotKey: string): string => t(`slot.${slotKey}`);
export const getStatLabel = (statKey: string): string => t(`stat.${statKey}`);


===================== [D:\download\LootingRPG\src\shared\types\assets.d.ts] =====================
declare module '*.csv?raw' {
  const content: string;
  export default content;
}


===================== [D:\download\LootingRPG\src\shared\types\game.ts] =====================
import type { EntityStats } from '../../config/game/monsterSchema';
import type { BattleUnitInstance } from '../../types/battle/BattleUnit';
export type { Monster } from '../../config/game/monsterSchema';
export type { MonsterTrait, MonsterBaseStats, MonsterScalingProfile, ThreatType, BossIdentity, BossCounterGoal, CounterStatKey, EntityStats, ScalingProfileStats } from '../../config/game/monsterSchema';

export type BattlePhase =
  | 'player_input'
  | 'resolving'
  | 'enemy_turn'
  | 'finished';

export interface BattleAction {
  id: string;
  type: 'basic_attack' | 'skill' | 'passive';
  sourceId: string;
  targetIds: string[];
  payload?: Record<string, unknown>;
}

export type ApplyDamageEvent = {
  type: 'apply_damage';
  sourceId: string;
  targetId: string;
  amount: number;
};

export type ApplyHealEvent = {
  type: 'apply_heal';
  sourceId: string;
  targetId: string;
  amount: number;
};

export type UnitDiedEvent = {
  type: 'unit_died';
  unitId: string;
};

export type TurnEndEvent = {
  type: 'turn_end';
};

export type BattleEvent = ApplyDamageEvent | ApplyHealEvent | UnitDiedEvent | TurnEndEvent;

export interface PlayerStats extends EntityStats     {
  level: number;
  xp: number;
  critRate: string;
  damageBonus: number;
  lifesteal: number;
  thorns: number;
  elemental: number;
  attackSpeed: number;
  gold: number;
}
export type EquipmentAffix = 'crit_chance' | 'lifesteal' | 'damage_bonus' | 'thorns' | 'hp_bonus';
export interface EquipmentAffixValue {
  type: EquipmentAffix;
  value: number;
}
export interface Equipment {
  id: string;
  icon: string;
  level: number;
  name: string;
  quality: string;
  slot: string;
  attributes: Record<string, number>;
  special?: string;
  affixes: EquipmentAffixValue[];
  enhancementLevel: number;
  mainStat: string;
  equipped: boolean;
  localeNames?: {
    zh?: string;
    en?: string;
  };
}

export type BattleSessionStatus = 'fighting' | 'victory' | 'defeat';

export interface BattleSession {
  id: string;            // 鍞竴鏍囪瘑绗︼紝鏍煎紡涓?"battle_timestamp"
  chapterId: string;     // 鎵€灞炵珷鑺侷D
  chapterName: string;   // 鎵€灞炵珷鑺傚悕绉帮紙鍐椾綑瀛楁锛屼究浜庡揩閫熻闂級
  nodeId: string;        // 鎵€灞炶妭鐐笽D
  nodeName: string;      // 鎵€灞炶妭鐐瑰悕绉帮紙鍐椾綑瀛楁锛屼究浜庡揩閫熻闂級
  encounterType: string; // 閬亣绫诲瀷锛堜緥濡?"normal"銆?elite"銆?boss"锛夛紝鐢ㄤ簬鍖哄垎涓嶅悓鐨勬垬鏂楀満鏅拰瑙勫垯
  turn: number;          // 褰撳墠鍥炲悎鏁帮紝浠?寮€濮嬮€掑
  phase: BattlePhase;
  player: BattleUnitInstance;
  enemies: BattleUnitInstance[];
  waveOrder: string[];         // 娉㈡椤哄簭鍒楄〃锛岃褰曞綋鍓嶆垬鏂椾腑鏁屼汉鎵€灞炵殑娉㈡椤哄簭锛屼究浜庡湪鎴樻枟鏃ュ織鍜岀晫闈笂鏄剧ず褰撳墠娉㈡鐘舵€?  currentWaveIndex: number;    // 褰撳墠娉㈡绱㈠紩锛屾寚绀虹帺瀹舵鍦ㄩ潰瀵瑰摢涓尝娆＄殑鏁屼汉锛屾垬鏂楄繃绋嬩腑浼氭牴鎹晫浜鸿鍑昏触鐨勬儏鍐佃繘琛屾洿鏂?  status: BattleSessionStatus; // 鎴樻枟鐘舵€侊紝鎸囩ず褰撳墠鎴樻枟鏄繘琛屼腑銆佽儨鍒┿€佸け璐ヨ繕鏄挙閫€锛屾垬鏂楄繃绋嬩腑浼氭牴鎹帺瀹跺拰鏁屼汉鐨勭姸鎬佽繘琛屾洿鏂?  events: BattleEvent[];
  logs: string[];              // 鎴樻枟鏃ュ織锛岃褰曟垬鏂楄繃绋嬩腑鍙戠敓鐨勪簨浠跺拰鎿嶄綔锛屼究浜庡洖鏀惧拰璋冭瘯
}

export interface BattleResult {
  sessionId: string;
  chapterId: string;
  nodeId: string;
  won: boolean;
  turns: number;
  xpGained: number;
  goldGained: number;
  finishedAt: number;
}
export interface BattleState {
  activeSession: BattleSession | null;
  history: BattleResult[];
}
export interface GameState {
  playerStats: PlayerStats;
  droppedEquipment: Equipment | null;
  backpack: Equipment[];
  systemMessage: string;
  currentEquipment: Record<string, Equipment | null>;
  pityCounts: {
    legendary: number;
    mythic: number;
  };
  battle: BattleState;
}
export type ActiveTab = 'map' | 'inventory' | 'forge' | 'codex';
export interface SaveProfile { id: string; name: string; updatedAt: number}

export interface MapProgressState {
  selectedChapterId: string;
  unlockedChapters: string[];
  unlockedNodes: string[];
  clearedNodes: string[];
  failedAttempts: Record<string, number>;
}

export interface SavePayload {
  gameState: GameState;
  logs: string[];
  autoSellQualities?: Record<string, boolean>;
  mapProgress?: MapProgressState;
}


===================== [D:\download\LootingRPG\src\types\battle\BattleUnit.ts] =====================
export interface BaseStats {
  hp: number
  attack: number
  defense: number
}

export interface BattleDerivedStats {
  damageReduction: number
  critRate?: number
  lifestealRate?: number
  thornsRate?: number
  elementalBonus?: number
}

export type Faction = 'player' | 'monster'

export interface BattleUnitInstance {
  id: string
  name: string
  faction: Faction
  level: number
  baseStats: BaseStats
  currentHp: number
  derivedStats: BattleDerivedStats
  skills: string[]
  passives: string[]
  elements: string[]
  tags: string[]
  meta?: Record<string, unknown>
}

export interface BattleUnitSchema {
  id: string
  name: string
  faction: Faction
  baseStats: BaseStats
  skills: string[]
  passives?: string[]
  elements?: string[]
  tags?: string[]
  aiProfile?: string
  derivedStats?: BattleDerivedStats
  meta?: Record<string, unknown>
}


===================== [D:\download\LootingRPG\src\types\game.ts] =====================
export * from '../shared/types/game';


===================== [D:\download\LootingRPG\src\App.tsx] =====================
import { ThemeProvider } from './config/themes/ThemeContext';
import { AppShell } from './app/AppShell';
import { GameProvider } from './app/GameContext';

export default function App() {
  return (
    <ThemeProvider>
      <GameProvider>
        <AppShell />
      </GameProvider>
    </ThemeProvider>
  );
}


===================== [D:\download\LootingRPG\src\i18n.ts] =====================
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';
import zhTranslation from '@data/locales/zh/translation.json';
import enTranslation from '@data/locales/en/translation.json';
const resources = {
  zh: { translation: zhTranslation },
  en: { translation: enTranslation },
};
i18n.use(initReactI18next).init({
  resources,
  lng: 'zh',
  fallbackLng: 'en',
  interpolation: {
    escapeValue: false,
  },
});

export default i18n;


===================== [D:\download\LootingRPG\src\main.tsx] =====================
import {StrictMode} from 'react';
import {createRoot} from 'react-dom/client';
import './i18n';  // initialize internationalization before app modules
import App from './App.tsx';
import './index.css';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
);
