# LootingRPG 项目换血计划（降耦合 / 降复杂度 / 可持续迭代）

> 目标：
> 1) 逻辑清晰（业务边界明确，状态流单向）
> 2) 减少耦合（UI 与业务逻辑分离，核心逻辑可测试）
> 3) 减少代码（删除重复模块，统一模型，降低维护成本）

---

## 一、当前问题画像（为什么会变“屎山”）

### 1. 状态与模型分裂
- 同一业务（战斗、背包、地图）在多个目录有重叠定义，导致“改 A 炸 B”。
- 类型定义与运行时字段可能长期漂移，TS 只能兜底一部分问题。

### 2. UI 与业务逻辑耦合过深
- 一些流程控制（阶段切换、结算、副作用）混在组件/hook 中，难复用、难测试。
- 视图层承担了太多业务职责，导致组件一改动就牵扯全局。

### 3. 历史代码路径残留
- 老模块没被真正下线，存在“名义不用、实际仍被引用”的风险。
- 新旧实现并存，团队很难判断“哪条才是标准路径”。

### 4. 缺乏演进护栏
- 没有稳定的架构分层约束（依赖方向不清），新增功能容易绕过边界。
- 验证流程偏弱，技术债持续累积。

---

## 二、换血总体策略（不是推倒重来）

采用 **“双轨渐进替换”**：

- **主轨：业务不停机**（保证现有玩法可持续迭代）
- **副轨：新内核并行落地**（按域逐步替换旧实现）

每次迭代遵循三条规则：
1. **先建边界，再搬代码**。
2. **新代码只进新目录，不再给旧目录加功能**。
3. **每替换一块，就删除对应旧块（不做“永久兼容层”）**。

---

## 三、目标架构（建议落地目录）

```txt
src/
  app/                    # 组装层（路由、Provider、页面装配）
  domains/
    battle/
      model/              # 类型与领域对象（唯一来源）
      services/           # 纯业务服务（无 React 依赖）
      reducers/           # 状态演进（纯函数）
      ports/              # 外部能力接口（存储、随机数、日志）
      ui/                 # battle 相关展示组件
    inventory/
    map/
    player/
  shared/
    types/
    utils/
    ui/
  infra/
    storage/
    i18n/
    telemetry/
```

### 依赖方向（必须强约束）
- `ui -> domain services/reducers`
- `domain -> ports`
- `infra -> ports 实现`
- **禁止**：domain 反向依赖 React/UI。

---

## 四、4 个阶段的换血计划（8~10 周）

### 当前阶段进度（每次对话结束更新）
- [x] Phase 0（盘点 + 冻结）
- -- Phase 0.5（执行化推进：Issue 化、巡检模板、orphan 清理）
- -- Phase 1（统一模型）
- [ ] Phase 2（逻辑剥离）
- [ ] Phase 3（删除旧链路 + 收敛目录）
- [ ] Phase 4（质量护栏）

## Phase 0（第 1 周）：盘点 + 冻结 ✅已完成
**目标**：停止债务继续增长。

- 输出“模块现状清单”：每个模块标记为 `保留 / 合并 / 删除 / 待迁移`。
- 设立“旧目录冻结规则”：仅允许 bugfix，不允许新功能进入旧链路。
- 建立变更台账：每次迁移都记录“来源文件 -> 新文件 -> 删除时间”。

**交付物**：
- 《模块清单.xlsx/markdown》
- 《冻结规则.md》
- 《迁移台账.md》

---

## Phase 1（第 2~3 周）：统一模型（先把“词典”统一） --进行中
**目标**：同一个概念只定义一次。

**本轮进展（2026-02-25）**：
- [x] 建立 `src/domains/player/model/combat.ts`，承接玩家战斗计算模型
- [x] 建立 `src/domains/player/services/recalculatePlayerStats.ts`，承接玩家属性重算服务
- -- 旧入口保留兼容导出（`src/logic/playerStats.ts`、`src/logic/stats/playerStats.ts`），下一步逐步改调用方

- 统一核心领域类型：`BattleState / BattleResult / PlayerStats / Equipment / MapProgress`。
- 删除重复或冲突类型出口，建立单一导出入口（barrel）。
- 给核心状态增加 schema 校验（可选 zod），防止读档/版本升级时破坏数据。

**完成标准（DoD）**：
- 核心域类型只有 1 套来源。
- 旧类型别名全部标记 deprecated，并排期删除。

---

## Phase 2（第 4~6 周）：逻辑剥离（减耦合关键阶段）
**目标**：把业务从 UI/hook 中抽离为可测试纯逻辑。

- 将战斗流程拆成：
  - `battle/services`：数值结算、回合推进、奖励计算（纯函数）
  - `battle/reducers`：状态机（idle/fighting/victory/defeat...）
- hook 只做 orchestration（调服务、发 action、触发 UI 更新）。
- 地图 / 背包按同样模式推进，避免“战斗先先进化，其他域继续旧模式”。

**完成标准（DoD）**：
- 主要业务函数可以脱离 React 单测。
- 组件代码量显著下降（以职责为主，不要求绝对行数）。

---

## Phase 3（第 7~8 周）：删除旧链路 + 收敛目录
**目标**：减少代码总量，去掉双轨维护成本。

- 按迁移台账逐条删除旧文件。
- 清理失效导出、失效文档、失效脚本、失效配置。
- 统一导入路径（别名/索引文件），减少“到处相对路径穿透”。

**完成标准（DoD）**：
- 新架构覆盖主流程：登录、地图、战斗、掉落、背包、锻造。
- 旧链路不再被引用（可用脚本检查 orphan import）。

---

## Phase 4（第 9~10 周）：质量护栏（防止再次烂掉）
**目标**：把“好状态”固化为工程制度。

- CI 最低门槛：`typecheck + build + smoke test`。
- ESLint 架构规则：禁止跨层依赖、禁止 domain 引入 UI。
- PR 模板强制三件事：
  1) 改动属于哪个域
  2) 是否新增耦合
  3) 是否删除了旧代码

**完成标准（DoD）**：
- 新需求默认走新架构，不再回流旧目录。
- 每个迭代都能看到净删除代码（而不是只增不减）。

---

## 五、减代码的具体策略（你最关心的）

### 1) 一进一出规则（强制）
- 每新增一个新模块，必须关联删除至少一个旧模块或旧导出。

### 2) 三类可优先删除对象
1. **重复实现**：同一功能多版本函数。
2. **壳模块**：只做透传、没有语义价值的 wrapper。
3. **历史兼容分支**：已无人使用但仍在代码里保留的分支。

### 3) 代码量指标（建议）
- 目标不是“行数越少越好”，而是“**重复逻辑和无效路径下降**”。
- 推荐跟踪：
  - 重复函数数（按签名/语义）
  - 无引用文件数
  - 超长函数（>120 行）数量
  - `any` 新增数量（必须为 0）

---

## 六、风险与回滚策略

### 风险 1：迁移过程中功能回退
- 方案：对关键流程做 smoke case（开局 -> 进图 -> 战斗 -> 掉落 -> 背包变化）。

### 风险 2：新旧状态不兼容导致存档损坏
- 方案：存档版本号 + 迁移脚本（`vN -> vN+1`）+ 回滚读取策略。

### 风险 3：团队执行跑偏
- 方案：每周一次“架构巡检”，只看边界与删除量，不讨论 UI 细节。

---

## 七、第一周可直接执行的 TODO（开工清单）

1. 建立 `domains/*` 目录骨架与依赖约束文档。
2. 梳理现有类型来源，定版 `shared/types` 或 `domains/*/model`。
3. 把“战斗奖励计算”先抽成纯函数并补 3~5 个单测样例。
4. 增加 orphan import 检查脚本（用于发现可删旧文件）。
5. 在 PR 模板加入“是否删除旧代码”必答项。

---

## 八、成功标准（你怎么判断换血成功）

- 开发新功能时，能快速定位到唯一模块，不再“猜在哪改”。
- 单个功能改动影响面可预测（不是到处修编译）。
- 仓库代码总量趋稳或下降，且玩法迭代速度不降。
- 新同学 1~2 天能跑通核心开发流并提交有效改动。

---

如果你愿意，我下一步可以直接给你出：
1) **按你现仓库结构的“保留/合并/删除”清单（逐文件）**，
2) **一版 battle 域的目标文件模板**（你可以直接开始迁移）。
